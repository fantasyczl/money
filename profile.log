SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/ftplugin/php.vim
Sourced 2 times
Total time:   0.007236
 Self time:   0.005206

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	php
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    2              0.000025 if exists("b:did_ftplugin") | finish | endif
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    2              0.000024 let s:keepcpo= &cpo
    2              0.000045 set cpo&vim
                            
                            " Define some defaults in case the included ftplugins don't set them.
    2              0.000011 let s:undo_ftplugin = ""
    2              0.000032 let s:browsefilter = "HTML Files (*.html, *.htm)\t*.html;*.htm\n" .
                            	    \	     "All Files (*.*)\t*.*\n"
    2              0.000003 let s:match_words = ""
                            
    2   0.005686   0.003656 runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
    2              0.000014 let b:did_ftplugin = 1
                            
                            " Override our defaults if these were set by an included ftplugin.
    2              0.000011 if exists("b:undo_ftplugin")
    2              0.000006     let s:undo_ftplugin = b:undo_ftplugin
    2              0.000003 endif
    2              0.000013 if exists("b:browsefilter")
                                let s:browsefilter = b:browsefilter
                            endif
    2              0.000005 if exists("b:match_words")
                                let s:match_words = b:match_words
                            endif
    2              0.000005 if exists("b:match_skip")
                                unlet b:match_skip
                            endif
                            
                            " Change the :browse e filter to primarily show PHP-related files.
    2              0.000009 if has("gui_win32")
                                let  b:browsefilter="PHP Files (*.php)\t*.php\n" . s:browsefilter
                            endif
                            
                            " ###
                            " Provided by Mikolaj Machowski <mikmach at wp dot pl>
    2              0.000014 setlocal include=\\\(require\\\|include\\\)\\\(_once\\\)\\\?
                            " Disabled changing 'iskeyword', it breaks a command such as "*"
                            " setlocal iskeyword+=$
                            
    2              0.000005 if exists("loaded_matchit")
                                let b:match_words = '<?php:?>,\<switch\>:\<endswitch\>,' .
                            		      \ '\<if\>:\<elseif\>:\<else\>:\<endif\>,' .
                            		      \ '\<while\>:\<endwhile\>,' .
                            		      \ '\<do\>:\<while\>,' .
                            		      \ '\<for\>:\<endfor\>,' .
                            		      \ '\<foreach\>:\<endforeach\>,' .
                                                  \ '(:),[:],{:},' .
                            		      \ s:match_words
                            endif
                            " ###
                            
    2              0.000005 if exists('&omnifunc')
    2              0.000006   setlocal omnifunc=phpcomplete#CompletePHP
    2              0.000001 endif
                            
                            " Section jumping: [[ and ]] provided by Antony Scriven <adscriven at gmail dot com>
    2              0.000010 let s:function = '\(abstract\s\+\|final\s\+\|private\s\+\|protected\s\+\|public\s\+\|static\s\+\)*function'
    2              0.000016 let s:class = '\(abstract\s\+\|final\s\+\)*class'
    2              0.000183 let s:interface = 'interface'
    2              0.000018 let s:section = '\(.*\%#\)\@!\_^\s*\zs\('.s:function.'\|'.s:class.'\|'.s:interface.'\)'
    2              0.000099 exe 'nno <buffer> <silent> [[ ?' . escape(s:section, '|') . '?<CR>:nohls<CR>'
    2              0.000058 exe 'nno <buffer> <silent> ]] /' . escape(s:section, '|') . '/<CR>:nohls<CR>'
    2              0.000053 exe 'ono <buffer> <silent> [[ ?' . escape(s:section, '|') . '?<CR>:nohls<CR>'
    2              0.000050 exe 'ono <buffer> <silent> ]] /' . escape(s:section, '|') . '/<CR>:nohls<CR>'
                            
    2              0.000009 setlocal commentstring=/*%s*/
                            
                            " Undo the stuff we changed.
    2              0.000012 let b:undo_ftplugin = "setlocal commentstring< include< omnifunc<" .
                            	    \	      " | unlet! b:browsefilter b:match_words | " .
                            	    \	      s:undo_ftplugin
                            
                            " Restore the saved compatibility options.
    2              0.000110 let &cpo = s:keepcpo
    2              0.000012 unlet s:keepcpo

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/ftplugin/html.vim
Sourced 2 times
Total time:   0.001958
 Self time:   0.001628

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	html
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    2              0.000023 if exists("b:did_ftplugin") | finish | endif
    2              0.000008 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    2              0.000012 let s:save_cpo = &cpo
    2              0.000259 set cpo-=C
                            
    2              0.000048 setlocal matchpairs+=<:>
    2              0.000013 setlocal commentstring=<!--%s-->
    2              0.000169 setlocal comments=s:<!--,m:\ \ \ \ ,e:-->
                            
    2              0.000012 if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
                                setlocal formatoptions-=t formatoptions+=croql
                            endif
                            
    2              0.000007 if exists('&omnifunc')
    2              0.000013   setlocal omnifunc=htmlcomplete#CompleteTags
    2   0.000629   0.000299   call htmlcomplete#DetectOmniFlavor()
    2              0.000003 endif
                            
                            " HTML:  thanks to Johannes Zellner and Benji Fisher.
    2              0.000007 if exists("loaded_matchit")
                                let b:match_ignorecase = 1
                                let b:match_words = '<:>,' .
                                \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
                                \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
                                \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
                            endif
                            
                            " Change the :browse e filter to primarily show HTML-related files.
    2              0.000010 if has("gui_win32")
                                let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"Cascading StyleSheets (*.css)\t*.css\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                            
                            " Undo the stuff we changed.
    2              0.000015 let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
                                \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"
                            
                            " Restore the saved compatibility options.
    2              0.000017 let &cpo = s:save_cpo
    2              0.000014 unlet s:save_cpo

SCRIPT  /Users/czl/.vim/bundle/nerdtree/syntax/nerdtree.vim
Sourced 1 time
Total time:   0.001582
 Self time:   0.001582

count  total (s)   self (s)
    1              0.000027 let s:tree_up_dir_line = '.. (up a dir)'
    1              0.000047 syn match NERDTreeIgnore #\~#
    1              0.000020 exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
                            
                            "highlighting for the .. (up dir) line at the top of the tree
    1              0.000025 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
                            
                            "quickhelp syntax elements
    1              0.000015 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
    1              0.000010 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
    1              0.000010 syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
    1              0.000010 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
    1              0.000010 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
    1              0.000012 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    1              0.000080 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for sym links
    1              0.000034 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
    1              0.000021 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
    1              0.000021 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
                            
                            "highlighing for directory nodes and file nodes
    1              0.000020 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
                            
    1              0.000043 exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    1              0.000039 exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
                            
    1              0.000012 let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
    1              0.000018 exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
    1              0.000035 syn match NERDTreeExecFile  #^ .*\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark
    1              0.000064 exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
                            
                            "highlighting for readonly files
    1              0.000050 exec 'syn match NERDTreeRO # *\zs.*\ze \['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'
                            
    1              0.000045 syn match NERDTreeFlags #^ *\zs\[.\]# containedin=NERDTreeFile,NERDTreeExecFile
    1              0.000023 syn match NERDTreeFlags #\[.\]# containedin=NERDTreeDir
                            
    1              0.000018 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
    1              0.000010 syn match NERDTreeBookmark # {.*}#hs=s+1
                            
                            "highlighting for the bookmarks table
    1              0.000009 syn match NERDTreeBookmarksLeader #^>#
    1              0.000023 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    1              0.000022 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    1              0.000043 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
    1              0.000020 hi def link NERDTreePart Special
    1              0.000014 hi def link NERDTreePartFile Type
    1              0.000015 hi def link NERDTreeExecFile Title
    1              0.000014 hi def link NERDTreeDirSlash Identifier
                            
    1              0.000014 hi def link NERDTreeBookmarksHeader statement
    1              0.000013 hi def link NERDTreeBookmarksLeader ignore
    1              0.000014 hi def link NERDTreeBookmarkName Identifier
    1              0.000013 hi def link NERDTreeBookmark normal
                            
    1              0.000013 hi def link NERDTreeHelp String
    1              0.000013 hi def link NERDTreeHelpKey Identifier
    1              0.000013 hi def link NERDTreeHelpCommand Identifier
    1              0.000013 hi def link NERDTreeHelpTitle Macro
    1              0.000014 hi def link NERDTreeToggleOn Question
    1              0.000014 hi def link NERDTreeToggleOff WarningMsg
                            
    1              0.000013 hi def link NERDTreeLinkTarget Type
    1              0.000014 hi def link NERDTreeLinkFile Macro
    1              0.000013 hi def link NERDTreeLinkDir Macro
                            
    1              0.000014 hi def link NERDTreeDir Directory
    1              0.000014 hi def link NERDTreeUp Directory
    1              0.000014 hi def link NERDTreeFile Normal
    1              0.000013 hi def link NERDTreeCWD Statement
    1              0.000014 hi def link NERDTreeOpenable Directory
    1              0.000014 hi def link NERDTreeClosable Directory
    1              0.000014 hi def link NERDTreeIgnore ignore
    1              0.000014 hi def link NERDTreeRO WarningMsg
    1              0.000013 hi def link NERDTreeBookmark Statement
    1              0.000013 hi def link NERDTreeFlags Number
                            
    1              0.000025 hi def link NERDTreeCurrentNode Search

SCRIPT  /Users/czl/.vim/bundle/phpcd.vim/ftplugin/php_phpcd.vim
Sourced 2 times
Total time:   0.008019
 Self time:   0.001337

count  total (s)   self (s)
    2              0.000074 let s:save_cpo = &cpo
    2              0.000036 set cpo&vim
                            
    2              0.000079 silent! nnoremap <silent> <unique> <buffer> <C-]>
                            			\ :<C-u>call phpcd#JumpToDefinition('normal')<CR>
    2              0.000029 silent! nnoremap <silent> <unique> <buffer> <C-W><C-]>
                            			\ :<C-u>call phpcd#JumpToDefinition('split')<CR>
    2              0.000023 silent! nnoremap <silent> <unique> <buffer> <C-W><C-\>
                            			\ :<C-u>call phpcd#JumpToDefinition('vsplit')<CR>
    2              0.000020 silent! nnoremap <silent> <unique> <buffer> <C-t>
                            			\ :<C-u>call phpcd#JumpBack()<CR>
                            
    2              0.000019 command! -nargs=0 PHPID call phpcd#Index()
                            
    2              0.000016 if !get(g:, 'phpcd_auto_restart', 0)
    2   0.006796   0.000114 	call phpcd#OpenFileNoAutoRestart()
    2              0.000067 endif
                            
    2              0.000123 let &cpo = s:save_cpo
    2              0.000022 unlet s:save_cpo
                            
                            " vim: foldmethod=marker:noexpandtab:ts=2:sts=2:sw=2

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/indent/php.vim
Sourced 3 times
Total time:   0.001456
 Self time:   0.001331

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	PHP
                            " Author:	John Wellesz <John.wellesz (AT) teaser (DOT) fr>
                            " URL:		http://www.2072productions.com/vim/indent/php.vim
                            " Home:		https://github.com/2072/PHP-Indenting-for-VIm
                            " Last Change:	2018 May 18th
                            " Version:	1.66
                            "
                            "
                            "	Type :help php-indent for available options
                            "
                            "	A fully commented version of this file is available on github
                            "
                            "
                            "  If you find a bug, please open a ticket on github.com
                            "  ( https://github.com/2072/PHP-Indenting-for-VIm/issues ) with an example of
                            "  code that breaks the algorithm.
                            "
                            
                            " NOTE: This script must be used with PHP syntax ON and with the php syntax
                            "	script by Lutz Eymers (http://www.isp.de/data/php.vim ) or with the
                            "	script by Peter Hodge (http://www.vim.org/scripts/script.php?script_id=1571 )
                            "	the later is bunbdled by default with Vim 7.
                            "
                            "
                            "	In the case you have syntax errors in your script such as HereDoc end
                            "	identifiers not at col 1 you'll have to indent your file 2 times (This
                            "	script will automatically put HereDoc end identifiers at col 1 if
                            "	they are followed by a ';').
                            "
                            
                            " NOTE: If you are editing files in Unix file format and that (by accident)
                            "	there are '\r' before new lines, this script won't be able to proceed
                            "	correctly and will make many mistakes because it won't be able to match
                            "	'\s*$' correctly.
                            "	So you have to remove those useless characters first with a command like:
                            "
                            "	:%s /\r$//g
                            "
                            "	or simply 'let' the option PHP_removeCRwhenUnix to 1 and the script will
                            "	silently remove them when VIM load this script (at each bufread).
                            
                            
                            
    3              0.000040 if exists("b:did_indent")
    1              0.000002     finish
                            endif
    2              0.000011 let b:did_indent = 1
                            
                            
    2              0.000006 let g:php_sync_method = 0
                            
                            
    2              0.000011 if exists("PHP_default_indenting")
                                let b:PHP_default_indenting = PHP_default_indenting * shiftwidth()
                            else
    2              0.000006     let b:PHP_default_indenting = 0
    2              0.000002 endif
                            
    2              0.000007 if exists("PHP_outdentSLComments")
                                let b:PHP_outdentSLComments = PHP_outdentSLComments * shiftwidth()
                            else
    2              0.000011     let b:PHP_outdentSLComments = 0
    2              0.000002 endif
                            
    2              0.000006 if exists("PHP_BracesAtCodeLevel")
                                let b:PHP_BracesAtCodeLevel = PHP_BracesAtCodeLevel
                            else
    2              0.000005     let b:PHP_BracesAtCodeLevel = 0
    2              0.000002 endif
                            
                            
    2              0.000006 if exists("PHP_autoformatcomment")
                                let b:PHP_autoformatcomment = PHP_autoformatcomment
                            else
    2              0.000005     let b:PHP_autoformatcomment = 1
    2              0.000003 endif
                            
    2              0.000007 if exists("PHP_outdentphpescape")
                                let b:PHP_outdentphpescape = PHP_outdentphpescape
                            else
    2              0.000006     let b:PHP_outdentphpescape = 1
    2              0.000001 endif
                            
    2              0.000006 if exists("PHP_noArrowMatching")
                                let b:PHP_noArrowMatching = PHP_noArrowMatching
                            else
    2              0.000004     let b:PHP_noArrowMatching = 0
    2              0.000001 endif
                            
                            
    2              0.000009 if exists("PHP_vintage_case_default_indent") && PHP_vintage_case_default_indent
                                let b:PHP_vintage_case_default_indent = 1
                            else
    2              0.000006     let b:PHP_vintage_case_default_indent = 0
    2              0.000001 endif
                            
                            
                            
    2              0.000003 let b:PHP_lastindented = 0
    2              0.000006 let b:PHP_indentbeforelast = 0
    2              0.000005 let b:PHP_indentinghuge = 0
    2              0.000007 let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
    2              0.000005 let b:PHP_LastIndentedWasComment = 0
    2              0.000008 let b:PHP_InsideMultilineComment = 0
    2              0.000005 let b:InPHPcode = 0
    2              0.000004 let b:InPHPcode_checked = 0
    2              0.000004 let b:InPHPcode_and_script = 0
    2              0.000009 let b:InPHPcode_tofind = ""
    2              0.000007 let b:PHP_oldchangetick = b:changedtick
    2              0.000004 let b:UserIsTypingComment = 0
    2              0.000006 let b:optionsset = 0
                            
    2              0.000026 setlocal nosmartindent
    2              0.000010 setlocal noautoindent
    2              0.000006 setlocal nocindent
    2              0.000055 setlocal nolisp
                            
    2              0.000026 setlocal indentexpr=GetPhpIndent()
    2              0.000018 setlocal indentkeys=0{,0},0),0],:,!^F,o,O,e,*<Return>,=?>,=<?,=*/
                            
                            
                            
    2              0.000007 let s:searchpairflags = 'bWr'
                            
    2              0.000017 if &fileformat == "unix" && exists("PHP_removeCRwhenUnix") && PHP_removeCRwhenUnix
                                silent! %s/\r$//g
                            endif
                            
    2              0.000009 if exists("*GetPhpIndent")
    2   0.000172   0.000047     call ResetPhpOptions()
    2              0.000004     finish
                            endif
                            
                            
                            let s:PHP_validVariable = '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
                            let s:notPhpHereDoc = '\%(break\|return\|continue\|exit\|die\|else\)'
                            let s:blockstart = '\%(\%(\%(}\s*\)\=else\%(\s\+\)\=\)\=if\>\|\%(}\s*\)\?else\>\|do\>\|while\>\|switch\>\|case\>\|default\>\|for\%(each\)\=\>\|declare\>\|class\>\|trait\>\|use\>\|interface\>\|abstract\>\|final\>\|try\>\|\%(}\s*\)\=catch\>\|\%(}\s*\)\=finally\>\)'
                            let s:functionDecl = '\<function\>\%(\s\+&\='.s:PHP_validVariable.'\)\=\s*(.*'
                            let s:endline = '\s*\%(//.*\|#.*\|/\*.*\*/\s*\)\=$'
                            let s:unstated = '\%(^\s*'.s:blockstart.'.*)\|\%(//.*\)\@<!\<e'.'lse\>\)'.s:endline
                            
                            
                            let s:terminated = '\%(\%(;\%(\s*\%(?>\|}\)\)\=\|<<<\s*[''"]\=\a\w*[''"]\=$\|^\s*}\|^\s*'.s:PHP_validVariable.':\)'.s:endline.'\)'
                            let s:PHP_startindenttag = '<?\%(.*?>\)\@!\|<script[^>]*>\%(.*<\/script>\)\@!'
                            let s:structureHead = '^\s*\%(' . s:blockstart . '\)\|'. s:functionDecl . s:endline . '\|\<new\s\+class\>'
                            
                            
                            let s:escapeDebugStops = 0
                            function! DebugPrintReturn(scriptLine)
                            
                                if ! s:escapeDebugStops
                            	echo "debug:" . a:scriptLine
                            	let c = getchar()
                            	if c == "\<Del>"
                            	    let s:escapeDebugStops = 1
                            	end
                                endif
                            
                            endfunction
                            
                            function! GetLastRealCodeLNum(startline) " {{{
                            
                                let lnum = a:startline
                            
                                if b:GetLastRealCodeLNum_ADD && b:GetLastRealCodeLNum_ADD == lnum + 1
                            	let lnum = b:GetLastRealCodeLNum_ADD
                                endif
                            
                                while lnum > 1
                            	let lnum = prevnonblank(lnum)
                            	let lastline = getline(lnum)
                            
                            	if b:InPHPcode_and_script && lastline =~ '?>\s*$'
                            	    let lnum = lnum - 1
                            	elseif lastline =~ '^\s*?>.*<?\%(php\)\=\s*$'
                            	    let lnum = lnum - 1
                            	elseif lastline =~ '^\s*\%(//\|#\|/\*.*\*/\s*$\)'
                            	    let lnum = lnum - 1
                            	elseif lastline =~ '\*/\s*$'
                            	    call cursor(lnum, 1)
                            	    if lastline !~ '^\*/'
                            		call search('\*/', 'W')
                            	    endif
                            	    let lnum = searchpair('/\*', '', '\*/', s:searchpairflags, 'Skippmatch2()')
                            
                            	    let lastline = getline(lnum)
                            	    if lastline =~ '^\s*/\*'
                            		let lnum = lnum - 1
                            	    else
                            		break
                            	    endif
                            
                            
                            	elseif lastline =~? '\%(//\s*\|?>.*\)\@<!<?\%(php\)\=\s*$\|^\s*<script\>'
                            
                            	    while lastline !~ '\(<?.*\)\@<!?>' && lnum > 1
                            		let lnum = lnum - 1
                            		let lastline = getline(lnum)
                            	    endwhile
                            	    if lastline =~ '^\s*?>'
                            		let lnum = lnum - 1
                            	    else
                            		break
                            	    endif
                            
                            
                            	elseif lastline =~? '^\a\w*;\=$' && lastline !~? s:notPhpHereDoc
                            	    let tofind=substitute( lastline, '\(\a\w*\);\=', '<<<\\s*[''"]\\=\1[''"]\\=$', '')
                            	    while getline(lnum) !~? tofind && lnum > 1
                            		let lnum = lnum - 1
                            	    endwhile
                            	elseif lastline =~ '^[^''"`]*[''"`][;,]'.s:endline
                            
                            	    let tofind=substitute( lastline, '^.*\([''"`]\)[;,].*$', '^[^\1]\\+[\1]$\\|^[^\1]\\+[=([]\\s*[\1]', '')
                            	    let trylnum = lnum
                            	    while getline(trylnum) !~? tofind && trylnum > 1
                            		let trylnum = trylnum - 1
                            	    endwhile
                            
                            	    if trylnum == 1
                            		break
                            	    else
                            		if lastline =~ ';'.s:endline
                            		    while getline(trylnum) !~? s:terminated && getline(trylnum) !~? '{'.s:endline && trylnum > 1
                            			let trylnum = prevnonblank(trylnum - 1)
                            		    endwhile
                            
                            
                            		    if trylnum == 1
                            			break
                            		    end
                            		end
                            		let lnum = trylnum
                            	    end
                            	else
                            	    break
                            	endif
                                endwhile
                            
                                if lnum==1 && getline(lnum) !~ '<?'
                            	let lnum=0
                                endif
                            
                                if b:InPHPcode_and_script && 1 > b:InPHPcode
                            	let b:InPHPcode_and_script = 0
                                endif
                            
                                return lnum
                            endfunction " }}}
                            
                            function! Skippmatch2()
                            
                                let line = getline(".")
                            
                                if line =~ "\\([\"']\\).*/\\*.*\\1" || line =~ '\%(//\|#\).*/\*'
                            	return 1
                                else
                            	return 0
                                endif
                            endfun
                            
                            function! Skippmatch()	" {{{
                                let synname = synIDattr(synID(line("."), col("."), 0), "name")
                                if synname ==? "Delimiter" || synname ==? "phpRegionDelimiter" || synname =~? "^phpParent" || synname ==? "phpArrayParens" || synname =~? '^php\%(Block\|Brace\)' || synname ==? "javaScriptBraces" || synname =~? '^php\%(Doc\)\?Comment' && b:UserIsTypingComment
                            	return 0
                                else
                            	return 1
                                endif
                            endfun " }}}
                            
                            function! FindOpenBracket(lnum, blockStarter) " {{{
                                call cursor(a:lnum, 1)
                                let line = searchpair('{', '', '}', 'bW', 'Skippmatch()')
                            
                                if a:blockStarter == 1
                            	while line > 1
                            	    let linec = getline(line)
                            
                            	    if linec =~ s:terminated || linec =~ s:structureHead
                            		break
                            	    endif
                            
                            	    let line = GetLastRealCodeLNum(line - 1)
                            	endwhile
                                endif
                            
                                return line
                            endfun " }}}
                            
                            let s:blockChars = {'{':1, '[': 1, '(': 1, ')':-1, ']':-1, '}':-1}
                            function! BalanceDirection (str)
                            
                                let balance = 0
                            
                                for c in split(a:str, '\zs')
                            	if has_key(s:blockChars, c)
                            	    let balance += s:blockChars[c]
                            	endif
                                endfor
                            
                                return balance
                            endfun
                            
                            function! StripEndlineComments (line)
                                return substitute(a:line,"\\(//\\|#\\)\\(\\(\\([^\"']*\\([\"']\\)[^\"']*\\5\\)\\+[^\"']*$\\)\\|\\([^\"']*$\\)\\)",'','')
                            endfun
                            
                            function! FindArrowIndent (lnum)  " {{{
                            
                                let parrentArrowPos = 0
                                let lnum = a:lnum
                                while lnum > 1
                            	let last_line = getline(lnum)
                            	if last_line =~ '^\s*->'
                            	    let parrentArrowPos = indent(a:lnum)
                            	    break
                            	else
                            	    call cursor(lnum, 1)
                            	    let cleanedLnum = StripEndlineComments(last_line)
                            	    if cleanedLnum =~ '->'
                            		if ! b:PHP_noArrowMatching
                            		    let parrentArrowPos = searchpos('->', 'W', lnum)[1] - 1
                            		else
                            		    let parrentArrowPos = indent(lnum) + shiftwidth()
                            		endif
                            		break
                            	    elseif cleanedLnum =~ ')'.s:endline && BalanceDirection(last_line) < 0
                            		call searchpos(')'.s:endline, 'cW', lnum)
                            		let openedparent = searchpair('(', '', ')', 'bW', 'Skippmatch()')
                            		if openedparent != lnum
                            		    let lnum = openedparent
                            		else
                            		    let openedparent = -1
                            		endif
                            
                            	    else
                            		let parrentArrowPos = indent(lnum) + shiftwidth()
                            		break
                            	    endif
                            	endif
                                endwhile
                            
                                return parrentArrowPos
                            endfun "}}}
                            
                            function! FindTheIfOfAnElse (lnum, StopAfterFirstPrevElse) " {{{
                            
                                if getline(a:lnum) =~# '^\s*}\s*else\%(if\)\=\>'
                            	let beforeelse = a:lnum
                                else
                            	let beforeelse = GetLastRealCodeLNum(a:lnum - 1)
                                endif
                            
                                if !s:level
                            	let s:iftoskip = 0
                                endif
                            
                                if getline(beforeelse) =~# '^\s*\%(}\s*\)\=else\%(\s*if\)\@!\>'
                            	let s:iftoskip = s:iftoskip + 1
                                endif
                            
                                if getline(beforeelse) =~ '^\s*}'
                            	let beforeelse = FindOpenBracket(beforeelse, 0)
                            
                            	if getline(beforeelse) =~ '^\s*{'
                            	    let beforeelse = GetLastRealCodeLNum(beforeelse - 1)
                            	endif
                                endif
                            
                            
                                if !s:iftoskip && a:StopAfterFirstPrevElse && getline(beforeelse) =~# '^\s*\%([}]\s*\)\=else\%(if\)\=\>'
                            	return beforeelse
                                endif
                            
                                if getline(beforeelse) !~# '^\s*if\>' && beforeelse>1 || s:iftoskip && beforeelse>1
                            
                            	if s:iftoskip && getline(beforeelse) =~# '^\s*if\>'
                            	    let s:iftoskip = s:iftoskip - 1
                            	endif
                            
                            	let s:level =  s:level + 1
                            	let beforeelse = FindTheIfOfAnElse(beforeelse, a:StopAfterFirstPrevElse)
                                endif
                            
                                return beforeelse
                            
                            endfunction " }}}
                            
                            let s:defaultORcase = '^\s*\%(default\|case\).*:'
                            
                            function! FindTheSwitchIndent (lnum) " {{{
                            
                                let test = GetLastRealCodeLNum(a:lnum - 1)
                            
                                if test <= 1
                            	return indent(1) - shiftwidth() * b:PHP_vintage_case_default_indent
                                end
                            
                                while getline(test) =~ '^\s*}' && test > 1
                            	let test = GetLastRealCodeLNum(FindOpenBracket(test, 0) - 1)
                            
                            	if getline(test) =~ '^\s*switch\>'
                            	    let test = GetLastRealCodeLNum(test - 1)
                            	endif
                                endwhile
                            
                                if getline(test) =~# '^\s*switch\>'
                            	return indent(test)
                                elseif getline(test) =~# s:defaultORcase
                            	return indent(test) - shiftwidth() * b:PHP_vintage_case_default_indent
                                else
                            	return FindTheSwitchIndent(test)
                                endif
                            
                            endfunction "}}}
                            
                            let s:SynPHPMatchGroups = {'phpparent':1, 'delimiter':1, 'define':1, 'storageclass':1, 'structure':1, 'exception':1}
                            function! IslinePHP (lnum, tofind) " {{{
                                let cline = getline(a:lnum)
                            
                                if a:tofind==""
                            	let tofind = "^\\s*[\"'`]*\\s*\\zs\\S"
                                else
                            	let tofind = a:tofind
                                endif
                            
                                let tofind = tofind . '\c'
                            
                                let coltotest = match (cline, tofind) + 1
                            
                                let synname = synIDattr(synID(a:lnum, coltotest, 0), "name")
                            
                                if synname ==? 'phpStringSingle' || synname ==? 'phpStringDouble' || synname ==? 'phpBacktick'
                            	if cline !~ '^\s*[''"`]'
                            	    return "SpecStringEntrails"
                            	else
                            	    return synname
                            	end
                                end
                            
                                if get(s:SynPHPMatchGroups, tolower(synname)) || synname =~ '^php' ||  synname =~? '^javaScript'
                            	return synname
                                else
                            	return ""
                                endif
                            endfunction " }}}
                            
                            let s:autoresetoptions = 0
                            if ! s:autoresetoptions
                                let s:autoresetoptions = 1
                            endif
                            
                            function! ResetPhpOptions()
                                if ! b:optionsset && &filetype =~ "php"
                            	if b:PHP_autoformatcomment
                            
                            	    setlocal comments=s1:/*,mb:*,ex:*/,://,:#
                            
                            	    setlocal formatoptions-=t
                            	    setlocal formatoptions+=q
                            	    setlocal formatoptions+=r
                            	    setlocal formatoptions+=o
                            	    setlocal formatoptions+=c
                            	    setlocal formatoptions+=b
                            	endif
                            	let b:optionsset = 1
                                endif
                            endfunc
                            
                            call ResetPhpOptions()
                            
                            function! GetPhpIndentVersion()
                                return "1.66-bundle"
                            endfun
                            
                            function! GetPhpIndent()
                            
                                let b:GetLastRealCodeLNum_ADD = 0
                            
                                let UserIsEditing=0
                                if	b:PHP_oldchangetick != b:changedtick
                            	let b:PHP_oldchangetick = b:changedtick
                            	let UserIsEditing=1
                                endif
                            
                                if b:PHP_default_indenting
                            	let b:PHP_default_indenting = g:PHP_default_indenting * shiftwidth()
                                endif
                            
                                let cline = getline(v:lnum)
                            
                                if !b:PHP_indentinghuge && b:PHP_lastindented > b:PHP_indentbeforelast
                            	if b:PHP_indentbeforelast
                            	    let b:PHP_indentinghuge = 1
                            	endif
                            	let b:PHP_indentbeforelast = b:PHP_lastindented
                                endif
                            
                                if b:InPHPcode_checked && prevnonblank(v:lnum - 1) != b:PHP_lastindented
                            	if b:PHP_indentinghuge
                            	    let b:PHP_indentinghuge = 0
                            	    let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            	endif
                            	let real_PHP_lastindented = v:lnum
                            	let b:PHP_LastIndentedWasComment=0
                            	let b:PHP_InsideMultilineComment=0
                            	let b:PHP_indentbeforelast = 0
                            
                            	let b:InPHPcode = 0
                            	let b:InPHPcode_checked = 0
                            	let b:InPHPcode_and_script = 0
                            	let b:InPHPcode_tofind = ""
                            
                                elseif v:lnum > b:PHP_lastindented
                            	let real_PHP_lastindented = b:PHP_lastindented
                                else
                            	let real_PHP_lastindented = v:lnum
                                endif
                            
                                let b:PHP_lastindented = v:lnum
                            
                            
                                if !b:InPHPcode_checked " {{{ One time check
                            	let b:InPHPcode_checked = 1
                            	let b:UserIsTypingComment = 0
                            
                            	let synname = ""
                            	if cline !~ '<?.*?>'
                            	    let synname = IslinePHP (prevnonblank(v:lnum), "")
                            	endif
                            
                            	if synname!=""
                            	    if synname ==? "SpecStringEntrails"
                            		let b:InPHPcode = -1 " thumb down
                            		let b:InPHPcode_tofind = ""
                            	    elseif synname !=? "phpHereDoc" && synname !=? "phpHereDocDelimiter"
                            		let b:InPHPcode = 1
                            		let b:InPHPcode_tofind = ""
                            
                            		if synname =~? '^php\%(Doc\)\?Comment'
                            		    let b:UserIsTypingComment = 1
                            		    let b:InPHPcode_checked = 0
                            		endif
                            
                            		if synname =~? '^javaScript'
                            		    let b:InPHPcode_and_script = 1
                            		endif
                            
                            	    else
                            		let b:InPHPcode = 0
                            
                            		let lnum = v:lnum - 1
                            		while getline(lnum) !~? '<<<\s*[''"]\=\a\w*[''"]\=$' && lnum > 1
                            		    let lnum = lnum - 1
                            		endwhile
                            
                            		let b:InPHPcode_tofind = substitute( getline(lnum), '^.*<<<\s*[''"]\=\(\a\w*\)[''"]\=$', '^\\s*\1;\\=$', '')
                            	    endif
                            	else
                            	    let b:InPHPcode = 0
                            	    let b:InPHPcode_tofind = s:PHP_startindenttag
                            	endif
                                endif "!b:InPHPcode_checked }}}
                            
                            
                                " Test if we are indenting PHP code {{{
                                let lnum = prevnonblank(v:lnum - 1)
                                let last_line = getline(lnum)
                                let endline= s:endline
                            
                                if b:InPHPcode_tofind!=""
                            	if cline =~? b:InPHPcode_tofind
                            	    let b:InPHPcode_tofind = ""
                            	    let b:UserIsTypingComment = 0
                            
                            	    if b:InPHPcode == -1
                            		let b:InPHPcode = 1
                            		return -1
                            	    end
                            
                            	    let b:InPHPcode = 1
                            
                            	    if cline =~ '\*/'
                            		call cursor(v:lnum, 1)
                            		if cline !~ '^\*/'
                            		    call search('\*/', 'W')
                            		endif
                            		let lnum = searchpair('/\*', '', '\*/', s:searchpairflags, 'Skippmatch2()')
                            
                            		let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            
                            		let b:PHP_LastIndentedWasComment = 0
                            
                            		if cline =~ '^\s*\*/'
                            		    return indent(lnum) + 1
                            		else
                            		    return indent(lnum)
                            		endif
                            
                            	    elseif cline =~? '<script\>'
                            		let b:InPHPcode_and_script = 1
                            		let b:GetLastRealCodeLNum_ADD = v:lnum
                            	    endif
                            	endif
                                endif
                            
                                if 1 == b:InPHPcode
                            
                            	if !b:InPHPcode_and_script && last_line =~ '\%(<?.*\)\@<!?>\%(.*<?\)\@!' && IslinePHP(lnum, '?>')=~?"Delimiter"
                            	    if cline !~? s:PHP_startindenttag
                            		let b:InPHPcode = 0
                            		let b:InPHPcode_tofind = s:PHP_startindenttag
                            	    elseif cline =~? '<script\>'
                            		let b:InPHPcode_and_script = 1
                            	    endif
                            
                            	elseif last_line =~ '^[^''"`]\+[''"`]$' " a string identifier with nothing after it and no other string identifier before
                            	    let b:InPHPcode = -1
                            	    let b:InPHPcode_tofind = substitute( last_line, '^.*\([''"`]\).*$', '^[^\1]*\1[;,]$', '')
                            	elseif last_line =~? '<<<\s*[''"]\=\a\w*[''"]\=$'
                            	    let b:InPHPcode = 0
                            	    let b:InPHPcode_tofind = substitute( last_line, '^.*<<<\s*[''"]\=\(\a\w*\)[''"]\=$', '^\\s*\1;\\=$', '')
                            
                            	elseif !UserIsEditing && cline =~ '^\s*/\*\%(.*\*/\)\@!' && getline(v:lnum + 1) !~ '^\s*\*'
                            	    let b:InPHPcode = 0
                            	    let b:InPHPcode_tofind = '\*/'
                            
                            	elseif cline =~? '^\s*</script>'
                            	    let b:InPHPcode = 0
                            	    let b:InPHPcode_tofind = s:PHP_startindenttag
                            	endif
                                endif " }}}
                            
                            
                                if 1 > b:InPHPcode && !b:InPHPcode_and_script
                            	return -1
                                endif
                            
                                " Indent successive // or # comment the same way the first is {{{
                                let addSpecial = 0
                                if cline =~ '^\s*\%(//\|#\|/\*.*\*/\s*$\)'
                            	let addSpecial = b:PHP_outdentSLComments
                            	if b:PHP_LastIndentedWasComment == 1
                            	    return indent(real_PHP_lastindented)
                            	endif
                            	let b:PHP_LastIndentedWasComment = 1
                                else
                            	let b:PHP_LastIndentedWasComment = 0
                                endif " }}}
                            
                                " Indent multiline /* comments correctly {{{
                            
                                if b:PHP_InsideMultilineComment || b:UserIsTypingComment
                            	if cline =~ '^\s*\*\%(\/\)\@!'
                            	    if last_line =~ '^\s*/\*'
                            		return indent(lnum) + 1
                            	    else
                            		return indent(lnum)
                            	    endif
                            	else
                            	    let b:PHP_InsideMultilineComment = 0
                            	endif
                                endif
                            
                                if !b:PHP_InsideMultilineComment && cline =~ '^\s*/\*\%(.*\*/\)\@!'
                            	if getline(v:lnum + 1) !~ '^\s*\*'
                            	    return -1
                            	endif
                            	let b:PHP_InsideMultilineComment = 1
                                endif " }}}
                            
                            
                                " Things always indented at col 1 (PHP delimiter: <?, ?>, Heredoc end) {{{
                                if cline =~# '^\s*<?' && cline !~ '?>' && b:PHP_outdentphpescape
                            	return 0
                                endif
                            
                                if	cline =~ '^\s*?>' && cline !~# '<?' && b:PHP_outdentphpescape
                            	return 0
                                endif
                            
                                if cline =~? '^\s*\a\w*;$\|^\a\w*$\|^\s*[''"`][;,]' && cline !~? s:notPhpHereDoc
                            	return 0
                                endif " }}}
                            
                                let s:level = 0
                            
                                let lnum = GetLastRealCodeLNum(v:lnum - 1)
                            
                                let last_line = getline(lnum)
                                let ind = indent(lnum)
                            
                                if ind==0 && b:PHP_default_indenting
                            	let ind = b:PHP_default_indenting
                                endif
                            
                                if lnum == 0
                            	return b:PHP_default_indenting + addSpecial
                                endif
                            
                            
                                if cline =~ '^\s*}\%(}}\)\@!'
                            	let ind = indent(FindOpenBracket(v:lnum, 1))
                            	let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            	return ind
                                endif
                            
                                if cline =~ '^\s*\*/'
                            	call cursor(v:lnum, 1)
                            	if cline !~ '^\*/'
                            	    call search('\*/', 'W')
                            	endif
                            	let lnum = searchpair('/\*', '', '\*/', s:searchpairflags, 'Skippmatch2()')
                            
                            	let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            
                            	if cline =~ '^\s*\*/'
                            	    return indent(lnum) + 1
                            	else
                            	    return indent(lnum)
                            	endif
                                endif
                            
                            
                                if last_line =~ '[;}]'.endline && last_line !~ '^[)\]]' && last_line !~# s:defaultORcase
                            	if ind==b:PHP_default_indenting
                            	    return b:PHP_default_indenting + addSpecial
                            	elseif b:PHP_indentinghuge && ind==b:PHP_CurrentIndentLevel && cline !~# '^\s*\%(else\|\%(case\|default\).*:\|[})];\=\)' && last_line !~# '^\s*\%(\%(}\s*\)\=else\)' && getline(GetLastRealCodeLNum(lnum - 1))=~';'.endline
                            	    return b:PHP_CurrentIndentLevel + addSpecial
                            	endif
                                endif
                            
                                let LastLineClosed = 0
                            
                                let terminated = s:terminated
                            
                                let unstated  = s:unstated
                            
                            
                                if ind != b:PHP_default_indenting && cline =~# '^\s*else\%(if\)\=\>'
                            	let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            	return indent(FindTheIfOfAnElse(v:lnum, 1))
                                elseif cline =~# s:defaultORcase
                            	return FindTheSwitchIndent(v:lnum) + shiftwidth() * b:PHP_vintage_case_default_indent
                                elseif cline =~ '^\s*)\=\s*{'
                            	let previous_line = last_line
                            	let last_line_num = lnum
                            
                            	while last_line_num > 1
                            
                            	    if previous_line =~ terminated || previous_line =~ s:structureHead
                            
                            		let ind = indent(last_line_num)
                            
                            		if  b:PHP_BracesAtCodeLevel
                            		    let ind = ind + shiftwidth()
                            		endif
                            
                            		return ind
                            	    endif
                            
                            	    let last_line_num = GetLastRealCodeLNum(last_line_num - 1)
                            	    let previous_line = getline(last_line_num)
                            	endwhile
                                elseif cline =~ '^\s*->'
                            	return FindArrowIndent(lnum)
                                elseif last_line =~# unstated && cline !~ '^\s*);\='.endline
                            	let ind = ind + shiftwidth() " we indent one level further when the preceding line is not stated
                            	return ind + addSpecial
                            
                                elseif (ind != b:PHP_default_indenting || last_line =~ '^[)\]]' ) && last_line =~ terminated
                            	let previous_line = last_line
                            	let last_line_num = lnum
                            	let LastLineClosed = 1
                            
                            	let isSingleLineBlock = 0
                            	while 1
                            	    if ! isSingleLineBlock && previous_line =~ '^\s*}\|;\s*}'.endline
                            
                            		call cursor(last_line_num, 1)
                            		if previous_line !~ '^}'
                            		    call search('}\|;\s*}'.endline, 'W')
                            		end
                            		let oldLastLine = last_line_num
                            		let last_line_num = searchpair('{', '', '}', 'bW', 'Skippmatch()')
                            
                            		if getline(last_line_num) =~ '^\s*{'
                            		    let last_line_num = GetLastRealCodeLNum(last_line_num - 1)
                            		elseif oldLastLine == last_line_num
                            		    let isSingleLineBlock = 1
                            		    continue
                            		endif
                            
                            		let previous_line = getline(last_line_num)
                            
                            		continue
                            	    else
                            		let isSingleLineBlock = 0
                            
                            		if getline(last_line_num) =~# '^\s*else\%(if\)\=\>'
                            		    let last_line_num = FindTheIfOfAnElse(last_line_num, 0)
                            		    continue
                            		endif
                            
                            
                            		let last_match = last_line_num
                            
                            		let one_ahead_indent = indent(last_line_num)
                            		let last_line_num = GetLastRealCodeLNum(last_line_num - 1)
                            		let two_ahead_indent = indent(last_line_num)
                            		let after_previous_line = previous_line
                            		let previous_line = getline(last_line_num)
                            
                            
                            		if previous_line =~# s:defaultORcase.'\|{'.endline
                            		    break
                            		endif
                            
                            		if after_previous_line=~# '^\s*'.s:blockstart.'.*)'.endline && previous_line =~# '[;}]'.endline
                            		    break
                            		endif
                            
                            		if one_ahead_indent == two_ahead_indent || last_line_num < 1
                            		    if previous_line =~# '\%(;\|^\s*}\)'.endline || last_line_num < 1
                            			break
                            		    endif
                            		endif
                            	    endif
                            	endwhile
                            
                            	if indent(last_match) != ind
                            	    let ind = indent(last_match)
                            	    let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            
                            	    return ind + addSpecial
                            	endif
                                endif
                            
                                if (last_line !~ '^\s*}\%(}}\)\@!')
                            	let plinnum = GetLastRealCodeLNum(lnum - 1)
                                else
                            	let plinnum = GetLastRealCodeLNum(FindOpenBracket(lnum, 1) - 1)
                                endif
                            
                                let AntepenultimateLine = getline(plinnum)
                            
                                let last_line = StripEndlineComments(last_line)
                            
                                if ind == b:PHP_default_indenting
                            	if last_line =~ terminated && last_line !~# s:defaultORcase
                            	    let LastLineClosed = 1
                            	endif
                                endif
                            
                                if !LastLineClosed
                            
                            	let openedparent = -1
                            
                            
                            	if last_line =~# '[{(\[]'.endline || last_line =~? '\h\w*\s*(.*,$' && AntepenultimateLine !~ '[,(\[]'.endline && BalanceDirection(last_line) > 0
                            
                            	    let dontIndent = 0
                            	    if last_line =~ '\S\+\s*{'.endline && last_line !~ '^\s*[)\]]\+\(\s*:\s*'.s:PHP_validVariable.'\)\=\s*{'.endline && last_line !~ s:structureHead
                            		let dontIndent = 1
                            	    endif
                            
                            	    if !dontIndent && (!b:PHP_BracesAtCodeLevel || last_line !~# '^\s*{')
                            		let ind = ind + shiftwidth()
                            	    endif
                            
                            	    if b:PHP_BracesAtCodeLevel || b:PHP_vintage_case_default_indent == 1
                            		let b:PHP_CurrentIndentLevel = ind
                            
                            	    endif
                            
                            	elseif last_line =~ '),'.endline && BalanceDirection(last_line) < 0
                            	    call cursor(lnum, 1)
                            	    call searchpos('),'.endline, 'cW')
                            	    let openedparent = searchpair('(', '', ')', 'bW', 'Skippmatch()')
                            	    if openedparent != lnum
                            		let ind = indent(openedparent)
                            	    endif
                            
                            	elseif last_line =~ s:structureHead
                            	    let ind = ind + shiftwidth()
                            
                            
                            	elseif AntepenultimateLine =~ '{'.endline && AntepenultimateLine !~? '^\s*use\>' || AntepenultimateLine =~ terminated || AntepenultimateLine =~# s:defaultORcase
                            	    let ind = ind + shiftwidth()
                            	endif
                            
                            
                            	if openedparent >= 0
                            	    let last_line = StripEndlineComments(getline(openedparent))
                            	endif
                                endif
                            
                                if cline =~ '^\s*[)\]];\='
                            	let ind = ind - shiftwidth()
                                endif
                            
                                if last_line =~ '^\s*->' && last_line !~? s:structureHead && BalanceDirection(last_line) <= 0
                            	let ind = ind - shiftwidth()
                                endif
                            
                                let b:PHP_CurrentIndentLevel = ind
                                return ind + addSpecial
                            endfunction

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/syntax/php.vim
Sourced 3 times
Total time:   0.127806
 Self time:   0.024965

count  total (s)   self (s)
                            " Vim syntax file
                            " Language: php PHP 3/4/5/7
                            " Maintainer: Jason Woofenden <jason@jasonwoof.com>
                            " Last Change: May 12, 2018
                            " URL: https://jasonwoof.com/gitweb/?p=vim-syntax.git;a=blob;f=php.vim;hb=HEAD
                            " Former Maintainers: Peter Hodge <toomuchphp-vim@yahoo.com>
                            "         Debian VIM Maintainers <pkg-vim-maintainers@lists.alioth.debian.org>
                            "
                            " Note: If you are using a colour terminal with dark background, you will
                            "       probably find the 'elflord' colorscheme is much better for PHP's syntax
                            "       than the default colourscheme, because elflord's colours will better
                            "       highlight the break-points (Statements) in your code.
                            "
                            " Options:
                            "   Set to anything to enable:
                            "     php_sql_query           SQL syntax highlighting inside strings
                            "     php_htmlInStrings       HTML syntax highlighting inside strings
                            "     php_baselib             highlighting baselib functions
                            "     php_asp_tags            highlighting ASP-style short tags
                            "     php_parent_error_close  highlighting parent error ] or )
                            "     php_parent_error_open   skipping an php end tag, if there exists
                            "                               an open ( or [ without a closing one
                            "     php_oldStyle            use old colorstyle
                            "     php_noShortTags         don't sync <? ?> as php
                            "   Set to a specific value:
                            "     php_folding = 1         fold classes and functions
                            "     php_folding = 2         fold all { } regions
                            "     php_sync_method = x  where x is an integer:
                            "                       -1  sync by search ( default )
                            "                       >0  sync at least x lines backwards
                            "                       0   sync from start
                            "   Set to 0 to _disable_:      (Added by Peter Hodge On June 9, 2006)
                            "     php_special_functions = 0      highlight functions with abnormal behaviour
                            "     php_alt_comparisons = 0        comparison operators in an alternate colour
                            "     php_alt_assignByReference = 0  '= &' in an alternate colour
                            "
                            "
                            " Note:
                            " Setting php_folding=1 will match a closing } by comparing the indent
                            " before the class or function keyword with the indent of a matching }.
                            " Setting php_folding=2 will match all of pairs of {,} ( see known
                            " bugs ii )
                            
                            " Known Bugs:
                            "  - setting  php_parent_error_close  on  and  php_parent_error_open  off
                            "    has these two leaks:
                            "     i) A closing ) or ] inside a string match to the last open ( or [
                            "        before the string, when the the closing ) or ] is on the same line
                            "        where the string started. In this case a following ) or ] after
                            "        the string would be highlighted as an error, what is incorrect.
                            "    ii) Same problem if you are setting php_folding = 2 with a closing
                            "        } inside an string on the first line of this string.
                            
                            " quit when a syntax file was already loaded
    3              0.000033 if exists("b:current_syntax")
                              finish
                            endif
                            
    3              0.000011 if !exists("main_syntax")
    3              0.000017   let main_syntax = 'php'
    3              0.000004 endif
                            
    3   0.097531   0.001504 runtime! syntax/html.vim
    3              0.000013 unlet b:current_syntax
                            
                            " accept old options
    3              0.000015 if !exists("php_sync_method")
                              if exists("php_minlines")
                                let php_sync_method=php_minlines
                              else
                                let php_sync_method=-1
                              endif
                            endif
                            
    3              0.000015 if exists("php_parentError") && !exists("php_parent_error_open") && !exists("php_parent_error_close")
                              let php_parent_error_close=1
                              let php_parent_error_open=1
                            endif
                            
    3              0.000109 syn cluster htmlPreproc add=phpRegion,phpRegionAsp,phpRegionSc
                            
    3   0.008055   0.001241 syn include @sqlTop syntax/sql.vim
    3              0.000021 syn sync clear
    3              0.000010 unlet b:current_syntax
    3              0.000081 syn cluster sqlTop remove=sqlString,sqlComment
    3              0.000017 if exists( "php_sql_query")
                              syn cluster phpAddStrings contains=@sqlTop
                            endif
                            
    3              0.000010 if exists( "php_htmlInStrings")
                              syn cluster phpAddStrings add=@htmlTop
                            endif
                            
                            " make sure we can use \ at the begining of the line to do a continuation
    3              0.000033 let s:cpo_save = &cpo
    3              0.000033 set cpo&vim
                            
    3              0.000005 syn case match
                            
                            " Env Variables
    3              0.000080 syn keyword phpEnvVar GATEWAY_INTERFACE SERVER_NAME SERVER_SOFTWARE SERVER_PROTOCOL REQUEST_METHOD QUERY_STRING DOCUMENT_ROOT HTTP_ACCEPT HTTP_ACCEPT_CHARSET HTTP_ENCODING HTTP_ACCEPT_LANGUAGE HTTP_CONNECTION HTTP_HOST HTTP_REFERER HTTP_USER_AGENT REMOTE_ADDR REMOTE_PORT SCRIPT_FILENAME SERVER_ADMIN SERVER_PORT SERVER_SIGNATURE PATH_TRANSLATED SCRIPT_NAME REQUEST_URI contained
                            
                            " Internal Variables
    3              0.000076 syn keyword phpIntVar GLOBALS PHP_ERRMSG PHP_SELF HTTP_GET_VARS HTTP_POST_VARS HTTP_COOKIE_VARS HTTP_POST_FILES HTTP_ENV_VARS HTTP_SERVER_VARS HTTP_SESSION_VARS HTTP_RAW_POST_DATA HTTP_STATE_VARS _GET _POST _COOKIE _FILES _SERVER _ENV _SERVER _REQUEST _SESSION contained
                            
                            " Constants
    3              0.000047 syn keyword phpCoreConstant PHP_VERSION PHP_OS DEFAULT_INCLUDE_PATH PEAR_INSTALL_DIR PEAR_EXTENSION_DIR PHP_EXTENSION_DIR PHP_BINDIR PHP_LIBDIR PHP_DATADIR PHP_SYSCONFDIR PHP_LOCALSTATEDIR PHP_CONFIG_FILE_PATH PHP_OUTPUT_HANDLER_START PHP_OUTPUT_HANDLER_CONT PHP_OUTPUT_HANDLER_END contained
                            
                            " Predefined constants
                            " Generated by: curl -q http://php.net/manual/en/errorfunc.constants.php | grep -oP 'E_\w+' | sort -u
    3              0.000042 syn keyword phpCoreConstant E_ALL E_COMPILE_ERROR E_COMPILE_WARNING E_CORE_ERROR E_CORE_WARNING E_DEPRECATED E_ERROR E_NOTICE E_PARSE E_RECOVERABLE_ERROR E_STRICT E_USER_DEPRECATED E_USER_ERROR E_USER_NOTICE E_USER_WARNING E_WARNING contained
                            
    3              0.000005 syn case ignore
                            
    3              0.000035 syn keyword phpConstant __LINE__ __FILE__ __FUNCTION__ __METHOD__ __CLASS__ __DIR__ __NAMESPACE__ __TRAIT__ contained
                            
                            
                            " Function and Methods ripped from php_manual_de.tar.gz Jan 2003
    3              0.000057 syn keyword phpFunctions apache_child_terminate apache_get_modules apache_get_version apache_getenv apache_lookup_uri apache_note apache_request_headers apache_response_headers apache_setenv ascii2ebcdic ebcdic2ascii getallheaders virtual contained
    3              0.000154 syn keyword phpFunctions array_change_key_case array_chunk array_column array_combine array_count_values array_diff_assoc array_diff_key array_diff_uassoc array_diff_ukey array_diff array_fill_keys array_fill array_filter array_flip array_intersect_assoc array_intersect_key array_intersect_uassoc array_intersect_ukey array_intersect array_key_exists array_keys array_map array_merge_recursive array_merge array_multisort array_pad array_pop array_product array_push array_rand array_reduce array_replace_recursive array_replace array_reverse array_search array_shift array_slice array_splice array_sum array_udiff_assoc array_udiff_uassoc array_udiff array_uintersect_assoc array_uintersect_uassoc array_uintersect array_unique array_unshift array_values array_walk_recursive array_walk arsort asort count current each end in_array key_exists key krsort ksort natcasesort natsort next pos prev range reset rsort shuffle sizeof sort uasort uksort usort contained
    3              0.000028 syn keyword phpFunctions aspell_check aspell_new aspell_suggest contained
    3              0.000034 syn keyword phpFunctions bcadd bccomp bcdiv bcmod bcmul bcpow bcpowmod bcscale bcsqrt bcsub contained
    3              0.000036 syn keyword phpFunctions bzclose bzcompress bzdecompress bzerrno bzerror bzerrstr bzflush bzopen bzread bzwrite contained
    3              0.000050 syn keyword phpFunctions cal_days_in_month cal_from_jd cal_info cal_to_jd easter_date easter_days frenchtojd gregoriantojd jddayofweek jdmonthname jdtofrench jdtogregorian jdtojewish jdtojulian jdtounix jewishtojd juliantojd unixtojd contained
    3              0.000049 syn keyword phpFunctions ccvs_add ccvs_auth ccvs_command ccvs_count ccvs_delete ccvs_done ccvs_init ccvs_lookup ccvs_new ccvs_report ccvs_return ccvs_reverse ccvs_sale ccvs_status ccvs_textvalue ccvs_void contained
    3              0.000043 syn keyword phpFunctions call_user_method_array call_user_method class_exists get_class_methods get_class_vars get_class get_declared_classes get_object_vars get_parent_class is_a is_subclass_of method_exists contained
    3              0.000198 syn keyword phpFunctions com VARIANT com_addref com_get com_invoke com_isenum com_load_typelib com_load com_propget com_propput com_propset com_release com_set contained
    3              0.000167 syn keyword phpFunctions cpdf_add_annotation cpdf_add_outline cpdf_arc cpdf_begin_text cpdf_circle cpdf_clip cpdf_close cpdf_closepath_fill_stroke cpdf_closepath_stroke cpdf_closepath cpdf_continue_text cpdf_curveto cpdf_end_text cpdf_fill_stroke cpdf_fill cpdf_finalize_page cpdf_finalize cpdf_global_set_document_limits cpdf_import_jpeg cpdf_lineto cpdf_moveto cpdf_newpath cpdf_open cpdf_output_buffer cpdf_page_init cpdf_place_inline_image cpdf_rect cpdf_restore cpdf_rlineto cpdf_rmoveto cpdf_rotate_text cpdf_rotate cpdf_save_to_file cpdf_save cpdf_scale cpdf_set_action_url cpdf_set_char_spacing cpdf_set_creator cpdf_set_current_page cpdf_set_font_directories cpdf_set_font_map_file cpdf_set_font cpdf_set_horiz_scaling cpdf_set_keywords cpdf_set_leading cpdf_set_page_animation cpdf_set_subject cpdf_set_text_matrix cpdf_set_text_pos cpdf_set_text_rendering cpdf_set_text_rise cpdf_set_title cpdf_set_viewer_preferences cpdf_set_word_spacing cpdf_setdash cpdf_setflat cpdf_setgray_fill cpdf_setgray_stroke cpdf_set
    3              0.000032 syn keyword phpFunctions crack_check crack_closedict crack_getlastmessage crack_opendict contained
    3              0.000038 syn keyword phpFunctions ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_graph ctype_lower ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit contained
    3              0.000062 syn keyword phpFunctions curl_close curl_errno curl_error curl_exec curl_getinfo curl_init curl_multi_add_handle curl_multi_close curl_multi_exec curl_multi_getcontent curl_multi_info_read curl_multi_init curl_multi_remove_handle curl_multi_select curl_setopt curl_version contained
    3              0.000031 syn keyword phpFunctions cybercash_base64_decode cybercash_base64_encode cybercash_decr cybercash_encr contained
    3              0.000032 syn keyword phpFunctions cyrus_authenticate cyrus_bind cyrus_close cyrus_connect cyrus_query cyrus_unbind contained
    3              0.000041 syn keyword phpFunctions checkdate date getdate gettimeofday gmdate gmmktime gmstrftime localtime microtime mktime strftime strtotime time contained
    3              0.000045 syn keyword phpFunctions dba_close dba_delete dba_exists dba_fetch dba_firstkey dba_handlers dba_insert dba_key_split dba_list dba_nextkey dba_open dba_optimize dba_popen dba_replace dba_sync contained
    3              0.000048 syn keyword phpFunctions dbase_add_record dbase_close dbase_create dbase_delete_record dbase_get_header_info dbase_get_record_with_names dbase_get_record dbase_numfields dbase_numrecords dbase_open dbase_pack dbase_replace_record contained
    3              0.000040 syn keyword phpFunctions dblist dbmclose dbmdelete dbmexists dbmfetch dbmfirstkey dbminsert dbmnextkey dbmopen dbmreplace contained
    3              0.000103 syn keyword phpFunctions dbplus_add dbplus_aql dbplus_chdir dbplus_close dbplus_curr dbplus_errcode dbplus_errno dbplus_find dbplus_first dbplus_flush dbplus_freealllocks dbplus_freelock dbplus_freerlocks dbplus_getlock dbplus_getunique dbplus_info dbplus_last dbplus_lockrel dbplus_next dbplus_open dbplus_prev dbplus_rchperm dbplus_rcreate dbplus_rcrtexact dbplus_rcrtlike dbplus_resolve dbplus_restorepos dbplus_rkeys dbplus_ropen dbplus_rquery dbplus_rrename dbplus_rsecindex dbplus_runlink dbplus_rzap dbplus_savepos dbplus_setindex dbplus_setindexbynumber dbplus_sql dbplus_tcl dbplus_tremove dbplus_undo dbplus_undoprepare dbplus_unlockrel dbplus_unselect dbplus_update dbplus_xlockrel dbplus_xunlockrel contained
    3              0.000033 syn keyword phpFunctions dbx_close dbx_compare dbx_connect dbx_error dbx_escape_string dbx_fetch_row dbx_query dbx_sort contained
    3              0.000034 syn keyword phpFunctions dio_close dio_fcntl dio_open dio_read dio_seek dio_stat dio_tcsetattr dio_truncate dio_write contained
    3              0.000037 syn keyword phpFunctions chdir chroot dir closedir getcwd opendir readdir rewinddir scandir contained
    3              0.000141 syn keyword phpFunctions domxml_new_doc domxml_open_file domxml_open_mem domxml_version domxml_xmltree domxml_xslt_stylesheet_doc domxml_xslt_stylesheet_file domxml_xslt_stylesheet xpath_eval_expression xpath_eval xpath_new_context xptr_eval xptr_new_context contained
    3              0.000126 syn keyword phpMethods name specified value create_attribute create_cdata_section create_comment create_element_ns create_element create_entity_reference create_processing_instruction create_text_node doctype document_element dump_file dump_mem get_element_by_id get_elements_by_tagname html_dump_mem xinclude entities internal_subset name notations public_id system_id get_attribute_node get_attribute get_elements_by_tagname has_attribute remove_attribute set_attribute tagname add_namespace append_child append_sibling attributes child_nodes clone_node dump_node first_child get_content has_attributes has_child_nodes insert_before is_blank_node last_child next_sibling node_name node_type node_value owner_document parent_node prefix previous_sibling remove_child replace_child replace_node set_content set_name set_namespace unlink_node data target process result_dump_file result_dump_mem contained
    3              0.000020 syn keyword phpFunctions dotnet_load contained
    3              0.000027 syn keyword phpFunctions debug_backtrace debug_print_backtrace error_log error_reporting restore_error_handler set_error_handler trigger_error user_error contained
    3              0.000028 syn keyword phpFunctions escapeshellarg escapeshellcmd exec passthru proc_close proc_get_status proc_nice proc_open proc_terminate shell_exec system contained
    3              0.000033 syn keyword phpFunctions fam_cancel_monitor fam_close fam_monitor_collection fam_monitor_directory fam_monitor_file fam_next_event fam_open fam_pending fam_resume_monitor fam_suspend_monitor contained
    3              0.000379 syn keyword phpFunctions fbsql_affected_rows fbsql_autocommit fbsql_change_user fbsql_close fbsql_commit fbsql_connect fbsql_create_blob fbsql_create_clob fbsql_create_db fbsql_data_seek fbsql_database_password fbsql_database fbsql_db_query fbsql_db_status fbsql_drop_db fbsql_errno fbsql_error fbsql_fetch_array fbsql_fetch_assoc fbsql_fetch_field fbsql_fetch_lengths fbsql_fetch_object fbsql_fetch_row fbsql_field_flags fbsql_field_len fbsql_field_name fbsql_field_seek fbsql_field_table fbsql_field_type fbsql_free_result fbsql_get_autostart_info fbsql_hostname fbsql_insert_id fbsql_list_dbs fbsql_list_fields fbsql_list_tables fbsql_next_result fbsql_num_fields fbsql_num_rows fbsql_password fbsql_pconnect fbsql_query fbsql_read_blob fbsql_read_clob fbsql_result fbsql_rollback fbsql_select_db fbsql_set_lob_mode fbsql_set_transaction fbsql_start_db fbsql_stop_db fbsql_tablename fbsql_username fbsql_warnings contained
    3              0.000096 syn keyword phpFunctions fdf_add_doc_javascript fdf_add_template fdf_close fdf_create fdf_enum_values fdf_errno fdf_error fdf_get_ap fdf_get_attachment fdf_get_encoding fdf_get_file fdf_get_flags fdf_get_opt fdf_get_status fdf_get_value fdf_get_version fdf_header fdf_next_field_name fdf_open_string fdf_open fdf_remove_item fdf_save_string fdf_save fdf_set_ap fdf_set_encoding fdf_set_file fdf_set_flags fdf_set_javascript_action fdf_set_opt fdf_set_status fdf_set_submit_form_action fdf_set_target_frame fdf_set_value fdf_set_version contained
    3              0.000047 syn keyword phpFunctions filepro_fieldcount filepro_fieldname filepro_fieldtype filepro_fieldwidth filepro_retrieve filepro_rowcount filepro contained
    3              0.000134 syn keyword phpFunctions basename chgrp chmod chown clearstatcache copy delete dirname disk_free_space disk_total_space diskfreespace fclose feof fflush fgetc fgetcsv fgets fgetss file_exists file_get_contents file_put_contents file fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype flock fnmatch fopen fpassthru fputs fread fscanf fseek fstat ftell ftruncate fwrite glob is_dir is_executable is_file is_link is_readable is_uploaded_file is_writable is_writeable link linkinfo lstat mkdir move_uploaded_file parse_ini_file pathinfo pclose popen readfile readlink realpath rename rewind rmdir set_file_buffer stat symlink tempnam tmpfile touch umask unlink contained
    3              0.000027 syn keyword phpFunctions fribidi_log2vis contained
    3              0.000080 syn keyword phpFunctions ftp_alloc ftp_cdup ftp_chdir ftp_chmod ftp_close ftp_connect ftp_delete ftp_exec ftp_fget ftp_fput ftp_get_option ftp_get ftp_login ftp_mdtm ftp_mkdir ftp_nb_continue ftp_nb_fget ftp_nb_fput ftp_nb_get ftp_nb_put ftp_nlist ftp_pasv ftp_put ftp_pwd ftp_quit ftp_raw ftp_rawlist ftp_rename ftp_rmdir ftp_set_option ftp_site ftp_size ftp_ssl_connect ftp_systype contained
    3              0.000041 syn keyword phpFunctions call_user_func_array call_user_func create_function func_get_arg func_get_args func_num_args function_exists get_defined_functions register_shutdown_function register_tick_function unregister_tick_function contained
    3              0.000054 syn keyword phpFunctions bind_textdomain_codeset bindtextdomain dcgettext dcngettext dgettext dngettext gettext ngettext textdomain contained
    3              0.000343 syn keyword phpFunctions gmp_abs gmp_add gmp_and gmp_clrbit gmp_cmp gmp_com gmp_div_q gmp_div_qr gmp_div_r gmp_div gmp_divexact gmp_fact gmp_gcd gmp_gcdext gmp_hamdist gmp_init gmp_intval gmp_invert gmp_jacobi gmp_legendre gmp_mod gmp_mul gmp_neg gmp_or gmp_perfect_square gmp_popcount gmp_pow gmp_powm gmp_prob_prime gmp_random gmp_scan0 gmp_scan1 gmp_setbit gmp_sign gmp_sqrt gmp_sqrtrem gmp_sqrtrm gmp_strval gmp_sub gmp_xor contained
    3              0.000040 syn keyword phpFunctions header headers_list headers_sent setcookie contained
    3              0.000030 syn keyword phpFunctions hw_api_attribute hwapi_hgcsp hw_api_content hw_api_object contained
    3              0.000108 syn keyword phpMethods key langdepvalue value values checkin checkout children mimetype read content copy dbstat dcstat dstanchors dstofsrcanchors count reason find ftstat hwstat identify info insert insertanchor insertcollection insertdocument link lock move assign attreditable count insert remove title value object objectbyanchor parents description type remove replace setcommitedversion srcanchors srcsofdst unlock user userlist contained
    3              0.000124 syn keyword phpFunctions hw_Array2Objrec hw_changeobject hw_Children hw_ChildrenObj hw_Close hw_Connect hw_connection_info hw_cp hw_Deleteobject hw_DocByAnchor hw_DocByAnchorObj hw_Document_Attributes hw_Document_BodyTag hw_Document_Content hw_Document_SetContent hw_Document_Size hw_dummy hw_EditText hw_Error hw_ErrorMsg hw_Free_Document hw_GetAnchors hw_GetAnchorsObj hw_GetAndLock hw_GetChildColl hw_GetChildCollObj hw_GetChildDocColl hw_GetChildDocCollObj hw_GetObject hw_GetObjectByQuery hw_GetObjectByQueryColl hw_GetObjectByQueryCollObj hw_GetObjectByQueryObj hw_GetParents hw_GetParentsObj hw_getrellink hw_GetRemote hw_getremotechildren hw_GetSrcByDestObj hw_GetText hw_getusername hw_Identify hw_InCollections hw_Info hw_InsColl hw_InsDoc hw_insertanchors hw_InsertDocument hw_InsertObject hw_mapid hw_Modifyobject hw_mv hw_New_Document hw_objrec2array hw_Output_Document hw_pConnect hw_PipeDocument hw_Root hw_setlinkroot hw_stat hw_Unlock hw_Who contained
    3              0.000078 syn keyword phpFunctions ibase_add_user ibase_affected_rows ibase_blob_add ibase_blob_cancel ibase_blob_close ibase_blob_create ibase_blob_echo ibase_blob_get ibase_blob_import ibase_blob_info ibase_blob_open ibase_close ibase_commit_ret ibase_commit ibase_connect ibase_delete_user ibase_drop_db ibase_errcode ibase_errmsg ibase_execute ibase_fetch_assoc ibase_fetch_object ibase_fetch_row ibase_field_info ibase_free_event_handler ibase_free_query ibase_free_result ibase_gen_id ibase_modify_user ibase_name_result ibase_num_fields ibase_num_params ibase_param_info ibase_pconnect ibase_prepare ibase_query ibase_rollback_ret ibase_rollback ibase_set_event_handler ibase_timefmt ibase_trans ibase_wait_event contained
    3              0.000035 syn keyword phpFunctions iconv_get_encoding iconv_mime_decode_headers iconv_mime_decode iconv_mime_encode iconv_set_encoding iconv_strlen iconv_strpos iconv_strrpos iconv_substr iconv ob_iconv_handler contained
    3              0.000096 syn keyword phpFunctions ifx_affected_rows ifx_blobinfile_mode ifx_byteasvarchar ifx_close ifx_connect ifx_copy_blob ifx_create_blob ifx_create_char ifx_do ifx_error ifx_errormsg ifx_fetch_row ifx_fieldproperties ifx_fieldtypes ifx_free_blob ifx_free_char ifx_free_result ifx_get_blob ifx_get_char ifx_getsqlca ifx_htmltbl_result ifx_nullformat ifx_num_fields ifx_num_rows ifx_pconnect ifx_prepare ifx_query ifx_textasvarchar ifx_update_blob ifx_update_char ifxus_close_slob ifxus_create_slob ifxus_free_slob ifxus_open_slob ifxus_read_slob ifxus_seek_slob ifxus_tell_slob ifxus_write_slob contained
    3              0.000170 syn keyword phpFunctions exif_imagetype exif_read_data exif_thumbnail gd_info getimagesize image_type_to_mime_type image2wbmp imagealphablending imageantialias imagearc imagechar imagecharup imagecolorallocate imagecolorallocatealpha imagecolorat imagecolorclosest imagecolorclosestalpha imagecolorclosesthwb imagecolordeallocate imagecolorexact imagecolorexactalpha imagecolormatch imagecolorresolve imagecolorresolvealpha imagecolorset imagecolorsforindex imagecolorstotal imagecolortransparent imagecopy imagecopymerge imagecopymergegray imagecopyresampled imagecopyresized imagecreate imagecreatefromgd2 imagecreatefromgd2part imagecreatefromgd imagecreatefromgif imagecreatefromjpeg imagecreatefrompng imagecreatefromstring imagecreatefromwbmp imagecreatefromxbm imagecreatefromxpm imagecreatetruecolor imagedashedline imagedestroy imageellipse imagefill imagefilledarc imagefilledellipse imagefilledpolygon imagefilledrectangle imagefilltoborder imagefontheight imagefontwidth imageftbbox imagefttext imagegammacorrec
    3              0.000145 syn keyword phpFunctions imap_8bit imap_alerts imap_append imap_base64 imap_binary imap_body imap_bodystruct imap_check imap_clearflag_full imap_close imap_createmailbox imap_delete imap_deletemailbox imap_errors imap_expunge imap_fetch_overview imap_fetchbody imap_fetchheader imap_fetchstructure imap_get_quota imap_get_quotaroot imap_getacl imap_getmailboxes imap_getsubscribed imap_header imap_headerinfo imap_headers imap_last_error imap_list imap_listmailbox imap_listscan imap_listsubscribed imap_lsub imap_mail_compose imap_mail_copy imap_mail_move imap_mail imap_mailboxmsginfo imap_mime_header_decode imap_msgno imap_num_msg imap_num_recent imap_open imap_ping imap_qprint imap_renamemailbox imap_reopen imap_rfc822_parse_adrlist imap_rfc822_parse_headers imap_rfc822_write_address imap_scanmailbox imap_search imap_set_quota imap_setacl imap_setflag_full imap_sort imap_status imap_subscribe imap_thread imap_timeout imap_uid imap_undelete imap_unsubscribe imap_utf7_decode imap_utf7_encode imap_utf8 contained
    3              0.000103 syn keyword phpFunctions assert_options assert dl extension_loaded get_cfg_var get_current_user get_defined_constants get_extension_funcs get_include_path get_included_files get_loaded_extensions get_magic_quotes_gpc get_magic_quotes_runtime get_required_files getenv getlastmod getmygid getmyinode getmypid getmyuid getopt getrusage ini_alter ini_get_all ini_get ini_restore ini_set main memory_get_usage php_ini_scanned_files php_logo_guid php_sapi_name php_uname phpcredits phpinfo phpversion putenv restore_include_path set_include_path set_magic_quotes_runtime set_time_limit version_compare zend_logo_guid zend_version contained
    3              0.000053 syn keyword phpFunctions ingres_autocommit ingres_close ingres_commit ingres_connect ingres_fetch_array ingres_fetch_object ingres_fetch_row ingres_field_length ingres_field_name ingres_field_nullable ingres_field_precision ingres_field_scale ingres_field_type ingres_num_fields ingres_num_rows ingres_pconnect ingres_query ingres_rollback contained
    3              0.000061 syn keyword phpFunctions ircg_channel_mode ircg_disconnect ircg_fetch_error_msg ircg_get_username ircg_html_encode ircg_ignore_add ircg_ignore_del ircg_is_conn_alive ircg_join ircg_kick ircg_lookup_format_messages ircg_msg ircg_nick ircg_nickname_escape ircg_nickname_unescape ircg_notice ircg_part ircg_pconnect ircg_register_format_messages ircg_set_current ircg_set_file ircg_set_on_die ircg_topic ircg_whois contained
    3              0.000026 syn keyword phpFunctions java_last_exception_clear java_last_exception_get contained
    3              0.000047 syn keyword phpFunctions json_decode json_encode json_last_error contained
    3              0.000095 syn keyword phpFunctions ldap_8859_to_t61 ldap_add ldap_bind ldap_close ldap_compare ldap_connect ldap_count_entries ldap_delete ldap_dn2ufn ldap_err2str ldap_errno ldap_error ldap_explode_dn ldap_first_attribute ldap_first_entry ldap_first_reference ldap_free_result ldap_get_attributes ldap_get_dn ldap_get_entries ldap_get_option ldap_get_values_len ldap_get_values ldap_list ldap_mod_add ldap_mod_del ldap_mod_replace ldap_modify ldap_next_attribute ldap_next_entry ldap_next_reference ldap_parse_reference ldap_parse_result ldap_read ldap_rename ldap_search ldap_set_option ldap_set_rebind_proc ldap_sort ldap_start_tls ldap_t61_to_8859 ldap_unbind contained
    3              0.000028 syn keyword phpFunctions lzf_compress lzf_decompress lzf_optimized_for contained
    3              0.000023 syn keyword phpFunctions ezmlm_hash mail contained
    3              0.000050 syn keyword phpFunctions mailparse_determine_best_xfer_encoding mailparse_msg_create mailparse_msg_extract_part_file mailparse_msg_extract_part mailparse_msg_free mailparse_msg_get_part_data mailparse_msg_get_part mailparse_msg_get_structure mailparse_msg_parse_file mailparse_msg_parse mailparse_rfc822_parse_addresses mailparse_stream_encode mailparse_uudecode_all contained
    3              0.000119 syn keyword phpFunctions abs acos acosh asin asinh atan2 atan atanh base_convert bindec ceil cos cosh decbin dechex decoct deg2rad exp expm1 floor fmod getrandmax hexdec hypot is_finite is_infinite is_nan lcg_value log10 log1p log max min mt_getrandmax mt_rand mt_srand octdec pi pow rad2deg rand round sin sinh sqrt srand tan tanh contained
    3              0.000112 syn keyword phpFunctions mb_convert_case mb_convert_encoding mb_convert_kana mb_convert_variables mb_decode_mimeheader mb_decode_numericentity mb_detect_encoding mb_detect_order mb_encode_mimeheader mb_encode_numericentity mb_ereg_match mb_ereg_replace mb_ereg_search_getpos mb_ereg_search_getregs mb_ereg_search_init mb_ereg_search_pos mb_ereg_search_regs mb_ereg_search_setpos mb_ereg_search mb_ereg mb_eregi_replace mb_eregi mb_get_info mb_http_input mb_http_output mb_internal_encoding mb_language mb_output_handler mb_parse_str mb_preferred_mime_name mb_regex_encoding mb_regex_set_options mb_send_mail mb_split mb_strcut mb_strimwidth mb_strlen mb_strpos mb_strrpos mb_strtolower mb_strtoupper mb_strwidth mb_substitute_character mb_substr_count mb_substr contained
    3              0.000091 syn keyword phpFunctions mcal_append_event mcal_close mcal_create_calendar mcal_date_compare mcal_date_valid mcal_day_of_week mcal_day_of_year mcal_days_in_month mcal_delete_calendar mcal_delete_event mcal_event_add_attribute mcal_event_init mcal_event_set_alarm mcal_event_set_category mcal_event_set_class mcal_event_set_description mcal_event_set_end mcal_event_set_recur_daily mcal_event_set_recur_monthly_mday mcal_event_set_recur_monthly_wday mcal_event_set_recur_none mcal_event_set_recur_weekly mcal_event_set_recur_yearly mcal_event_set_start mcal_event_set_title mcal_expunge mcal_fetch_current_stream_event mcal_fetch_event mcal_is_leap_year mcal_list_alarms mcal_list_events mcal_next_recurrence mcal_open mcal_popen mcal_rename_calendar mcal_reopen mcal_snooze mcal_store_event mcal_time_valid mcal_week_of_year contained
    3              0.000186 syn keyword phpFunctions mcrypt_cbc mcrypt_cfb mcrypt_create_iv mcrypt_decrypt mcrypt_ecb mcrypt_enc_get_algorithms_name mcrypt_enc_get_block_size mcrypt_enc_get_iv_size mcrypt_enc_get_key_size mcrypt_enc_get_modes_name mcrypt_enc_get_supported_key_sizes mcrypt_enc_is_block_algorithm_mode mcrypt_enc_is_block_algorithm mcrypt_enc_is_block_mode mcrypt_enc_self_test mcrypt_encrypt mcrypt_generic_deinit mcrypt_generic_end mcrypt_generic_init mcrypt_generic mcrypt_get_block_size mcrypt_get_cipher_name mcrypt_get_iv_size mcrypt_get_key_size mcrypt_list_algorithms mcrypt_list_modes mcrypt_module_close mcrypt_module_get_algo_block_size mcrypt_module_get_algo_key_size mcrypt_module_get_supported_key_sizes mcrypt_module_is_block_algorithm_mode mcrypt_module_is_block_algorithm mcrypt_module_is_block_mode mcrypt_module_open mcrypt_module_self_test mcrypt_ofb mdecrypt_generic contained
    3              0.000136 syn keyword phpFunctions mcve_adduser mcve_adduserarg mcve_bt mcve_checkstatus mcve_chkpwd mcve_chngpwd mcve_completeauthorizations mcve_connect mcve_connectionerror mcve_deleteresponse mcve_deletetrans mcve_deleteusersetup mcve_deluser mcve_destroyconn mcve_destroyengine mcve_disableuser mcve_edituser mcve_enableuser mcve_force mcve_getcell mcve_getcellbynum mcve_getcommadelimited mcve_getheader mcve_getuserarg mcve_getuserparam mcve_gft mcve_gl mcve_gut mcve_initconn mcve_initengine mcve_initusersetup mcve_iscommadelimited mcve_liststats mcve_listusers mcve_maxconntimeout mcve_monitor mcve_numcolumns mcve_numrows mcve_override mcve_parsecommadelimited mcve_ping mcve_preauth mcve_preauthcompletion mcve_qc mcve_responseparam mcve_return mcve_returncode mcve_returnstatus mcve_sale mcve_setblocking mcve_setdropfile mcve_setip mcve_setssl_files mcve_setssl mcve_settimeout mcve_settle mcve_text_avs mcve_text_code mcve_text_cv mcve_transactionauth mcve_transactionavs mcve_transactionbatch mcve_transactioncv mcve_
    3              0.000029 syn keyword phpFunctions mhash_count mhash_get_block_size mhash_get_hash_name mhash_keygen_s2k mhash contained
    3              0.000018 syn keyword phpFunctions mime_content_type contained
    3              0.000042 syn keyword phpFunctions ming_setcubicthreshold ming_setscale ming_useswfversion SWFAction SWFBitmap swfbutton_keypress SWFbutton SWFDisplayItem SWFFill SWFFont SWFGradient SWFMorph SWFMovie SWFShape SWFSprite SWFText SWFTextField contained
    3              0.000123 syn keyword phpMethods getHeight getWidth addAction addShape setAction setdown setHit setOver setUp addColor move moveTo multColor remove Rotate rotateTo scale scaleTo setDepth setName setRatio skewX skewXTo skewY skewYTo moveTo rotateTo scaleTo skewXTo skewYTo getwidth addEntry getshape1 getshape2 add nextframe output remove save setbackground setdimension setframes setrate streammp3 addFill drawCurve drawCurveTo drawLine drawLineTo movePen movePenTo setLeftFill setLine setRightFill add nextframe remove setframes addString getWidth moveTo setColor setFont setHeight setSpacing addstring align setbounds setcolor setFont setHeight setindentation setLeftMargin setLineSpacing setMargins setname setrightMargin contained
    3              0.000045 syn keyword phpFunctions connection_aborted connection_status connection_timeout constant define defined die eval exit get_browser highlight_file highlight_string ignore_user_abort pack show_source sleep uniqid unpack usleep contained
    3              0.000050 syn keyword phpFunctions udm_add_search_limit udm_alloc_agent udm_api_version udm_cat_list udm_cat_path udm_check_charset udm_check_stored udm_clear_search_limits udm_close_stored udm_crc32 udm_errno udm_error udm_find udm_free_agent udm_free_ispell_data udm_free_res udm_get_doc_count udm_get_res_field udm_get_res_param udm_load_ispell_data udm_open_stored udm_set_agent_param contained
    3              0.000046 syn keyword phpFunctions msession_connect msession_count msession_create msession_destroy msession_disconnect msession_find msession_get_array msession_get msession_getdata msession_inc msession_list msession_listvar msession_lock msession_plugin msession_randstr msession_set_array msession_set msession_setdata msession_timeout msession_uniq msession_unlock contained
    3              0.000068 syn keyword phpFunctions msql_affected_rows msql_close msql_connect msql_create_db msql_createdb msql_data_seek msql_dbname msql_drop_db msql_dropdb msql_error msql_fetch_array msql_fetch_field msql_fetch_object msql_fetch_row msql_field_seek msql_fieldflags msql_fieldlen msql_fieldname msql_fieldtable msql_fieldtype msql_free_result msql_freeresult msql_list_dbs msql_list_fields msql_list_tables msql_listdbs msql_listfields msql_listtables msql_num_fields msql_num_rows msql_numfields msql_numrows msql_pconnect msql_query msql_regcase msql_result msql_select_db msql_selectdb msql_tablename msql contained
    3              0.000072 syn keyword phpFunctions mssql_bind mssql_close mssql_connect mssql_data_seek mssql_execute mssql_fetch_array mssql_fetch_assoc mssql_fetch_batch mssql_fetch_field mssql_fetch_object mssql_fetch_row mssql_field_length mssql_field_name mssql_field_seek mssql_field_type mssql_free_result mssql_free_statement mssql_get_last_message mssql_guid_string mssql_init mssql_min_error_severity mssql_min_message_severity mssql_next_result mssql_num_fields mssql_num_rows mssql_pconnect mssql_query mssql_result mssql_rows_affected mssql_select_db contained
    3              0.000047 syn keyword phpFunctions muscat_close muscat_get muscat_give muscat_setup_net muscat_setup contained
    3              0.000089 syn keyword phpFunctions mysql_affected_rows mysql_change_user mysql_client_encoding mysql_close mysql_connect mysql_create_db mysql_data_seek mysql_db_name mysql_db_query mysql_drop_db mysql_errno mysql_error mysql_escape_string mysql_fetch_array mysql_fetch_assoc mysql_fetch_field mysql_fetch_lengths mysql_fetch_object mysql_fetch_row mysql_field_flags mysql_field_len mysql_field_name mysql_field_seek mysql_field_table mysql_field_type mysql_free_result mysql_get_client_info mysql_get_host_info mysql_get_proto_info mysql_get_server_info mysql_info mysql_insert_id mysql_list_dbs mysql_list_fields mysql_list_processes mysql_list_tables mysql_num_fields mysql_num_rows mysql_pconnect mysql_ping mysql_query mysql_real_escape_string mysql_result mysql_select_db mysql_stat mysql_tablename mysql_thread_id mysql_unbuffered_query contained
    3              0.000213 syn keyword phpFunctions mysqli_affected_rows mysqli_autocommit mysqli_bind_param mysqli_bind_result mysqli_change_user mysqli_character_set_name mysqli_close mysqli_commit mysqli_connect mysqli_data_seek mysqli_debug mysqli_disable_reads_from_master mysqli_disable_rpl_parse mysqli_dump_debug_info mysqli_enable_reads_from_master mysqli_enable_rpl_parse mysqli_errno mysqli_error mysqli_execute mysqli_fetch_array mysqli_fetch_assoc mysqli_fetch_field_direct mysqli_fetch_field mysqli_fetch_fields mysqli_fetch_lengths mysqli_fetch_object mysqli_fetch_row mysqli_fetch mysqli_field_count mysqli_field_seek mysqli_field_tell mysqli_free_result mysqli_get_client_info mysqli_get_host_info mysqli_get_proto_info mysqli_get_server_info mysqli_get_server_version mysqli_info mysqli_init mysqli_insert_id mysqli_kill mysqli_master_query mysqli_num_fields mysqli_num_rows mysqli_options mysqli_param_count mysqli_ping mysqli_prepare_result mysqli_prepare mysqli_profiler mysqli_query mysqli_read_query_result mysqli_real_connect 
    3              0.000309 syn keyword phpFunctions ncurses_addch ncurses_addchnstr ncurses_addchstr ncurses_addnstr ncurses_addstr ncurses_assume_default_colors ncurses_attroff ncurses_attron ncurses_attrset ncurses_baudrate ncurses_beep ncurses_bkgd ncurses_bkgdset ncurses_border ncurses_bottom_panel ncurses_can_change_color ncurses_cbreak ncurses_clear ncurses_clrtobot ncurses_clrtoeol ncurses_color_content ncurses_color_set ncurses_curs_set ncurses_def_prog_mode ncurses_def_shell_mode ncurses_define_key ncurses_del_panel ncurses_delay_output ncurses_delch ncurses_deleteln ncurses_delwin ncurses_doupdate ncurses_echo ncurses_echochar ncurses_end ncurses_erase ncurses_erasechar ncurses_filter ncurses_flash ncurses_flushinp ncurses_getch ncurses_getmaxyx ncurses_getmouse ncurses_getyx ncurses_halfdelay ncurses_has_colors ncurses_has_ic ncurses_has_il ncurses_has_key ncurses_hide_panel ncurses_hline ncurses_inch ncurses_init_color ncurses_init_pair ncurses_init ncurses_insch ncurses_insdelln ncurses_insertln ncurses_insstr ncurses_ins
    3              0.000075 syn keyword phpFunctions checkdnsrr closelog debugger_off debugger_on define_syslog_variables dns_check_record dns_get_mx dns_get_record fsockopen gethostbyaddr gethostbyname gethostbynamel getmxrr getprotobyname getprotobynumber getservbyname getservbyport ip2long long2ip openlog pfsockopen socket_get_status socket_set_blocking socket_set_timeout syslog contained
    3              0.000039 syn keyword phpFunctions yp_all yp_cat yp_err_string yp_errno yp_first yp_get_default_domain yp_master yp_match yp_next yp_order contained
    3              0.000038 syn keyword phpFunctions notes_body notes_copy_db notes_create_db notes_create_note notes_drop_db notes_find_note notes_header_info notes_list_msgs notes_mark_read notes_mark_unread notes_nav_create notes_search notes_unread notes_version contained
    3              0.000018 syn keyword phpFunctions nsapi_request_headers nsapi_response_headers nsapi_virtual contained
    3              0.000035 syn keyword phpFunctions aggregate_info aggregate_methods_by_list aggregate_methods_by_regexp aggregate_methods aggregate_properties_by_list aggregate_properties_by_regexp aggregate_properties aggregate aggregation_info deaggregate contained
    3              0.000120 syn keyword phpFunctions ocibindbyname ocicancel ocicloselob ocicollappend ocicollassign ocicollassignelem ocicollgetelem ocicollmax ocicollsize ocicolltrim ocicolumnisnull ocicolumnname ocicolumnprecision ocicolumnscale ocicolumnsize ocicolumntype ocicolumntyperaw ocicommit ocidefinebyname ocierror ociexecute ocifetch ocifetchinto ocifetchstatement ocifreecollection ocifreecursor ocifreedesc ocifreestatement ociinternaldebug ociloadlob ocilogoff ocilogon ocinewcollection ocinewcursor ocinewdescriptor ocinlogon ocinumcols ociparse ociplogon ociresult ocirollback ocirowcount ocisavelob ocisavelobfile ociserverversion ocisetprefetch ocistatementtype ociwritelobtofile ociwritetemporarylob contained
    3              0.000124 syn keyword phpFunctions odbc_autocommit odbc_binmode odbc_close_all odbc_close odbc_columnprivileges odbc_columns odbc_commit odbc_connect odbc_cursor odbc_data_source odbc_do odbc_error odbc_errormsg odbc_exec odbc_execute odbc_fetch_array odbc_fetch_into odbc_fetch_object odbc_fetch_row odbc_field_len odbc_field_name odbc_field_num odbc_field_precision odbc_field_scale odbc_field_type odbc_foreignkeys odbc_free_result odbc_gettypeinfo odbc_longreadlen odbc_next_result odbc_num_fields odbc_num_rows odbc_pconnect odbc_prepare odbc_primarykeys odbc_procedurecolumns odbc_procedures odbc_result_all odbc_result odbc_rollback odbc_setoption odbc_specialcolumns odbc_statistics odbc_tableprivileges odbc_tables contained
    3              0.000116 syn keyword phpFunctions openssl_cipher_iv_length openssl_csr_export_to_file openssl_csr_export openssl_csr_get_public_key openssl_csr_get_subject openssl_csr_new openssl_csr_sign openssl_decrypt openssl_dh_compute_key openssl_digest openssl_encrypt openssl_error_string openssl_free_key openssl_get_cert_locations openssl_get_cipher_methods openssl_get_md_methods openssl_get_privatekey openssl_get_publickey openssl_open openssl_pbkdf2 openssl_pkcs12_export_to_file openssl_pkcs12_export openssl_pkcs12_read openssl_pkcs7_decrypt openssl_pkcs7_encrypt openssl_pkcs7_sign openssl_pkcs7_verify openssl_pkey_export_to_file openssl_pkey_export openssl_pkey_free openssl_pkey_get_details openssl_pkey_get_private openssl_pkey_get_public openssl_pkey_new openssl_private_decrypt openssl_private_encrypt openssl_public_decrypt openssl_public_encrypt openssl_random_pseudo_bytes openssl_seal openssl_sign openssl_spki_export_challenge openssl_spki_export openssl_spki_new openssl_spki_verify openssl_verify openssl_x509_check_pri
    3              0.000052 syn keyword phpFunctions ora_bind ora_close ora_columnname ora_columnsize ora_columntype ora_commit ora_commitoff ora_commiton ora_do ora_error ora_errorcode ora_exec ora_fetch_into ora_fetch ora_getcolumn ora_logoff ora_logon ora_numcols ora_numrows ora_open ora_parse ora_plogon ora_rollback contained
    3              0.000039 syn keyword phpFunctions flush ob_clean ob_end_clean ob_end_flush ob_flush ob_get_clean ob_get_contents ob_get_flush ob_get_length ob_get_level ob_get_status ob_gzhandler ob_implicit_flush ob_list_handlers ob_start output_add_rewrite_var output_reset_rewrite_vars contained
    3              0.000017 syn keyword phpFunctions overload contained
    3              0.000044 syn keyword phpFunctions ovrimos_close ovrimos_commit ovrimos_connect ovrimos_cursor ovrimos_exec ovrimos_execute ovrimos_fetch_into ovrimos_fetch_row ovrimos_field_len ovrimos_field_name ovrimos_field_num ovrimos_field_type ovrimos_free_result ovrimos_longreadlen ovrimos_num_fields ovrimos_num_rows ovrimos_prepare ovrimos_result_all ovrimos_result ovrimos_rollback contained
    3              0.000062 syn keyword phpFunctions pcntl_exec pcntl_fork pcntl_signal pcntl_waitpid pcntl_wexitstatus pcntl_wifexited pcntl_wifsignaled pcntl_wifstopped pcntl_wstopsig pcntl_wtermsig contained
    3              0.000031 syn keyword phpFunctions preg_grep preg_match_all preg_match preg_quote preg_replace_callback preg_replace preg_split contained
    3              0.000243 syn keyword phpFunctions pdf_add_annotation pdf_add_bookmark pdf_add_launchlink pdf_add_locallink pdf_add_note pdf_add_outline pdf_add_pdflink pdf_add_thumbnail pdf_add_weblink pdf_arc pdf_arcn pdf_attach_file pdf_begin_page pdf_begin_pattern pdf_begin_template pdf_circle pdf_clip pdf_close_image pdf_close_pdi_page pdf_close_pdi pdf_close pdf_closepath_fill_stroke pdf_closepath_stroke pdf_closepath pdf_concat pdf_continue_text pdf_curveto pdf_delete pdf_end_page pdf_end_pattern pdf_end_template pdf_endpath pdf_fill_stroke pdf_fill pdf_findfont pdf_get_buffer pdf_get_font pdf_get_fontname pdf_get_fontsize pdf_get_image_height pdf_get_image_width pdf_get_majorversion pdf_get_minorversion pdf_get_parameter pdf_get_pdi_parameter pdf_get_pdi_value pdf_get_value pdf_initgraphics pdf_lineto pdf_makespotcolor pdf_moveto pdf_new pdf_open_CCITT pdf_open_file pdf_open_gif pdf_open_image_file pdf_open_image pdf_open_jpeg pdf_open_memory_image pdf_open_pdi_page pdf_open_pdi pdf_open_png pdf_open_tiff pdf_open pdf_place_i
    3              0.000065 syn keyword phpFunctions pfpro_cleanup pfpro_init pfpro_process_raw pfpro_process pfpro_version contained
    3              0.000106 syn keyword phpFunctions pg_affected_rows pg_cancel_query pg_client_encoding pg_close pg_connect pg_connection_busy pg_connection_reset pg_connection_status pg_convert pg_copy_from pg_copy_to pg_dbname pg_delete pg_end_copy pg_escape_bytea pg_escape_string pg_fetch_all pg_fetch_array pg_fetch_assoc pg_fetch_object pg_fetch_result pg_fetch_row pg_field_is_null pg_field_name pg_field_num pg_field_prtlen pg_field_size pg_field_type pg_free_result pg_get_notify pg_get_pid pg_get_result pg_host pg_insert pg_last_error pg_last_notice pg_last_oid pg_lo_close pg_lo_create pg_lo_export pg_lo_import pg_lo_open pg_lo_read_all pg_lo_read pg_lo_seek pg_lo_tell pg_lo_unlink pg_lo_write pg_meta_data pg_num_fields pg_num_rows pg_options pg_pconnect pg_ping pg_port pg_put_line pg_query pg_result_error pg_result_seek pg_result_status pg_select pg_send_query pg_set_client_encoding pg_trace pg_tty pg_unescape_bytea pg_untrace pg_update contained
    3              0.000063 syn keyword phpFunctions posix_ctermid posix_get_last_error posix_getcwd posix_getegid posix_geteuid posix_getgid posix_getgrgid posix_getgrnam posix_getgroups posix_getlogin posix_getpgid posix_getpgrp posix_getpid posix_getppid posix_getpwnam posix_getpwuid posix_getrlimit posix_getsid posix_getuid posix_isatty posix_kill posix_mkfifo posix_setegid posix_seteuid posix_setgid posix_setpgid posix_setsid posix_setuid posix_strerror posix_times posix_ttyname posix_uname contained
    3              0.000065 syn keyword phpFunctions printer_abort printer_close printer_create_brush printer_create_dc printer_create_font printer_create_pen printer_delete_brush printer_delete_dc printer_delete_font printer_delete_pen printer_draw_bmp printer_draw_chord printer_draw_elipse printer_draw_line printer_draw_pie printer_draw_rectangle printer_draw_roundrect printer_draw_text printer_end_doc printer_end_page printer_get_option printer_list printer_logical_fontheight printer_open printer_select_brush printer_select_font printer_select_pen printer_set_option printer_start_doc printer_start_page printer_write contained
    3              0.000041 syn keyword phpFunctions pspell_add_to_personal pspell_add_to_session pspell_check pspell_clear_session pspell_config_create pspell_config_ignore pspell_config_mode pspell_config_personal pspell_config_repl pspell_config_runtogether pspell_config_save_repl pspell_new_config pspell_new_personal pspell_new pspell_save_wordlist pspell_store_replacement pspell_suggest contained
    3              0.000016 syn keyword phpFunctions qdom_error qdom_tree contained
    3              0.000033 syn keyword phpFunctions readline_add_history readline_clear_history readline_completion_function readline_info readline_list_history readline_read_history readline_write_history readline contained
    3              0.000021 syn keyword phpFunctions recode_file recode_string recode contained
    3              0.000024 syn keyword phpFunctions ereg_replace ereg eregi_replace eregi split spliti sql_regcase contained
    3              0.000041 syn keyword phpFunctions ftok msg_get_queue msg_receive msg_remove_queue msg_send msg_set_queue msg_stat_queue sem_acquire sem_get sem_release sem_remove shm_attach shm_detach shm_get_var shm_put_var shm_remove_var shm_remove contained
    3              0.000052 syn keyword phpFunctions sesam_affected_rows sesam_commit sesam_connect sesam_diagnostic sesam_disconnect sesam_errormsg sesam_execimm sesam_fetch_array sesam_fetch_result sesam_fetch_row sesam_field_array sesam_field_name sesam_free_result sesam_num_fields sesam_query sesam_rollback sesam_seek_row sesam_settransaction contained
    3              0.000048 syn keyword phpFunctions session_cache_expire session_cache_limiter session_decode session_destroy session_encode session_get_cookie_params session_id session_is_registered session_module_name session_name session_regenerate_id session_register session_save_path session_set_cookie_params session_set_save_handler session_start session_unregister session_unset session_write_close contained
    3              0.000027 syn keyword phpFunctions shmop_close shmop_delete shmop_open shmop_read shmop_size shmop_write contained
    3              0.000049 syn keyword phpFunctions snmp_get_quick_print snmp_set_quick_print snmpget snmprealwalk snmpset snmpwalk snmpwalkoid contained
    3              0.000084 syn keyword phpFunctions socket_accept socket_bind socket_clear_error socket_close socket_connect socket_create_listen socket_create_pair socket_create socket_get_option socket_getpeername socket_getsockname socket_iovec_add socket_iovec_alloc socket_iovec_delete socket_iovec_fetch socket_iovec_free socket_iovec_set socket_last_error socket_listen socket_read socket_readv socket_recv socket_recvfrom socket_recvmsg socket_select socket_send socket_sendmsg socket_sendto socket_set_block socket_set_nonblock socket_set_option socket_shutdown socket_strerror socket_write socket_writev contained
    3              0.000080 syn keyword phpFunctions sqlite_array_query sqlite_busy_timeout sqlite_changes sqlite_close sqlite_column sqlite_create_aggregate sqlite_create_function sqlite_current sqlite_error_string sqlite_escape_string sqlite_fetch_array sqlite_fetch_single sqlite_fetch_string sqlite_field_name sqlite_has_more sqlite_last_error sqlite_last_insert_rowid sqlite_libencoding sqlite_libversion sqlite_next sqlite_num_fields sqlite_num_rows sqlite_open sqlite_popen sqlite_query sqlite_rewind sqlite_seek sqlite_udf_decode_binary sqlite_udf_encode_binary sqlite_unbuffered_query contained
    3              0.000092 syn keyword phpFunctions stream_context_create stream_context_get_options stream_context_set_option stream_context_set_params stream_copy_to_stream stream_filter_append stream_filter_prepend stream_filter_register stream_get_contents stream_get_filters stream_get_line stream_get_meta_data stream_get_transports stream_get_wrappers stream_register_wrapper stream_select stream_set_blocking stream_set_timeout stream_set_write_buffer stream_socket_accept stream_socket_client stream_socket_get_name stream_socket_recvfrom stream_socket_sendto stream_socket_server stream_wrapper_register contained
    3              0.000144 syn keyword phpFunctions addcslashes addslashes bin2hex chop chr chunk_split convert_cyr_string count_chars crc32 crypt explode fprintf get_html_translation_table hebrev hebrevc html_entity_decode htmlentities htmlspecialchars implode join levenshtein localeconv ltrim md5_file md5 metaphone money_format nl_langinfo nl2br number_format ord parse_str print printf quoted_printable_decode quotemeta rtrim setlocale sha1_file sha1 similar_text soundex sprintf sscanf str_ireplace str_pad str_repeat str_replace str_rot13 str_shuffle str_split str_word_count strcasecmp strchr strcmp strcoll strcspn strip_tags stripcslashes stripos stripslashes stristr strlen strnatcasecmp strnatcmp strncasecmp strncmp strpos strrchr strrev strripos strrpos strspn strstr strtok strtolower strtoupper strtr substr_compare substr_count substr_replace substr trim ucfirst ucwords vprintf vsprintf wordwrap contained
    3              0.000119 syn keyword phpFunctions swf_actiongeturl swf_actiongotoframe swf_actiongotolabel swf_actionnextframe swf_actionplay swf_actionprevframe swf_actionsettarget swf_actionstop swf_actiontogglequality swf_actionwaitforframe swf_addbuttonrecord swf_addcolor swf_closefile swf_definebitmap swf_definefont swf_defineline swf_definepoly swf_definerect swf_definetext swf_endbutton swf_enddoaction swf_endshape swf_endsymbol swf_fontsize swf_fontslant swf_fonttracking swf_getbitmapinfo swf_getfontinfo swf_getframe swf_labelframe swf_lookat swf_modifyobject swf_mulcolor swf_nextid swf_oncondition swf_openfile swf_ortho2 swf_ortho swf_perspective swf_placeobject swf_polarview swf_popmatrix swf_posround swf_pushmatrix swf_removeobject swf_rotate swf_scale swf_setfont swf_setframe swf_shapearc swf_shapecurveto3 swf_shapecurveto swf_shapefillbitmapclip swf_shapefillbitmaptile swf_shapefilloff swf_shapefillsolid swf_shapelinesolid swf_shapelineto swf_shapemoveto swf_showframe swf_startbutton swf_startdoaction swf_startshape swf
    3              0.000085 syn keyword phpFunctions sybase_affected_rows sybase_close sybase_connect sybase_data_seek sybase_deadlock_retry_count sybase_fetch_array sybase_fetch_assoc sybase_fetch_field sybase_fetch_object sybase_fetch_row sybase_field_seek sybase_free_result sybase_get_last_message sybase_min_client_severity sybase_min_error_severity sybase_min_message_severity sybase_min_server_severity sybase_num_fields sybase_num_rows sybase_pconnect sybase_query sybase_result sybase_select_db sybase_set_message_handler sybase_unbuffered_query contained
    3              0.000057 syn keyword phpFunctions tidy_access_count tidy_clean_repair tidy_config_count tidy_diagnose tidy_error_count tidy_get_body tidy_get_config tidy_get_error_buffer tidy_get_head tidy_get_html_ver tidy_get_html tidy_get_output tidy_get_release tidy_get_root tidy_get_status tidy_getopt tidy_is_xhtml tidy_load_config tidy_parse_file tidy_parse_string tidy_repair_file tidy_repair_string tidy_reset_config tidy_save_config tidy_set_encoding tidy_setopt tidy_warning_count contained
    3              0.000038 syn keyword phpMethods attributes children get_attr get_nodes has_children has_siblings is_asp is_comment is_html is_jsp is_jste is_text is_xhtml is_xml next prev tidy_node contained
    3              0.000018 syn keyword phpFunctions token_get_all token_name contained
    3              0.000029 syn keyword phpFunctions base64_decode base64_encode get_meta_tags http_build_query parse_url rawurldecode rawurlencode urldecode urlencode contained
    3              0.000053 syn keyword phpFunctions doubleval empty floatval get_defined_vars get_resource_type gettype import_request_variables intval is_array is_bool is_callable is_double is_float is_int is_integer is_long is_null is_numeric is_object is_real is_resource is_scalar is_string isset print_r serialize settype strval unserialize unset var_dump var_export contained
    3              0.000044 syn keyword phpFunctions vpopmail_add_alias_domain_ex vpopmail_add_alias_domain vpopmail_add_domain_ex vpopmail_add_domain vpopmail_add_user vpopmail_alias_add vpopmail_alias_del_domain vpopmail_alias_del vpopmail_alias_get_all vpopmail_alias_get vpopmail_auth_user vpopmail_del_domain_ex vpopmail_del_domain vpopmail_del_user vpopmail_error vpopmail_passwd vpopmail_set_user_quota contained
    3              0.000024 syn keyword phpFunctions w32api_deftype w32api_init_dtype w32api_invoke_function w32api_register_function w32api_set_call_method contained
    3              0.000025 syn keyword phpFunctions wddx_add_vars wddx_deserialize wddx_packet_end wddx_packet_start wddx_serialize_value wddx_serialize_vars contained
    3              0.000060 syn keyword phpFunctions utf8_decode utf8_encode xml_error_string xml_get_current_byte_index xml_get_current_column_number xml_get_current_line_number xml_get_error_code xml_parse_into_struct xml_parse xml_parser_create_ns xml_parser_create xml_parser_free xml_parser_get_option xml_parser_set_option xml_set_character_data_handler xml_set_default_handler xml_set_element_handler xml_set_end_namespace_decl_handler xml_set_external_entity_ref_handler xml_set_notation_decl_handler xml_set_object xml_set_processing_instruction_handler xml_set_start_namespace_decl_handler xml_set_unparsed_entity_decl_handler contained
    3              0.000047 syn keyword phpFunctions xmlrpc_decode_request xmlrpc_decode xmlrpc_encode_request xmlrpc_encode xmlrpc_get_type xmlrpc_parse_method_descriptions xmlrpc_server_add_introspection_data xmlrpc_server_call_method xmlrpc_server_create xmlrpc_server_destroy xmlrpc_server_register_introspection_callback xmlrpc_server_register_method xmlrpc_set_type contained
    3              0.000035 syn keyword phpFunctions xslt_create xslt_errno xslt_error xslt_free xslt_output_process xslt_set_base xslt_set_encoding xslt_set_error_handler xslt_set_log xslt_set_sax_handler xslt_set_sax_handlers xslt_set_scheme_handler xslt_set_scheme_handlers contained
    3              0.000069 syn keyword phpFunctions yaz_addinfo yaz_ccl_conf yaz_ccl_parse yaz_close yaz_connect yaz_database yaz_element yaz_errno yaz_error yaz_es_result yaz_get_option yaz_hits yaz_itemorder yaz_present yaz_range yaz_record yaz_scan_result yaz_scan yaz_schema yaz_search yaz_set_option yaz_sort yaz_syntax yaz_wait contained
    3              0.000044 syn keyword phpFunctions zip_close zip_entry_close zip_entry_compressedsize zip_entry_compressionmethod zip_entry_filesize zip_entry_name zip_entry_open zip_entry_read zip_open zip_read contained
    3              0.000044 syn keyword phpFunctions gzclose gzcompress gzdeflate gzencode gzeof gzfile gzgetc gzgets gzgetss gzinflate gzopen gzpassthru gzputs gzread gzrewind gzseek gztell gzuncompress gzwrite readgzfile zlib_get_coding_type contained
                            
    3              0.000099 if exists( "php_baselib" )
                              syn keyword phpMethods query next_record num_rows affected_rows nf f p np num_fields haltmsg seek link_id query_id metadata table_names nextid connect halt free register unregister is_registered delete url purl self_url pself_url hidden_session add_query padd_query reimport_get_vars reimport_post_vars reimport_cookie_vars set_container set_tokenname release_token put_headers get_id get_id put_id freeze thaw gc reimport_any_vars start url purl login_if is_authenticated auth_preauth auth_loginform auth_validatelogin auth_refreshlogin auth_registerform auth_doregister start check have_perm permsum perm_invalid contained
                              syn keyword phpFunctions page_open page_close sess_load sess_save contained
                            endif
                            
                            " Conditional
    3              0.000039 syn keyword phpConditional declare else enddeclare endswitch elseif endif if switch contained
                            
                            " Repeat
    3              0.000025 syn keyword phpRepeat as do endfor endforeach endwhile for foreach while contained
                            
                            " Repeat
    3              0.000017 syn keyword phpLabel case default switch contained
                            
                            " Statement
    3              0.000027 syn keyword phpStatement return break continue exit goto yield contained
                            
                            " Keyword
    3              0.000019 syn keyword phpKeyword var const contained
                            
                            " Type
    3              0.000033 syn keyword phpType void bool boolean int integer real double float string array object NULL callable iterable contained
                            
                            " Structure
    3              0.000022 syn keyword phpStructure namespace extends implements instanceof parent self contained
                            
                            " Operator
    3              0.000035 syn match phpOperator "[-=+%^&|*!.~?:]" contained display
    3              0.000048 syn match phpOperator "[-+*/%^&|.]=" contained display
    3              0.000026 syn match phpOperator "/[^*/]"me=e-1 contained display
    3              0.000019 syn match phpOperator "\$" contained display
    3              0.000035 syn match phpOperator "&&\|\<and\>" contained display
    3              0.000049 syn match phpOperator "||\|\<x\=or\>" contained display
    3              0.000023 syn match phpRelation "[!=<>]=" contained display
    3              0.000019 syn match phpRelation "[<>]" contained display
    3              0.000019 syn match phpMemberSelector "->" contained display
    3              0.000048 syn match phpVarSelector "\$" contained display
                            
                            " Identifier
    3              0.000124 syn match phpIdentifier "$\h\w*" contained contains=phpEnvVar,phpIntVar,phpVarSelector display
    3              0.000071 syn match phpIdentifierSimply "${\h\w*}" contains=phpOperator,phpParent contained display
    3              0.000131 syn region phpIdentifierComplex matchgroup=phpParent start="{\$"rs=e-1 end="}" contains=phpIdentifier,phpMemberSelector,phpVarSelector,phpIdentifierComplexP contained extend
    3              0.000046 syn region phpIdentifierComplexP matchgroup=phpParent start="\[" end="]" contains=@phpClInside contained
                            
                            " Interpolated indentifiers (inside strings)
    3              0.000023 	syn match phpBrackets "[][}{]" contained display
                            	" errors
    3              0.000020 		syn match phpInterpSimpleError "\[[^]]*\]" contained display " fallback (if nothing else matches)
    3              0.000019 		syn match phpInterpSimpleError "->[^a-zA-Z_]" contained display
                            		" make sure these stay above the correct DollarCurlies so they don't take priority
    3              0.000019 		syn match phpInterpBogusDollarCurley "${[^}]*}" contained display " fallback (if nothing else matches)
    3              0.000019 	syn match phpinterpSimpleBracketsInner "\w\+" contained
    3              0.000064 	syn match phpInterpSimpleBrackets "\[\h\w*]" contained contains=phpBrackets,phpInterpSimpleBracketsInner
    3              0.000060 	syn match phpInterpSimpleBrackets "\[\d\+]" contained contains=phpBrackets,phpInterpSimpleBracketsInner
    3              0.000063 	syn match phpInterpSimpleBrackets "\[0[xX]\x\+]" contained contains=phpBrackets,phpInterpSimpleBracketsInner
    3              0.000159 	syn match phpInterpSimple "\$\h\w*\(\[[^]]*\]\|->\h\w*\)\?" contained contains=phpInterpSimpleBrackets,phpIdentifier,phpInterpSimpleError,phpMethods,phpMemberSelector display
    3              0.000034 	syn match phpInterpVarname "\h\w*" contained
    3              0.000020 	syn match phpInterpMethodName "\h\w*" contained " default color
    3              0.000046 	syn match phpInterpSimpleCurly "\${\h\w*}" contains=phpInterpVarname contained extend
    3              0.000092 	syn region phpInterpDollarCurley1Helper matchgroup=phpParent start="{" end="\[" contains=phpInterpVarname contained
    3              0.000080 	syn region phpInterpDollarCurly1 matchgroup=phpParent start="\${\h\w*\["rs=s+1 end="]}" contains=phpInterpDollarCurley1Helper,@phpClConst contained extend
                            
    3              0.000084 	syn match phpInterpDollarCurley2Helper "{\h\w*->" contains=phpBrackets,phpInterpVarname,phpMemberSelector contained
                            
    3              0.000093 	syn region phpInterpDollarCurly2 matchgroup=phpParent start="\${\h\w*->"rs=s+1 end="}" contains=phpInterpDollarCurley2Helper,phpInterpMethodName contained
                            
    3              0.000026 	syn match phpInterpBogusDollarCurley "${\h\w*->}" contained display
    3              0.000019 	syn match phpInterpBogusDollarCurley "${\h\w*\[]}" contained display
                            
    3              0.000181 	syn region phpInterpComplex matchgroup=phpParent start="{\$"rs=e-1 end="}" contains=phpIdentifier,phpMemberSelector,phpVarSelector,phpIdentifierComplexP contained extend
    3              0.000048 	syn region phpIdentifierComplexP matchgroup=phpParent start="\[" end="]" contains=@phpClInside contained
                            	" define a cluster to get all interpolation syntaxes for double-quoted strings
    3              0.000144 	syn cluster phpInterpDouble contains=phpInterpSimple,phpInterpSimpleCurly,phpInterpDollarCurly1,phpInterpDollarCurly2,phpInterpBogusDollarCurley,phpInterpComplex
                            
                            " Methoden
    3              0.000099 syn match phpMethodsVar "->\h\w*" contained contains=phpMethods,phpMemberSelector display
                            
                            " Include
    3              0.000035 syn keyword phpInclude include require include_once require_once use contained
                            
                            " Define
    3              0.000018 syn keyword phpDefine new clone contained
                            
                            " Boolean
    3              0.000016 syn keyword phpBoolean true false contained
                            
                            " Number
    3              0.000025 syn match phpNumber "-\=\<\d\+\>" contained display
    3              0.000026 syn match phpNumber "\<0x\x\{1,8}\>" contained display
                            
                            " Float
    3              0.000024 syn match phpFloat "\(-\=\<\d+\|-\=\)\.\d\+\>" contained display
                            
                            " Backslash escapes
    3              0.000005 	syn case match
                            	" for double quotes and heredoc
    3              0.000024 	syn match phpBackslashSequences "\\[fnrtv\\\"$]" contained display
    3              0.000042 	syn match phpBackslashSequences "\\\d\{1,3}" contained contains=phpOctalError display
    3              0.000020 	syn match phpBackslashSequences "\\x\x\{1,2}" contained display
                            	" additional sequence for double quotes only
    3              0.000020 	syn match phpBackslashDoubleQuote "\\[\"]" contained display
                            	" for single quotes only
    3              0.000018 	syn match phpBackslashSingleQuote "\\[\\']" contained display
    3              0.000003 	syn case ignore
                            
                            
                            " Error
    3              0.000017 syn match phpOctalError "[89]" contained display
    3              0.000017 if exists("php_parent_error_close")
                              syn match phpParentError "[)\]}]" contained display
                            endif
                            
                            " Todo
    3              0.000020 syn keyword phpTodo todo fixme xxx contained
                            
                            " Comment
    3              0.000009 if exists("php_parent_error_open")
                              syn region phpComment start="/\*" end="\*/" contained contains=phpTodo,@Spell
                            else
    3              0.000059   syn region phpComment start="/\*" end="\*/" contained contains=phpTodo,@Spell extend
    3              0.000003 endif
    3              0.000056 syn match phpComment "#.\{-}\(?>\|$\)\@=" contained contains=phpTodo,@Spell
    3              0.000109 syn match phpComment "//.\{-}\(?>\|$\)\@=" contained contains=phpTodo,@Spell
                            
                            " String
    3              0.000017 if exists("php_parent_error_open")
                              syn region phpStringDouble matchgroup=phpStringDouble start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@phpAddStrings,phpBackslashSequences,phpBackslashDoubleQuote,@phpInterpDouble,@Spell contained keepend
                              syn region phpBacktick matchgroup=phpBacktick start=+`+ skip=+\\\\\|\\"+ end=+`+ contains=@phpAddStrings,phpIdentifier,phpBackslashSequences,phpIdentifierSimply,phpIdentifierComplex contained keepend
                              syn region phpStringSingle matchgroup=phpStringSingle start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@phpAddStrings,phpBackslashSingleQuote,@Spell contained keepend
                            else
    3              0.000095   syn region phpStringDouble matchgroup=phpStringDouble start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=@phpAddStrings,phpBackslashSequences,phpBackslashDoubleQuote,@phpInterpDouble,@Spell contained extend keepend
    3              0.000129   syn region phpBacktick matchgroup=phpBacktick start=+`+ skip=+\\\\\|\\"+ end=+`+ contains=@phpAddStrings,phpIdentifier,phpBackslashSequences,phpIdentifierSimply,phpIdentifierComplex contained extend keepend
    3              0.000076   syn region phpStringSingle matchgroup=phpStringSingle start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=@phpAddStrings,phpBackslashSingleQuote,@Spell contained keepend extend
    3              0.000004 endif
                            
                            " HereDoc and NowDoc
    3              0.000003 syn case match
                            
                            " HereDoc
    3              0.000212 syn region phpHereDoc matchgroup=Delimiter start="\(<<<\)\@<=\(\"\=\)\z(\I\i*\)\2$" end="^\z1\(;\=$\)\@=" contained contains=phpIdentifier,phpIdentifierSimply,phpIdentifierComplex,phpBackslashSequences,phpMethodsVar,@Spell keepend extend
                            " including HTML,JavaScript,SQL even if not enabled via options
    3              0.000202 syn region phpHereDoc matchgroup=Delimiter start="\(<<<\)\@<=\(\"\=\)\z(\(\I\i*\)\=\(html\)\c\(\i*\)\)\2$" end="^\z1\(;\=$\)\@=" contained contains=@htmlTop,phpIdentifier,phpIdentifierSimply,phpIdentifierComplex,phpBackslashSequences,phpMethodsVar,@Spell keepend extend
    3              0.000221 syn region phpHereDoc matchgroup=Delimiter start="\(<<<\)\@<=\(\"\=\)\z(\(\I\i*\)\=\(sql\)\c\(\i*\)\)\2$" end="^\z1\(;\=$\)\@=" contained contains=@sqlTop,phpIdentifier,phpIdentifierSimply,phpIdentifierComplex,phpBackslashSequences,phpMethodsVar,@Spell keepend extend
    3              0.000186 syn region phpHereDoc matchgroup=Delimiter start="\(<<<\)\@<=\(\"\=\)\z(\(\I\i*\)\=\(javascript\)\c\(\i*\)\)\2$" end="^\z1\(;\=$\)\@=" contained contains=@htmlJavascript,phpIdentifierSimply,phpIdentifier,phpIdentifierComplex,phpBackslashSequences,phpMethodsVar,@Spell keepend extend
                            
                            " NowDoc
    3              0.000076 syn region phpNowDoc matchgroup=Delimiter start="\(<<<\)\@<='\z(\I\i*\)'$" end="^\z1\(;\=$\)\@=" contained contains=@Spell keepend extend
                            " including HTML,JavaScript,SQL even if not enabled via options
    3              0.000069 syn region phpNowDoc matchgroup=Delimiter start="\(<<<\)\@<='\z(\(\I\i*\)\=\(html\)\c\(\i*\)\)'$" end="^\z1\(;\=$\)\@=" contained contains=@htmlTop,@Spell keepend extend
    3              0.000103 syn region phpNowDoc matchgroup=Delimiter start="\(<<<\)\@<='\z(\(\I\i*\)\=\(sql\)\c\(\i*\)\)'$" end="^\z1\(;\=$\)\@=" contained contains=@sqlTop,@Spell keepend extend
    3              0.000075 syn region phpNowDoc matchgroup=Delimiter start="\(<<<\)\@<='\z(\(\I\i*\)\=\(javascript\)\c\(\i*\)\)'$" end="^\z1\(;\=$\)\@=" contained contains=@htmlJavascript,@Spell keepend extend
    3              0.000004 syn case ignore
                            
                            " Parent
    3              0.000020 if exists("php_parent_error_close") || exists("php_parent_error_open")
                              syn match phpParent "[{}]" contained
                              syn region phpParent matchgroup=Delimiter start="(" end=")" contained contains=@phpClInside transparent
                              syn region phpParent matchgroup=Delimiter start="\[" end="\]" contained contains=@phpClInside transparent
                              if !exists("php_parent_error_close")
                                syn match phpParent "[\])]" contained
                              endif
                            else
    3              0.000036   syn match phpParent "[({[\]})]" contained
    3              0.000004 endif
                            
    3              0.000482 syn cluster phpClConst contains=phpFunctions,phpIdentifier,phpConditional,phpRepeat,phpStatement,phpOperator,phpRelation,phpStringSingle,phpStringDouble,phpBacktick,phpNumber,phpFloat,phpKeyword,phpType,phpBoolean,phpStructure,phpMethodsVar,phpConstant,phpCoreConstant,phpException
    3              0.000184 syn cluster phpClInside contains=@phpClConst,phpComment,phpLabel,phpParent,phpParentError,phpInclude,phpHereDoc,phpNowDoc
    3              0.000077 syn cluster phpClFunction contains=@phpClInside,phpDefine,phpParentError,phpStorageClass
    3              0.000116 syn cluster phpClTop contains=@phpClFunction,phpFoldFunction,phpFoldClass,phpFoldInterface,phpFoldTry,phpFoldCatch
                            
                            " Php Region
    3              0.000014 if exists("php_parent_error_open")
                              if exists("php_noShortTags")
                                syn region phpRegion matchgroup=Delimiter start="<?php" end="?>" contains=@phpClTop
                              else
                                syn region phpRegion matchgroup=Delimiter start="<?\(php\)\=" end="?>" contains=@phpClTop
                              endif
                              syn region phpRegionSc matchgroup=Delimiter start=+<script language="php">+ end=+</script>+ contains=@phpClTop
                              if exists("php_asp_tags")
                                syn region phpRegionAsp matchgroup=Delimiter start="<%\(=\)\=" end="%>" contains=@phpClTop
                              endif
                            else
    3              0.000015   if exists("php_noShortTags")
                                syn region phpRegion matchgroup=Delimiter start="<?php" end="?>" contains=@phpClTop keepend
                              else
    3              0.000069     syn region phpRegion matchgroup=Delimiter start="<?\(php\)\=" end="?>" contains=@phpClTop keepend
    3              0.000030   endif
    3              0.000075   syn region phpRegionSc matchgroup=Delimiter start=+<script language="php">+ end=+</script>+ contains=@phpClTop keepend
    3              0.000012   if exists("php_asp_tags")
                                syn region phpRegionAsp matchgroup=Delimiter start="<%\(=\)\=" end="%>" contains=@phpClTop keepend
                              endif
    3              0.000002 endif
                            
                            " Fold
    3              0.000012 if exists("php_folding") && php_folding==1
                            " match one line constructs here and skip them at folding
                              syn keyword phpSCKeyword abstract final private protected public static contained
                              syn keyword phpFCKeyword function contained
                              syn keyword phpStorageClass global contained
                              syn match phpDefine "\(\s\|^\)\(abstract\s\+\|final\s\+\|private\s\+\|protected\s\+\|public\s\+\|static\s\+\)*function\(\s\+.*[;}]\)\@=" contained contains=phpSCKeyword
                              syn match phpStructure "\(\s\|^\)\(abstract\s\+\|final\s\+\)*\(trait\|class\)\(\s\+.*}\)\@=" contained
                              syn match phpStructure "\(\s\|^\)interface\(\s\+.*}\)\@=" contained
                              syn match phpException "\(\s\|^\)try\(\s\+.*}\)\@=" contained
                              syn match phpException "\(\s\|^\)catch\(\s\+.*}\)\@=" contained
                              syn match phpException "\(\s\|^\)finally\(\s\+.*}\)\@=" contained
                            
                              set foldmethod=syntax
                              syn region phpFoldHtmlInside matchgroup=Delimiter start="?>" end="<?\(php\)\=" contained transparent contains=@htmlTop
                              syn region phpFoldFunction matchgroup=Storageclass start="^\z(\s*\)\(abstract\s\+\|final\s\+\|private\s\+\|protected\s\+\|public\s\+\|static\s\+\)*function\s\([^};]*$\)\@="rs=e-9 matchgroup=Delimiter end="^\z1}" contains=@phpClFunction,phpFoldHtmlInside,phpFCKeyword contained transparent fold extend
                              syn region phpFoldFunction matchgroup=Define start="^function\s\([^};]*$\)\@=" matchgroup=Delimiter end="^}" contains=@phpClFunction,phpFoldHtmlInside contained transparent fold extend
                              syn region phpFoldClass matchgroup=Structure start="^\z(\s*\)\(abstract\s\+\|final\s\+\)*\(trait\|class\)\s\+\([^}]*$\)\@=" matchgroup=Delimiter end="^\z1}" contains=@phpClFunction,phpFoldFunction,phpSCKeyword contained transparent fold extend
                              syn region phpFoldInterface matchgroup=Structure start="^\z(\s*\)interface\s\+\([^}]*$\)\@=" matchgroup=Delimiter end="^\z1}" contains=@phpClFunction,phpFoldFunction contained transparent fold extend
                              syn region phpFoldCatch matchgroup=Exception start="^\z(\s*\)catch\s\+\([^}]*$\)\@=" matchgroup=Delimiter end="^\z1}" contains=@phpClFunction,phpFoldFunction contained transparent fold extend
                              syn region phpFoldTry matchgroup=Exception start="^\z(\s*\)try\s\+\([^}]*$\)\@=" matchgroup=Delimiter end="^\z1}" contains=@phpClFunction,phpFoldFunction contained transparent fold extend
                            else
    3              0.000018   syn keyword phpDefine function contained
    3              0.000022   syn keyword phpStructure abstract class trait interface contained
    3              0.000020   syn keyword phpException catch throw try finally contained
    3              0.000023   syn keyword phpStorageClass final global private protected public static contained
    3              0.000013   if exists("php_folding") && php_folding==2
                                set foldmethod=syntax
                                syn region phpFoldHtmlInside matchgroup=Delimiter start="?>" end="<?\(php\)\=" contained transparent contains=@htmlTop
                                syn region phpParent matchgroup=Delimiter start="{" end="}" contained contains=@phpClFunction,phpFoldHtmlInside transparent fold
                              endif
    3              0.000003 endif
                            
                            " ================================================================
                            " Peter Hodge - June 9, 2006
                            " Some of these changes (highlighting isset/unset/echo etc) are not so
                            " critical, but they make things more colourful. :-)
                            
                            " different syntax highlighting for 'echo', 'print', 'switch', 'die' and 'list' keywords
                            " to better indicate what they are.
    3              0.000018 syntax keyword phpDefine echo print contained
    3              0.000016 syntax keyword phpStructure list contained
    3              0.000016 syntax keyword phpConditional switch contained
    3              0.000014 syntax keyword phpStatement die contained
                            
                            " Highlighting for PHP5's user-definable magic class methods
    3              0.000141 syntax keyword phpSpecialFunction containedin=ALLBUT,phpComment,phpStringDouble,phpStringSingle,phpIdentifier
                              \ __construct __destruct __call __callStatic __get __set __isset __unset __sleep __wakeup __toString __invoke __set_state __clone __debugInfo
                            " Highlighting for __autoload slightly different from line above
    3              0.000130 syntax keyword phpSpecialFunction containedin=ALLBUT,phpComment,phpStringDouble,phpStringSingle,phpIdentifier,phpMethodsVar
                              \ __autoload
    3              0.000027 hi def link phpSpecialFunction phpOperator
                            
                            " Highlighting for PHP5's built-in classes
                            " - built-in classes harvested from get_declared_classes() in 5.1.4
    3              0.000351 syntax keyword phpClasses containedin=ALLBUT,phpComment,phpStringDouble,phpStringSingle,phpIdentifier,phpMethodsVar
                              \ stdClass __PHP_Incomplete_Class php_user_filter Directory ArrayObject
                              \ Exception ErrorException LogicException BadFunctionCallException BadMethodCallException DomainException
                              \ RecursiveIteratorIterator IteratorIterator FilterIterator RecursiveFilterIterator ParentIterator LimitIterator
                              \ CachingIterator RecursiveCachingIterator NoRewindIterator AppendIterator InfiniteIterator EmptyIterator
                              \ ArrayIterator RecursiveArrayIterator DirectoryIterator RecursiveDirectoryIterator
                              \ InvalidArgumentException LengthException OutOfRangeException RuntimeException OutOfBoundsException
                              \ OverflowException RangeException UnderflowException UnexpectedValueException
                              \ PDO PDOException PDOStatement PDORow
                              \ Reflection ReflectionFunction ReflectionParameter ReflectionMethod ReflectionClass
                              \ ReflectionObject ReflectionProperty ReflectionExtension ReflectionException
                              \ SplFileInfo SplFileObject SplTempFileObject SplObjectStorage
                              \ XMLWriter LibXMLError XMLReader SimpleXMLElement SimpleXMLIterator
                              \ DOMException DOMStringList DOMNameList DOMDomError DOMErrorHandler
                              \ DOMImplementation DOMImplementationList DOMImplementationSource
                              \ DOMNode DOMNameSpaceNode DOMDocumentFragment DOMDocument DOMNodeList DOMNamedNodeMap
                              \ DOMCharacterData DOMAttr DOMElement DOMText DOMComment DOMTypeinfo DOMUserDataHandler
                              \ DOMLocator DOMConfiguration DOMCdataSection DOMDocumentType DOMNotation DOMEntity
                              \ DOMEntityReference DOMProcessingInstruction DOMStringExtend DOMXPath
    3              0.000060 hi def link phpClasses phpFunctions
                            
                            " Highlighting for PHP5's built-in interfaces
                            " - built-in classes harvested from get_declared_interfaces() in 5.1.4
    3              0.000146 syntax keyword phpInterfaces containedin=ALLBUT,phpComment,phpStringDouble,phpStringSingle,phpIdentifier,phpMethodsVar
                              \ Iterator IteratorAggregate RecursiveIterator OuterIterator SeekableIterator
                              \ Traversable ArrayAccess Serializable Countable SplObserver SplSubject Reflector
    3              0.000024 hi def link phpInterfaces phpConstant
                            
                            " option defaults:
    3              0.000015 if ! exists('php_special_functions')
                              let php_special_functions = 1
                            endif
    3              0.000009 if ! exists('php_alt_comparisons')
                              let php_alt_comparisons = 1
                            endif
    3              0.000008 if ! exists('php_alt_assignByReference')
                              let php_alt_assignByReference = 1
                            endif
                            
    3              0.000005 if php_special_functions
                              " Highlighting for PHP built-in functions which exhibit special behaviours
                              " - isset()/unset()/empty() are not real functions.
                              " - compact()/extract() directly manipulate variables in the local scope where
                              "   regular functions would not be able to.
                              " - eval() is the token 'make_your_code_twice_as_complex()' function for PHP.
                              " - user_error()/trigger_error() can be overloaded by set_error_handler and also
                              "   have the capacity to terminate your script when type is E_USER_ERROR.
    3              0.000100   syntax keyword phpSpecialFunction containedin=ALLBUT,phpComment,phpStringDouble,phpStringSingle
                              \ user_error trigger_error isset unset eval extract compact empty
    3              0.000003 endif
                            
    3              0.000004 if php_alt_assignByReference
                              " special highlighting for '=&' operator
    3              0.000094   syntax match phpAssignByRef /=\s*&/ containedin=ALLBUT,phpComment,phpStringDouble,phpStringSingle
    3              0.000039     hi def link phpAssignByRef Type
    3              0.000003 endif
                            
    3              0.000003 if php_alt_comparisons
                              " highlight comparison operators differently
    3              0.000055   syntax match phpComparison "\v[=!]\=\=?" contained containedin=phpRegion
    3              0.000048   syntax match phpComparison "\v[=<>-]@<![<>]\=?[<>]@!" contained containedin=phpRegion
                            
                              " highlight the 'instanceof' operator as a comparison operator rather than a structure
    3              0.000004   syntax case ignore
    3              0.000038   syntax keyword phpComparison instanceof contained containedin=phpRegion
                            
    3              0.000035   hi def link phpComparison Statement
    3              0.000003 endif
                            
                            " ================================================================
                            
                            " Sync
    3              0.000006 if php_sync_method==-1
                              if exists("php_noShortTags")
                                syn sync match phpRegionSync grouphere phpRegion "^\s*<?php\s*$"
                              else
                                syn sync match phpRegionSync grouphere phpRegion "^\s*<?\(php\)\=\s*$"
                              endif
                              syn sync match phpRegionSync grouphere phpRegionSc +^\s*<script language="php">\s*$+
                              if exists("php_asp_tags")
                                syn sync match phpRegionSync grouphere phpRegionAsp "^\s*<%\(=\)\=\s*$"
                              endif
                              syn sync match phpRegionSync grouphere NONE "^\s*?>\s*$"
                              syn sync match phpRegionSync grouphere NONE "^\s*%>\s*$"
                              syn sync match phpRegionSync grouphere phpRegion "function\s.*(.*\$"
                              "syn sync match phpRegionSync grouphere NONE "/\i*>\s*$"
                            elseif php_sync_method>0
                              exec "syn sync minlines=" . php_sync_method
                            else
    3              0.000018   exec "syn sync fromstart"
    3              0.000004 endif
                            
    3              0.000051 syntax match phpDocCustomTags "@[a-zA-Z]*\(\s\+\|\n\|\r\)" containedin=phpComment
    3              0.000070 syntax region phpDocTags start="{@\(example\|id\|internal\|inheritdoc\|link\|source\|toc\|tutorial\)" end="}" containedin=phpComment
    3              0.000121 syntax match phpDocTags "@\(abstract\|access\|author\|category\|copyright\|deprecated\|example\|final\|global\|ignore\|internal\|license\|link\|method\|name\|package\|param\|property\|return\|see\|since\|static\|staticvar\|subpackage\|tutorial\|uses\|var\|version\|contributor\|modified\|filename\|description\|filesource\|throws\)\(\s\+\)\?" containedin=phpComment
    3              0.000043 syntax match phpDocTodo "@\(todo\|fixme\|xxx\)\(\s\+\)\?" containedin=phpComment
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    3              0.000040 hi def link phpConstant Constant
    3              0.000037 hi def link phpCoreConstant Constant
    3              0.000032 hi def link phpComment Comment
    3              0.000031 hi def link phpDocTags PreProc
    3              0.000033 hi def link phpDocCustomTags Type
    3              0.000032 hi def link phpException Exception
    3              0.000031 hi def link phpBoolean Boolean
    3              0.000032 hi def link phpStorageClass StorageClass
    3              0.000031 hi def link phpSCKeyword StorageClass
    3              0.000031 hi def link phpFCKeyword Define
    3              0.000031 hi def link phpStructure Structure
    3              0.000031 hi def link phpStringSingle String
    3              0.000036 hi def link phpStringDouble String
    3              0.000035 hi def link phpBacktick String
    3              0.000031 hi def link phpNumber Number
    3              0.000058 hi def link phpFloat Float
    3              0.000044 hi def link phpMethods Function
    3              0.000032 hi def link phpFunctions Function
    3              0.000032 hi def link phpBaselib Function
    3              0.000031 hi def link phpRepeat Repeat
    3              0.000031 hi def link phpConditional Conditional
    3              0.000032 hi def link phpLabel Label
    3              0.000032 hi def link phpStatement Statement
    3              0.000031 hi def link phpKeyword Statement
    3              0.000031 hi def link phpType Type
    3              0.000030 hi def link phpInclude Include
    3              0.000030 hi def link phpDefine Define
    3              0.000032 hi def link phpBackslashSequences SpecialChar
    3              0.000032 hi def link phpBackslashDoubleQuote SpecialChar
    3              0.000031 hi def link phpBackslashSingleQuote SpecialChar
    3              0.000031 hi def link phpParent Delimiter
    3              0.000032 hi def link phpBrackets Delimiter
    3              0.000031 hi def link phpIdentifierConst Delimiter
    3              0.000030 hi def link phpParentError Error
    3              0.000058 hi def link phpOctalError Error
    3              0.000039 hi def link phpInterpSimpleError Error
    3              0.000033 hi def link phpInterpBogusDollarCurley Error
    3              0.000032 hi def link phpInterpDollarCurly1 Error
    3              0.000032 hi def link phpInterpDollarCurly2 Error
    3              0.000033 hi def link phpInterpSimpleBracketsInner String
    3              0.000032 hi def link phpInterpSimpleCurly Delimiter
    3              0.000032 hi def link phpInterpVarname Identifier
    3              0.000030 hi def link phpTodo Todo
    3              0.000031 hi def link phpDocTodo Todo
    3              0.000031 hi def link phpMemberSelector Structure
    3              0.000013 if exists("php_oldStyle")
                              hi def phpIntVar guifg=Red ctermfg=DarkRed
                              hi def phpEnvVar guifg=Red ctermfg=DarkRed
                              hi def phpOperator guifg=SeaGreen ctermfg=DarkGreen
                              hi def phpVarSelector guifg=SeaGreen ctermfg=DarkGreen
                              hi def phpRelation guifg=SeaGreen ctermfg=DarkGreen
                              hi def phpIdentifier guifg=DarkGray ctermfg=Brown
                              hi def phpIdentifierSimply guifg=DarkGray ctermfg=Brown
                            else
    3              0.000034   hi def link phpIntVar Identifier
    3              0.000033   hi def link phpEnvVar Identifier
    3              0.000032   hi def link phpOperator Operator
    3              0.000032   hi def link phpVarSelector Operator
    3              0.000032   hi def link phpRelation Operator
    3              0.000030   hi def link phpIdentifier Identifier
    3              0.000033   hi def link phpIdentifierSimply Identifier
    3              0.000002 endif
                            
                            
    3              0.000010 let b:current_syntax = "php"
                            
    3              0.000008 if main_syntax == 'php'
    3              0.000007   unlet main_syntax
    3              0.000003 endif
                            
                            " put cpoptions back the way we found it
    3              0.000041 let &cpo = s:cpo_save
    3              0.000005 unlet s:cpo_save
                            
                            " vim: ts=8 sts=2 sw=2 expandtab

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/syntax/html.vim
Sourced 3 times
Total time:   0.095973
 Self time:   0.026026

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:             HTML
                            " Maintainer:           Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            " Previous Maintainer:  Claudio Fleiner <claudio@fleiner.com>
                            " Repository:           https://notabug.org/jorgesumle/vim-html-syntax
                            " Last Change:          2017 Dec 16
                            " Included patch from Jorge Maldonado Ventura to add the dialog element
                            "
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    3              0.000026 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'html'
                            endif
                            
    3              0.000030 let s:cpo_save = &cpo
    3              0.000035 set cpo&vim
                            
    3              0.000007 syntax spell toplevel
                            
    3              0.000003 syn case ignore
                            
                            " mark illegal characters
    3              0.000124 syn match htmlError "[<>&]"
                            
                            
                            " tags
    3              0.000239 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    3              0.000173 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    3              0.000194 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    3              0.000170 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    3              0.000325 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    3              0.000153 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    3              0.000132 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    3              0.000035 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    3              0.000045 syn keyword htmlTagName contained address applet area a base basefont
    3              0.000039 syn keyword htmlTagName contained big blockquote br caption center
    3              0.000052 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    3              0.000036 syn keyword htmlTagName contained form hr html img
    3              0.000044 syn keyword htmlTagName contained input isindex kbd li link map menu
    3              0.000071 syn keyword htmlTagName contained meta ol option param pre p samp span
    3              0.000061 syn keyword htmlTagName contained select small sub sup
    3              0.000070 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    3              0.000062 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    3              0.000084 syn keyword htmlTagName contained abbr acronym bdo button col label
    3              0.000045 syn keyword htmlTagName contained colgroup fieldset iframe ins legend
    3              0.000038 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    3              0.000054 syn keyword htmlTagName contained article aside audio bdi canvas data
    3              0.000042 syn keyword htmlTagName contained datalist details embed figcaption figure
    3              0.000038 syn keyword htmlTagName contained footer header hgroup keygen main mark
    3              0.000036 syn keyword htmlTagName contained menuitem meter nav output picture
    3              0.000040 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    3              0.000039 syn keyword htmlTagName contained slot source template time track video wbr
                            
                            " legal arg names
    3              0.000026 syn keyword htmlArg contained action
    3              0.000033 syn keyword htmlArg contained align alink alt archive background bgcolor
    3              0.000032 syn keyword htmlArg contained border bordercolor cellpadding
    3              0.000080 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    3              0.000039 syn keyword htmlArg contained cols colspan content coords enctype face
    3              0.000032 syn keyword htmlArg contained gutter height hspace id
    3              0.000038 syn keyword htmlArg contained link lowsrc marginheight
    3              0.000041 syn keyword htmlArg contained marginwidth maxlength method name prompt
    3              0.000074 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    3              0.000052 syn keyword htmlArg contained size src start target text type url
    3              0.000051 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    3              0.000052 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " Netscape extensions
    3              0.000038 syn keyword htmlTagName contained frame noframes frameset nobr blink
    3              0.000039 syn keyword htmlTagName contained layer ilayer nolayer spacer
    3              0.000104 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    3              0.000632 syn keyword htmlArg     contained left top visibility clip id noshade
    3              0.000053 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    3              0.000037 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    3              0.000047 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    3              0.000081 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    3              0.000068 syn keyword htmlArg contained cite classid codetype compact data datetime
    3              0.000069 syn keyword htmlArg contained declare defer dir disabled for frame
    3              0.000107 syn keyword htmlArg contained headers hreflang lang language longdesc
    3              0.000056 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    3              0.000039 syn keyword htmlArg contained rules scheme scope span standby style
    3              0.000046 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    3              0.000041 syn keyword htmlArg contained allowfullscreen async autocomplete autofocus
    3              0.000038 syn keyword htmlArg contained autoplay challenge contenteditable contextmenu
    3              0.000035 syn keyword htmlArg contained controls crossorigin default dialog dirname
    3              0.000034 syn keyword htmlArg contained download draggable dropzone form formaction
    3              0.000032 syn keyword htmlArg contained formenctype formmethod formnovalidate formtarget
    3              0.000035 syn keyword htmlArg contained hidden high icon inputmode keytype kind list loop
    3              0.000043 syn keyword htmlArg contained low max min minlength muted nonce novalidate open
    3              0.000035 syn keyword htmlArg contained optimum pattern placeholder poster preload
    3              0.000043 syn keyword htmlArg contained radiogroup required reversed sandbox spellcheck
    3              0.000042 syn keyword htmlArg contained sizes srcset srcdoc srclang step title translate
    3              0.000027 syn keyword htmlArg contained typemustmatch
                            
                            " special characters
    3              0.000054 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    3              0.000018 if exists("html_wrong_comments")
                              syn region htmlComment                start=+<!--+    end=+--\s*>+ contains=@Spell
                            else
    3              0.000107   syn region htmlComment                start=+<!+      end=+>+   contains=htmlCommentPart,htmlCommentError,@Spell
    3              0.000031   syn match  htmlCommentError contained "[^><!]"
    3              0.000045   syn region htmlCommentPart  contained start=+--+      end=+--\s*+  contains=@htmlPreProc,@Spell
    3              0.000004 endif
    3              0.000042 syn region htmlComment                  start=+<!DOCTYPE+ keepend end=+>+
                            
                            " server-parsed commands
    3              0.000124 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    3              0.000047 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    3              0.000032 syn match htmlPreError contained "<!--#\S*"ms=s+4
    3              0.000103 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    3              0.000084 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    3              0.000030 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    3              0.000042 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    3              0.000011 if !exists("html_no_rendering")
                              " rendering
    3              0.000234   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    3              0.000041   syn region htmlStrike start="<del\>" end="</del>"me=e-6 contains=@htmlTop
    3              0.000046   syn region htmlStrike start="<strike\>" end="</strike>"me=e-9 contains=@htmlTop
                            
    3              0.000129   syn region htmlBold start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    3              0.000099   syn region htmlBold start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    3              0.000069   syn region htmlBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
    3              0.000061   syn region htmlBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlBoldItalicUnderline
    3              0.000068   syn region htmlBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlBoldItalicUnderline
    3              0.000042   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    3              0.000035   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    3              0.000068   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    3              0.000111   syn region htmlUnderline start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    3              0.000065   syn region htmlUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlUnderlineBoldItalic
    3              0.000090   syn region htmlUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlUnderlineBoldItalic
    3              0.000070   syn region htmlUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlUnderlineItalicBold
    3              0.000066   syn region htmlUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlUnderlineItalicBold
    3              0.000032   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    3              0.000044   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
    3              0.000040   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    3              0.000043   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
                            
    3              0.000091   syn region htmlItalic start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    3              0.000039   syn region htmlItalic start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    3              0.000074   syn region htmlItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlItalicBoldUnderline
    3              0.000074   syn region htmlItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlItalicBoldUnderline
    3              0.000042   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop
    3              0.000110   syn region htmlItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlItalicUnderlineBold
    3              0.000057   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    3              0.000055   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
                            
    3              0.000036   syn match htmlLeadingSpace "^\s\+" contained
    3              0.000267   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a>"me=e-4 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    3              0.000048   syn region htmlH1 start="<h1\>" end="</h1>"me=e-5 contains=@htmlTop
    3              0.000040   syn region htmlH2 start="<h2\>" end="</h2>"me=e-5 contains=@htmlTop
    3              0.000032   syn region htmlH3 start="<h3\>" end="</h3>"me=e-5 contains=@htmlTop
    3              0.000055   syn region htmlH4 start="<h4\>" end="</h4>"me=e-5 contains=@htmlTop
    3              0.000033   syn region htmlH5 start="<h5\>" end="</h5>"me=e-5 contains=@htmlTop
    3              0.000038   syn region htmlH6 start="<h6\>" end="</h6>"me=e-5 contains=@htmlTop
    3              0.000338   syn region htmlHead start="<head\>" end="</head>"me=e-7 end="<body\>"me=e-5 end="<h[1-6]\>"me=e-3 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    3              0.000279   syn region htmlTitle start="<title\>" end="</title>"me=e-8 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    3              0.000007 endif
                            
    3              0.000027 syn keyword htmlTagName         contained noscript
    3              0.000027 syn keyword htmlSpecialTagName  contained script style
    3              0.000014 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    3   0.005757   0.001221   syn include @htmlJavaScript syntax/javascript.vim
    3              0.000013   unlet b:current_syntax
    3              0.000157   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    3              0.000226   syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    3              0.000038   hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    3              0.000016   if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
                              else
    3              0.000059     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    3              0.000070     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    3              0.000003   endif
    3              0.000054   syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    3              0.000041   syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    3              0.000073   hi def link htmlEventSQ htmlEvent
    3              0.000031   hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    3              0.000093   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    3              0.000007 endif
                            
    3              0.000016 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    3   0.017290   0.001663   syn include @htmlVbScript syntax/vb.vim
    3              0.000014   unlet b:current_syntax
    3              0.000161   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    3              0.000006 endif
                            
    3              0.000014 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    3              0.000019 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    3              0.000033   syn keyword htmlArg           contained media
    3   0.050975   0.001191   syn include @htmlCss syntax/css.vim
    3              0.000013   unlet b:current_syntax
    3              0.000229   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    3              0.000038   syn match htmlCssStyleComment contained "\(<!--\|-->\)"
    3              0.007943   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    3              0.000058   hi def link htmlStyleArg htmlString
    3              0.000007 endif
                            
    3              0.000017 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
                              syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
                              syn sync match htmlHighlight groupthere javaScript "<script"
                              syn sync match htmlHighlightSkip "^.*['\"].*$"
                              syn sync minlines=10
                            endif
                            
                            " The default highlighting.
    3              0.000069 hi def link htmlTag                     Function
    3              0.000059 hi def link htmlEndTag                  Identifier
    3              0.000057 hi def link htmlArg                     Type
    3              0.000044 hi def link htmlTagName                 htmlStatement
    3              0.000051 hi def link htmlSpecialTagName          Exception
    3              0.000049 hi def link htmlValue                     String
    3              0.000050 hi def link htmlSpecialChar             Special
                            
    3              0.000018 if !exists("html_no_rendering")
    3              0.000055   hi def link htmlH1                      Title
    3              0.000043   hi def link htmlH2                      htmlH1
    3              0.000037   hi def link htmlH3                      htmlH2
    3              0.000037   hi def link htmlH4                      htmlH3
    3              0.000038   hi def link htmlH5                      htmlH4
    3              0.000039   hi def link htmlH6                      htmlH5
    3              0.000043   hi def link htmlHead                    PreProc
    3              0.000049   hi def link htmlTitle                   Title
    3              0.000048   hi def link htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    3              0.000045   hi def link htmlUnderlineBold           htmlBoldUnderline
    3              0.000039   hi def link htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    3              0.000039   hi def link htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    3              0.000039   hi def link htmlItalicUnderline         htmlUnderlineItalic
    3              0.000041   hi def link htmlItalicBold              htmlBoldItalic
    3              0.000039   hi def link htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    3              0.000038   hi def link htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    3              0.000054   hi def link htmlLink                    Underlined
    3              0.000038   hi def link htmlLeadingSpace            None
    3              0.000016   if !exists("html_my_rendering")
    3              0.000023     hi def htmlBold                term=bold cterm=bold gui=bold
    3              0.000023     hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    3              0.000021     hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    3              0.000023     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    3              0.000023     hi def htmlUnderline           term=underline cterm=underline gui=underline
    3              0.000022     hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    3              0.000020     hi def htmlItalic              term=italic cterm=italic gui=italic
    3              0.000015     if v:version > 800 || v:version == 800 && has("patch1038")
    3              0.000024         hi def htmlStrike              term=strikethrough cterm=strikethrough gui=strikethrough
    3              0.000004     else
                                    hi def htmlStrike              term=underline cterm=underline gui=underline
                                endif
    3              0.000002   endif
    3              0.000002 endif
                            
    3              0.000047 hi def link htmlPreStmt            PreProc
    3              0.000045 hi def link htmlPreError           Error
    3              0.000046 hi def link htmlPreProc            PreProc
    3              0.000079 hi def link htmlPreAttr            String
    3              0.000048 hi def link htmlPreProcAttrName    PreProc
    3              0.000045 hi def link htmlPreProcAttrError   Error
    3              0.000041 hi def link htmlSpecial            Special
    3              0.000048 hi def link htmlSpecialChar        Special
    3              0.000044 hi def link htmlString             String
    3              0.000041 hi def link htmlStatement          Statement
    3              0.000045 hi def link htmlComment            Comment
    3              0.000045 hi def link htmlCommentPart        Comment
    3              0.000045 hi def link htmlValue              String
    3              0.000041 hi def link htmlCommentError       htmlError
    3              0.000039 hi def link htmlTagError           htmlError
    3              0.000040 hi def link htmlEvent              javaScript
    3              0.000044 hi def link htmlError              Error
                            
    3              0.000053 hi def link javaScript             Special
    3              0.000047 hi def link javaScriptExpression   javaScript
    3              0.000045 hi def link htmlCssStyleComment    Comment
    3              0.000044 hi def link htmlCssDefinition      Special
                            
    3              0.000013 let b:current_syntax = "html"
                            
    3              0.000009 if main_syntax == 'html'
                              unlet main_syntax
                            endif
                            
    3              0.000042 let &cpo = s:cpo_save
    3              0.000008 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/syntax/javascript.vim
Sourced 3 times
Total time:   0.004482
 Self time:   0.004482

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2012 Oct 05
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    3              0.000034 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
                            elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
                            endif
                            
    3              0.000033 let s:cpo_save = &cpo
    3              0.000032 set cpo&vim
                            
                            
    3              0.000113 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    3              0.000094 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    3              0.000048 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    3              0.000079 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    3              0.000030 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    3              0.000084 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    3              0.000096 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
                            
    3              0.000033 syn match   javaScriptSpecialCharacter "'\\.'"
    3              0.000051 syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
    3              0.000091 syn region  javaScriptRegexpString     start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[;.,)\]}]+me=e-1 contains=@htmlPreproc oneline
                            
    3              0.000027 syn keyword javaScriptConditional	if else switch
    3              0.000031 syn keyword javaScriptRepeat		while for do in
    3              0.000028 syn keyword javaScriptBranch		break continue
    3              0.000034 syn keyword javaScriptOperator		new delete instanceof typeof
    3              0.000041 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    3              0.000023 syn keyword javaScriptStatement		return with
    3              0.000022 syn keyword javaScriptBoolean		true false
    3              0.000025 syn keyword javaScriptNull		null undefined
    3              0.000033 syn keyword javaScriptIdentifier	arguments this var let
    3              0.000026 syn keyword javaScriptLabel		case default
    3              0.000027 syn keyword javaScriptException		try catch finally throw
    3              0.000025 syn keyword javaScriptMessage		alert confirm prompt status
    3              0.000027 syn keyword javaScriptGlobal		self window top parent
    3              0.000026 syn keyword javaScriptMember		document event location 
    3              0.000025 syn keyword javaScriptDeprecated	escape unescape
    3              0.000071 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 
                            
    3              0.000014 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
    3              0.000028     syn keyword javaScriptFunction	function
    3              0.000029     syn match	javaScriptBraces	   "[{}\[\]]"
    3              0.000056     syn match	javaScriptParens	   "[()]"
    3              0.000004 endif
                            
    3              0.000006 syn sync fromstart
    3              0.000005 syn sync maxlines=100
                            
    3              0.000009 if main_syntax == "javascript"
                              syn sync ccomment javaScriptComment
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
    3              0.000043 hi def link javaScriptComment		Comment
    3              0.000039 hi def link javaScriptLineComment		Comment
    3              0.000038 hi def link javaScriptCommentTodo		Todo
    3              0.000036 hi def link javaScriptSpecial		Special
    3              0.000085 hi def link javaScriptStringS		String
    3              0.000044 hi def link javaScriptStringD		String
    3              0.000036 hi def link javaScriptCharacter		Character
    3              0.000033 hi def link javaScriptSpecialCharacter	javaScriptSpecial
    3              0.000029 hi def link javaScriptNumber		javaScriptValue
    3              0.000717 hi def link javaScriptConditional		Conditional
    3              0.000041 hi def link javaScriptRepeat		Repeat
    3              0.000037 hi def link javaScriptBranch		Conditional
    3              0.000035 hi def link javaScriptOperator		Operator
    3              0.000036 hi def link javaScriptType			Type
    3              0.000036 hi def link javaScriptStatement		Statement
    3              0.000034 hi def link javaScriptFunction		Function
    3              0.000034 hi def link javaScriptBraces		Function
    3              0.000041 hi def link javaScriptError		Error
    3              0.000030 hi def link javaScrParenError		javaScriptError
    3              0.000035 hi def link javaScriptNull			Keyword
    3              0.000036 hi def link javaScriptBoolean		Boolean
    3              0.000035 hi def link javaScriptRegexpString		String
                            
    3              0.000037 hi def link javaScriptIdentifier		Identifier
    3              0.000034 hi def link javaScriptLabel		Label
    3              0.000034 hi def link javaScriptException		Exception
    3              0.000035 hi def link javaScriptMessage		Keyword
    3              0.000034 hi def link javaScriptGlobal		Keyword
    3              0.000035 hi def link javaScriptMember		Keyword
    3              0.000034 hi def link javaScriptDeprecated		Exception 
    3              0.000035 hi def link javaScriptReserved		Keyword
    3              0.000033 hi def link javaScriptDebug		Debug
    3              0.000045 hi def link javaScriptConstant		Label
                            
                            
    3              0.000016 let b:current_syntax = "javascript"
    3              0.000010 if main_syntax == 'javascript'
                              unlet main_syntax
                            endif
    3              0.000037 let &cpo = s:cpo_save
    3              0.000006 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/syntax/vb.vim
Sourced 3 times
Total time:   0.015569
 Self time:   0.015569

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Visual Basic
                            " Maintainer:	Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:	Robert M. Cortopassi <cortopar@mindspring.com>
                            "	(tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    3              0.000034 if exists("b:current_syntax")
                            	finish
                            endif
                            
                            " VB is case insensitive
    3              0.000008 syn case ignore
                            
    3              0.000100 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    3              0.000036 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    3              0.000032 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    3              0.000046 syn match vbOperator "[()+.,\-/*=&]"
    3              0.000041 syn match vbOperator "[<>]=\="
    3              0.000034 syn match vbOperator "<>"
    3              0.000026 syn match vbOperator "\s\+_$"
                            
    3              0.000027 syn keyword vbBoolean  True False
    3              0.000031 syn keyword vbConst Null Nothing
                            
    3              0.000037 syn keyword vbRepeat Do For ForEach Loop Next
    3              0.000036 syn keyword vbRepeat Step To Until Wend While
                            
    3              0.000031 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    3              0.000026 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    3              0.000027 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    3              0.000029 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    3              0.000025 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    3              0.000022 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    3              0.000026 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    3              0.000024 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    3              0.000026 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    3              0.000031 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    3              0.000028 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    3              0.000028 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    3              0.000028 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    3              0.000030 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    3              0.000025 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    3              0.000033 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    3              0.000026 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    3              0.000031 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    3              0.000029 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    3              0.000024 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    3              0.000028 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    3              0.000025 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    3              0.000025 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    3              0.000026 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    3              0.000026 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    3              0.000028 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    3              0.000028 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    3              0.000024 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    3              0.000028 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    3              0.000025 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    3              0.000028 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    3              0.000031 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    3              0.000038 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    3              0.000030 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    3              0.000027 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    3              0.000026 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    3              0.000064 syn keyword vbEvents IniProperties InitProperties Initialize
    3              0.000042 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    3              0.000024 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    3              0.000032 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    3              0.000028 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    3              0.000022 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    3              0.000030 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    3              0.000032 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    3              0.000029 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    3              0.000829 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    3              0.000034 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    3              0.000033 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    3              0.000030 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    3              0.000027 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    3              0.000023 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    3              0.000028 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    3              0.000026 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    3              0.000023 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    3              0.000024 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    3              0.000021 syn keyword vbEvents RepeatedControlUnloaded Reposition
    3              0.000028 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    3              0.000025 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    3              0.000027 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    3              0.000033 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    3              0.000027 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    3              0.000029 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    3              0.000026 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    3              0.000030 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    3              0.000029 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    3              0.000025 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    3              0.000026 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    3              0.000026 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    3              0.000022 syn keyword vbEvents UserEvent Validate ValidationError
    3              0.000023 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    3              0.000022 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    3              0.000020 syn keyword vbEvents WriteProperties
                            
                            
    3              0.000033 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    3              0.000035 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    3              0.000042 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    3              0.000033 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    3              0.000032 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    3              0.000031 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    3              0.000036 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    3              0.000026 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    3              0.000026 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    3              0.000057 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    3              0.000050 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    3              0.000031 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    3              0.000026 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    3              0.000300 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    3              0.000196 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    3              0.000193 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    3              0.000262 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    3              0.000237 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    3              0.000470 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    3              0.000246 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    3              0.000152 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    3              0.000170 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    3              0.000242 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    3              0.000073 syn keyword vbFunction Year
                            
    3              0.000159 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    3              0.000126 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    3              0.000157 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    3              0.000125 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    3              0.000199 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    3              0.000125 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    3              0.000115 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    3              0.000141 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    3              0.000146 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    3              0.000142 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    3              0.000121 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    3              0.000282 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    3              0.000130 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    3              0.000112 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    3              0.000137 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    3              0.000104 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    3              0.000102 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    3              0.000103 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    3              0.000108 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    3              0.000109 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    3              0.000110 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    3              0.000057 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    3              0.000032 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    3              0.000027 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    3              0.000024 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    3              0.000024 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    3              0.000025 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    3              0.000023 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    3              0.000022 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    3              0.000023 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    3              0.000025 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    3              0.000023 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    3              0.000019 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    3              0.000025 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    3              0.000024 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    3              0.000024 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    3              0.000019 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    3              0.000021 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    3              0.000025 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    3              0.000028 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    3              0.000024 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    3              0.000024 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    3              0.000023 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    3              0.000020 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    3              0.000022 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    3              0.000021 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    3              0.000022 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    3              0.000020 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    3              0.000028 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    3              0.000024 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    3              0.000021 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    3              0.000023 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    3              0.000019 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    3              0.000023 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    3              0.000022 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    3              0.000020 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    3              0.000023 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    3              0.000022 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    3              0.000020 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    3              0.000022 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    3              0.000021 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    3              0.000021 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    3              0.000023 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    3              0.000023 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    3              0.000026 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    3              0.000024 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    3              0.000021 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    3              0.000023 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    3              0.000022 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    3              0.000028 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    3              0.000022 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    3              0.000021 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    3              0.000046 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    3              0.000022 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    3              0.000021 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    3              0.000020 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    3              0.000025 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    3              0.000028 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    3              0.000023 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    3              0.000023 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    3              0.000026 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    3              0.000025 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    3              0.000025 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    3              0.000027 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    3              0.000024 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    3              0.000022 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
    3              0.000023 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    3              0.000025 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    3              0.000025 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    3              0.000017 syn keyword vbStatement Write
                            
    3              0.000025 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    3              0.000027 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    3              0.000024 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    3              0.000020 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    3              0.000022 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    3              0.000023 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    3              0.000017 syn keyword vbTodo contained	TODO
                            
                            "Datatypes
    3              0.000029 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    3              0.000027 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    3              0.000023 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    3              0.000023 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    3              0.000023 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    3              0.000022 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    3              0.000019 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    3              0.000022 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    3              0.000021 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    3              0.000024 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    3              0.000021 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    3              0.000021 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    3              0.000021 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    3              0.000021 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    3              0.000022 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    3              0.000020 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    3              0.000022 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    3              0.000020 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    3              0.000021 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    3              0.000021 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    3              0.000019 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    3              0.000021 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    3              0.000027 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    3              0.000024 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    3              0.000019 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    3              0.000021 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    3              0.000019 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    3              0.000019 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    3              0.000019 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    3              0.000051 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    3              0.000029 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    3              0.000056 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    3              0.000025 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    3              0.000022 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    3              0.000028 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    3              0.000026 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    3              0.000050 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    3              0.000025 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    3              0.000026 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    3              0.000027 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    3              0.000027 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    3              0.000022 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    3              0.000022 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    3              0.000026 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    3              0.000023 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    3              0.000023 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    3              0.000021 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    3              0.000021 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    3              0.000019 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    3              0.000021 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    3              0.000025 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    3              0.000026 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    3              0.000033 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    3              0.000024 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    3              0.000023 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    3              0.000043 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    3              0.000033 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    3              0.000023 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    3              0.000021 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    3              0.000023 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    3              0.000022 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    3              0.000022 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    3              0.000021 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    3              0.000023 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    3              0.000022 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    3              0.000021 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    3              0.000025 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    3              0.000022 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    3              0.000023 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    3              0.000022 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    3              0.000020 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    3              0.000063 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    3              0.000027 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    3              0.000029 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber		"{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber		":[[:xdigit:]]\+"
                            "syn match  vbNumber		"[-+]\=\<\d\+\>"
    3              0.000040 syn match  vbFloat		"[-+]\=\<\d\+[eE][\-+]\=\d\+"
    3              0.000032 syn match  vbFloat		"[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    3              0.000061 syn match  vbFloat		"[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character contstants
    3              0.000048 syn region  vbString		start=+"+  end=+"\|$+
    3              0.000063 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    3              0.000066 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    3              0.000026 syn match   vbLineNumber	"^\d\+\(\s\|$\)"
    3              0.000435 syn match   vbTypeSpecifier  "[a-zA-Z0-9][\$%&!#]"ms=s+1
    3              0.000033 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    3              0.000088 hi def link vbBoolean		Boolean
    3              0.000053 hi def link vbLineNumber		Comment
    3              0.000041 hi def link vbComment		Comment
    3              0.000035 hi def link vbConditional	Conditional
    3              0.000033 hi def link vbConst			Constant
    3              0.000034 hi def link vbDefine			Constant
    3              0.000032 hi def link vbError			Error
    3              0.000034 hi def link vbFunction		Identifier
    3              0.000032 hi def link vbIdentifier		Identifier
    3              0.000034 hi def link vbNumber			Number
    3              0.000032 hi def link vbFloat			Float
    3              0.000033 hi def link vbMethods		PreProc
    3              0.000034 hi def link vbOperator		Operator
    3              0.000032 hi def link vbRepeat			Repeat
    3              0.000032 hi def link vbString			String
    3              0.000032 hi def link vbStatement		Statement
    3              0.000033 hi def link vbKeyword		Statement
    3              0.000033 hi def link vbEvents			Special
    3              0.000031 hi def link vbTodo			Todo
    3              0.000033 hi def link vbTypes			Type
    3              0.000033 hi def link vbTypeSpecifier	Type
                            
                            
    3              0.000017 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/syntax/css.vim
Sourced 3 times
Total time:   0.049733
 Self time:   0.049733

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/JulesWang/css.vim
                            " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
                            " Last Change:  2018 Feb. 27
                            "               cssClassName updated by Ryuichi Hayashida Jan 2016
                            
                            " quit when a syntax file was already loaded
    3              0.000021 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
                            elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
                            endif
                            
    3              0.000028 let s:cpo_save = &cpo
    3              0.000032 set cpo&vim
                            
    3              0.000005 syn case ignore
                            
                            " HTML4 tags
    3              0.000041 syn keyword cssTagName abbr address area a b base
    3              0.000026 syn keyword cssTagName bdo blockquote body br button
    3              0.000031 syn keyword cssTagName caption cite code col colgroup dd del
    3              0.000026 syn keyword cssTagName dfn div dl dt em fieldset form
    3              0.000026 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    3              0.000026 syn keyword cssTagName iframe input ins isindex kbd label legend li
    3              0.000031 syn keyword cssTagName link map menu meta noscript ol optgroup
    3              0.000030 syn keyword cssTagName option p param pre q s samp script small
    3              0.000025 syn keyword cssTagName span strong sub sup tbody td
    3              0.000031 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    3              0.000020 syn keyword cssTagName object svg
    3              0.000045 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    3              0.000026 syn keyword cssTagName article aside audio bdi canvas command data
    3              0.000027 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    3              0.000030 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    3              0.000030 syn keyword cssTagName output progress rt rp ruby section
    3              0.000028 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    3              0.000027 syn match cssTagName "\*"
                            
                            " selectors
    3              0.000024 syn match cssSelectorOp "[,>+~]"
    3              0.000033 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    3              0.000150 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    3              0.000062 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    3              0.000026 syn match cssClassNameDot contained '\.'
                            
    3              0.000003 try
    3              0.000030 syn match cssIdentifier "#[A-Za-z-_@][A-Za-z-0-9_@-]*"
    3              0.000006 catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
                            endtry
                            
                            " digits
    3              0.000051 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    3              0.000059 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    3              0.000066 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\)\>" contains=cssUnitDecorators
    3              0.000049 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    3              0.000059 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    3              0.000050 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    3              0.000049 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    3              0.000041 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    3              0.000023 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    3              0.000023 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    3              0.000026 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    3              0.000049 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    3              0.000055 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    3              0.000041 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    3              0.000038 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    3              0.000026 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    3              0.000623 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    3              0.000029 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    3              0.000024 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    3              0.000020 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    3              0.000040 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    3              0.000030 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    3              0.000034 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    3              0.000080 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    3              0.000041 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    3              0.000024 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    3              0.000022 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    3              0.000037 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    3              0.000025 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    3              0.000023 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    3              0.000023 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    3              0.000023 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    3              0.000023 syn keyword cssColor contained thistle tomato turquoise violet wheat
    3              0.000019 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    3              0.000007 syn case match
    3              0.000042 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    3              0.000003 syn case ignore
                            
    3              0.000025 syn match cssImportant contained "!\s*important\>"
                            
    3              0.000027 syn match cssColor contained "\<transparent\>"
    3              0.000029 syn match cssColor contained "\<currentColor\>"
    3              0.000024 syn match cssColor contained "\<white\>"
    3              0.000055 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    3              0.000050 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    3              0.000047 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    3              0.000105 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    3              0.000169 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    3              0.000205 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    3              0.000231 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    3              0.000196 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    3              0.000029 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    3              0.000048 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    3              0.000025 syn keyword cssCommonAttr contained auto none inherit all default normal
    3              0.000022 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    3              0.000045 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    3              0.000033 syn keyword cssAnimationAttr contained alternate reverse
    3              0.000033 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    3              0.000021 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    3              0.000017 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    3              0.000017 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    3              0.000034 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    3              0.000019 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    3              0.000020 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    3              0.000023 syn match cssBackgroundAttr contained "\<no-repeat\>"
    3              0.000025 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    3              0.000018 syn keyword cssBackgroundAttr contained cover contain
                            
    3              0.000032 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    3              0.000047 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    3              0.000039 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    3              0.000030 syn match cssBorderProp contained "\<box-decoration-break\>"
    3              0.000023 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    3              0.000021 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    3              0.000025 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    3              0.000019 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    3              0.000018 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    3              0.000033 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    3              0.000033 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    3              0.000037 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    3              0.000022 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    3              0.000020 syn keyword cssBoxAttr contained visible hidden scroll auto
    3              0.000030 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    3              0.000017 syn keyword cssColorProp contained opacity
    3              0.000022 syn match cssColorProp contained "\<color-profile\>"
    3              0.000021 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    3              0.000027 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    3              0.000018 syn keyword cssDimensionProp contained height
    3              0.000016 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    3              0.000030 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    3              0.000076 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    3              0.000019 syn keyword cssFlexibleBoxProp contained order
                            
    3              0.000034 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    3              0.000022 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    3              0.000023 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    3              0.000029 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    3              0.000071 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    3              0.000022 syn keyword cssFontAttr contained icon menu caption
    3              0.000024 syn match cssFontAttr contained "\<message-box\>"
    3              0.000020 syn match cssFontAttr contained "\<status-bar\>"
    3              0.000017 syn keyword cssFontAttr contained larger smaller
    3              0.000033 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    3              0.000029 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    3              0.000110 syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
    3              0.000062 syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Verdana Webdings Wingdings York Zapf
    3              0.000022 syn keyword cssFontAttr contained cursive fantasy monospace
                            " font-feature-settings attributes
    3              0.000018 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    3              0.000039 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    3              0.000018 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    3              0.000017 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    3              0.000018 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    3              0.000022 syn match cssFontProp contained "\<font-smooth\>"
    3              0.000025 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    3              0.000025 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    3              0.000033 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    3              0.000029 syn keyword cssMultiColumnProp contained columns
    3              0.000024 syn keyword cssMultiColumnAttr contained balance medium
    3              0.000027 syn keyword cssMultiColumnAttr contained always left right page column
    3              0.000033 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    3              0.000035 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    3              0.000022 syn match cssInteractProp contained "\<pointer-events\>"
    3              0.000036 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    3              0.000019 syn keyword cssGeneratedContentProp contained quotes crop
    3              0.000023 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    3              0.000023 syn match cssGeneratedContentProp contained "\<move-to\>"
    3              0.000021 syn match cssGeneratedContentProp contained "\<page-policy\>"
    3              0.000024 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    3              0.000020 syn match cssGridProp contained "\<grid\>"
    3              0.000033 syn match cssGridProp contained "\<grid\(-\(template\|auto\)\)\=\(-\(columns\|rows\|areas\)\)\>"
    3              0.000031 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    3              0.000023 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    3              0.000021 syn match cssGridProp contained "\<grid-auto-flow\>"
                            
    3              0.000030 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    3              0.000026 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    3              0.000034 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    3              0.000027 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    3              0.000031 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    3              0.000024 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    3              0.000018 syn keyword cssListAttr contained inside outside
                            
    3              0.000047 syn keyword cssPositioningProp contained bottom clear clip display float left
    3              0.000026 syn keyword cssPositioningProp contained position right top visibility
    3              0.000025 syn match cssPositioningProp contained "\<z-index\>"
    3              0.000020 syn keyword cssPositioningAttr contained block compact grid
    3              0.000034 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    3              0.000018 syn keyword cssPositioningAttr contained left right both
    3              0.000021 syn match cssPositioningAttr contained "\<list-item\>"
    3              0.000027 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    3              0.000021 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid
                            
    3              0.000021 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    3              0.000032 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    3              0.000024 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    3              0.000043 syn keyword cssTextProp contained color direction
    3              0.000046 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    3              0.000041 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    3              0.000031 syn match cssTextProp contained "\<word-\(break\|\wrap\)\>"
    3              0.000026 syn match cssTextProp contained "\<white-space\>"
    3              0.000023 syn match cssTextProp contained "\<hanging-punctuation\>"
    3              0.000022 syn match cssTextProp contained "\<punctuation-trim\>"
    3              0.000021 syn match cssTextAttr contained "\<line-through\>"
    3              0.000022 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    3              0.000019 syn keyword cssTextAttr contained ltr rtl embed nowrap
    3              0.000022 syn keyword cssTextAttr contained underline overline blink sub super middle
    3              0.000018 syn keyword cssTextAttr contained capitalize uppercase lowercase
    3              0.000019 syn keyword cssTextAttr contained justify baseline sub super
    3              0.000019 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed
    3              0.000022 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    3              0.000025 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    3              0.000023 syn keyword cssTextAttr contained start end adjacent
    3              0.000025 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    3              0.000021 syn keyword cssTextAttr contained distribute kashida first last
    3              0.000019 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    3              0.000020 syn match cssTextAttr contained "\<break-all\>"
    3              0.000027 syn match cssTextAttr contained "\<break-word\>"
    3              0.000017 syn keyword cssTextAttr contained hyphenate
    3              0.000021 syn match cssTextAttr contained "\<bidi-override\>"
                            
    3              0.000025 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    3              0.000022 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    3              0.000022 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    3              0.000030 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    3              0.000024 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    3              0.000023 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    3              0.000022 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    3              0.000022 syn match cssUIProp contained "\<box-sizing\>"
    3              0.000025 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    3              0.000018 syn keyword cssUIProp contained cursor
    3              0.000028 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    3              0.000023 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    3              0.000019 syn keyword cssUIAttr contained progress wait text cell move
    3              0.000022 syn match cssUIAttr contained "\<context-menu\>"
    3              0.000019 syn match cssUIAttr contained "\<no-drop\>"
    3              0.000019 syn match cssUIAttr contained "\<not-allowed\>"
    3              0.000019 syn match cssUIAttr contained "\<all-scroll\>"
    3              0.000022 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    3              0.000025 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    3              0.000020 syn match cssUIProp contained "\<ime-mode\>"
    3              0.000019 syn keyword cssUIAttr contained active inactive disabled
                            
    3              0.000025 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    3              0.000025 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    3              0.000016 syn keyword cssUIAttr contained invert
                            
    3              0.000017 syn keyword cssUIProp contained icon resize
    3              0.000017 syn keyword cssUIAttr contained both horizontal vertical
                            
    3              0.000020 syn match cssUIProp contained "\<text-overflow\>"
    3              0.000017 syn keyword cssUIAttr contained clip ellipsis
                            
    3              0.000020 syn match cssUIProp contained "\<image-rendering\>"
    3              0.000016 syn keyword cssUIAttr contained pixellated
    3              0.000020 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    3              0.000049 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    3              0.000027 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    3              0.000046 syn match cssUIProp contained '\<tap-highlight-color\|user-select\|touch-callout\>'
                            " IE specific properties
    3              0.000025 syn match cssIEUIProp contained '\<interpolation-mode\|zoom\|filter\>'
                            
                            " Webkit/Firebox specific properties/attributes
    3              0.000038 syn keyword cssUIProp contained appearance
    3              0.000022 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    3              0.000026 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    3              0.000041 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    3              0.000023 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    3              0.000022 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    3              0.000016 syn keyword cssAuralAttr contained silent
    3              0.000024 syn match cssAuralAttr contained "\<spell-out\>"
    3              0.000018 syn keyword cssAuralAttr contained non mix
    3              0.000022 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    3              0.000026 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    3              0.000018 syn keyword cssAuralAttr contained leftwards rightwards behind
    3              0.000019 syn keyword cssAuralAttr contained below level above lower higher
    3              0.000023 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    3              0.000016 syn keyword cssAuralAttr contained faster slower
    3              0.000027 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    3              0.000028 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    3              0.000028 syn keyword cssMediaProp contained width height orientation scan grid
    3              0.000031 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
    3              0.000023 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
    3              0.000024 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
    3              0.000070 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
    3              0.000025 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    3              0.000048 syn match cssKeyFrameProp /\d*%\|from\|to/  contained nextgroup=cssDefinition
    3              0.000056 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    3              0.000019 syn keyword cssPageProp contained content size
    3              0.000016 syn keyword cssPageProp contained orphans widows
    3              0.000016 syn keyword cssFontDescriptorProp contained src
    3              0.000022 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    3              0.000027 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    3              0.000024 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    3              0.000019 syn match cssBraces contained "[{}]"
    3              0.000022 syn match cssError contained "{@<>"
    3              0.005710 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    3              0.000028 syn match cssBraceError "}"
    3              0.000024 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
    3              0.000138 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    3              0.000027 syn keyword cssPseudoClassId contained link visited active hover before after left right
    3              0.000024 syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
    3              0.000024 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    3              0.000025 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    3              0.000058 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")"
                            " ------------------------------------
                            " Vendor specific properties
    3              0.000021 syn match cssPseudoClassId contained  "\<selection\>"
    3              0.000021 syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
    3              0.000023 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    3              0.000040 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    3              0.000023 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    3              0.000043 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    3              0.000033 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    3              0.000021 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    3              0.000019 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    3              0.000118 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    3              0.000087 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    3              0.000030 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    3              0.000020 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
    3              0.007705 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    3              0.012221 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    3              0.000062 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/ contained
                            
    3              0.000033 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    3              0.000357 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment nextgroup=cssDefinition
    3              0.000057 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    3              0.000121 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    3              0.000043 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    3              0.000127 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    3              0.000338 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    3              0.000205 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    3              0.000194 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @font-face
                            " http://www.w3.org/TR/css3-fonts/#at-font-face-rule
    3              0.000062 syn match cssAtRule "@font-face\>" nextgroup=cssFontDescriptorBlock
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    3              0.006862 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    3              0.000023 if main_syntax == "css"
                              syn sync minlines=10
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    3              0.000062 hi def link cssComment Comment
    3              0.000046 hi def link cssVendor Comment
    3              0.000043 hi def link cssHacks Comment
    3              0.000045 hi def link cssTagName Statement
    3              0.000041 hi def link cssDeprecated Error
    3              0.000045 hi def link cssSelectorOp Special
    3              0.000039 hi def link cssSelectorOp2 Special
    3              0.000039 hi def link cssAttrComma Special
                            
    3              0.000033 hi def link cssAnimationProp cssProp
    3              0.000031 hi def link cssBackgroundProp cssProp
    3              0.000032 hi def link cssBorderProp cssProp
    3              0.000028 hi def link cssBoxProp cssProp
    3              0.000030 hi def link cssColorProp cssProp
    3              0.000030 hi def link cssContentForPagedMediaProp cssProp
    3              0.000030 hi def link cssDimensionProp cssProp
    3              0.000030 hi def link cssFlexibleBoxProp cssProp
    3              0.000029 hi def link cssFontProp cssProp
    3              0.000029 hi def link cssGeneratedContentProp cssProp
    3              0.000029 hi def link cssGridProp cssProp
    3              0.000030 hi def link cssHyerlinkProp cssProp
    3              0.000029 hi def link cssInteractProp cssProp
    3              0.000029 hi def link cssLineboxProp cssProp
    3              0.000031 hi def link cssListProp cssProp
    3              0.000057 hi def link cssMarqueeProp cssProp
    3              0.000032 hi def link cssMultiColumnProp cssProp
    3              0.000029 hi def link cssPagedMediaProp cssProp
    3              0.000031 hi def link cssPositioningProp cssProp
    3              0.000027 hi def link cssPrintProp cssProp
    3              0.000029 hi def link cssRubyProp cssProp
    3              0.000029 hi def link cssSpeechProp cssProp
    3              0.000029 hi def link cssTableProp cssProp
    3              0.000029 hi def link cssTextProp cssProp
    3              0.000030 hi def link cssTransformProp cssProp
    3              0.000030 hi def link cssTransitionProp cssProp
    3              0.000028 hi def link cssUIProp cssProp
    3              0.000029 hi def link cssIEUIProp cssProp
    3              0.000031 hi def link cssAuralProp cssProp
    3              0.000027 hi def link cssRenderProp cssProp
    3              0.000030 hi def link cssMobileTextProp cssProp
                            
    3              0.000029 hi def link cssAnimationAttr cssAttr
    3              0.000028 hi def link cssBackgroundAttr cssAttr
    3              0.000032 hi def link cssBorderAttr cssAttr
    3              0.000030 hi def link cssBoxAttr cssAttr
    3              0.000030 hi def link cssContentForPagedMediaAttr cssAttr
    3              0.000027 hi def link cssDimensionAttr cssAttr
    3              0.000031 hi def link cssFlexibleBoxAttr cssAttr
    3              0.000030 hi def link cssFontAttr cssAttr
    3              0.000030 hi def link cssGeneratedContentAttr cssAttr
    3              0.000029 hi def link cssGridAttr cssAttr
    3              0.000027 hi def link cssHyerlinkAttr cssAttr
    3              0.000030 hi def link cssInteractAttr cssAttr
    3              0.000028 hi def link cssLineboxAttr cssAttr
    3              0.000031 hi def link cssListAttr cssAttr
    3              0.000028 hi def link cssMarginAttr cssAttr
    3              0.000029 hi def link cssMarqueeAttr cssAttr
    3              0.000031 hi def link cssMultiColumnAttr cssAttr
    3              0.000028 hi def link cssPaddingAttr cssAttr
    3              0.000029 hi def link cssPagedMediaAttr cssAttr
    3              0.000030 hi def link cssPositioningAttr cssAttr
    3              0.000030 hi def link cssGradientAttr cssAttr
    3              0.000029 hi def link cssPrintAttr cssAttr
    3              0.000028 hi def link cssRubyAttr cssAttr
    3              0.000029 hi def link cssSpeechAttr cssAttr
    3              0.000030 hi def link cssTableAttr cssAttr
    3              0.000028 hi def link cssTextAttr cssAttr
    3              0.000029 hi def link cssTransformAttr cssAttr
    3              0.000030 hi def link cssTransitionAttr cssAttr
    3              0.000030 hi def link cssUIAttr cssAttr
    3              0.000028 hi def link cssIEUIAttr cssAttr
    3              0.000028 hi def link cssAuralAttr cssAttr
    3              0.000029 hi def link cssRenderAttr cssAttr
    3              0.000029 hi def link cssCommonAttr cssAttr
                            
    3              0.000044 hi def link cssPseudoClassId PreProc
    3              0.000040 hi def link cssPseudoClassLang Constant
    3              0.000042 hi def link cssValueLength Number
    3              0.000065 hi def link cssValueInteger Number
    3              0.000122 hi def link cssValueNumber Number
    3              0.000090 hi def link cssValueAngle Number
    3              0.000045 hi def link cssValueTime Number
    3              0.000055 hi def link cssValueFrequency Number
    3              0.000071 hi def link cssFunction Constant
    3              0.000048 hi def link cssURL String
    3              0.000042 hi def link cssFunctionName Function
    3              0.000053 hi def link cssFunctionComma Function
    3              0.000048 hi def link cssColor Constant
    3              0.000044 hi def link cssIdentifier Function
    3              0.000041 hi def link cssAtRule Include
    3              0.000041 hi def link cssAtKeyword PreProc
    3              0.000053 hi def link cssImportant Special
    3              0.000052 hi def link cssBraces Function
    3              0.000055 hi def link cssBraceError Error
    3              0.000052 hi def link cssError Error
    3              0.000053 hi def link cssUnicodeEscape Special
    3              0.000067 hi def link cssStringQQ String
    3              0.000046 hi def link cssStringQ String
    3              0.000063 hi def link cssAttributeSelector String
    3              0.000044 hi def link cssMediaType Special
    3              0.000041 hi def link cssMediaComma Normal
    3              0.000041 hi def link cssAtRuleLogical Statement
    3              0.000032 hi def link cssMediaProp cssProp
    3              0.000029 hi def link cssMediaAttr cssAttr
    3              0.000039 hi def link cssPagePseudo PreProc
    3              0.000043 hi def link cssPageMarginProp cssAtKeyword
    3              0.000030 hi def link cssPageProp cssProp
    3              0.000041 hi def link cssKeyFrameProp Constant
    3              0.000044 hi def link cssFontDescriptor Special
    3              0.000033 hi def link cssFontDescriptorProp cssProp
    3              0.000032 hi def link cssFontDescriptorAttr cssAttr
    3              0.000040 hi def link cssUnicodeRange Constant
    3              0.000044 hi def link cssClassName Function
    3              0.000042 hi def link cssClassNameDot Function
    3              0.000043 hi def link cssProp StorageClass
    3              0.000041 hi def link cssAttr Constant
    3              0.000045 hi def link cssUnitDecorators Number
    3              0.000033 hi def link cssNoise Noise
                            
    3              0.000021 let b:current_syntax = "css"
                            
    3              0.000013 if main_syntax == 'css'
                              unlet main_syntax
                            endif
                            
    3              0.000052 let &cpo = s:cpo_save
    3              0.000009 unlet s:cpo_save
                            " vim: ts=8
                            

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/syntax/sql.vim
Sourced 3 times
Total time:   0.006740
 Self time:   0.001895

count  total (s)   self (s)
                            " Vim syntax file loader
                            " Language:    SQL
                            " Maintainer:  David Fishburn <fishburn at ianywhere dot com>
                            " Last Change: Thu Sep 15 2005 10:30:02 AM
                            " Version:     1.0
                            
                            " Description: Checks for a:
                            "                  buffer local variable,
                            "                  global variable,
                            "              If the above exist, it will source the type specified.
                            "              If none exist, it will source the default sql.vim file.
                            "
                            " quit when a syntax file was already loaded
    3              0.000027 if exists("b:current_syntax")
                                finish
                            endif
                            
                            " Default to the standard Vim distribution file
    3              0.000017 let filename = 'sqloracle'
                            
                            " Check for overrides.  Buffer variables have the highest priority.
    3              0.000012 if exists("b:sql_type_override")
                                " Check the runtimepath to see if the file exists
                                if globpath(&runtimepath, 'syntax/'.b:sql_type_override.'.vim') != ''
                                    let filename = b:sql_type_override
                                endif
                            elseif exists("g:sql_type_default")
                                if globpath(&runtimepath, 'syntax/'.g:sql_type_default.'.vim') != ''
                                    let filename = g:sql_type_default
                                endif
                            endif
                            
                            " Source the appropriate file
    3   0.005682   0.000837 exec 'runtime syntax/'.filename.'.vim'
                            
                            " vim:sw=4:

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/syntax/sqloracle.vim
Sourced 3 times
Total time:   0.004776
 Self time:   0.004776

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	SQL, PL/SQL (Oracle 11g)
                            " Maintainer:	Christian Brabandt
                            " Repository:   https://github.com/chrisbra/vim-sqloracle-syntax
                            " License:      Vim
                            " Previous Maintainer:	Paul Moore
                            " Last Change:	2018 May 13
                            
                            " Changes:
                            " 02.04.2016: Support for when keyword
                            " 03.04.2016: Support for join related keywords
                            " 22.07.2016: Support Oracle Q-Quote-Syntax
                            " 25.07.2016: Support for Oracle N'-Quote syntax
                            
    3              0.000032 if exists("b:current_syntax")
                              finish
                            endif
                            
    3              0.000018 syn case ignore
                            
                            " The SQL reserved words, defined as keywords.
                            
    3              0.000080 syn keyword sqlSpecial	false null true
                            
    3              0.000054 syn keyword sqlKeyword	access add as asc begin by case check cluster column
    3              0.000053 syn keyword sqlKeyword	cache compress connect current cursor decimal default desc
    3              0.000038 syn keyword sqlKeyword	else elsif end exception exclusive file for from
    3              0.000049 syn keyword sqlKeyword	function group having identified if immediate increment
    3              0.000048 syn keyword sqlKeyword	index initial initrans into is level link logging loop
    3              0.000037 syn keyword sqlKeyword	maxextents maxtrans mode modify monitoring
    3              0.000056 syn keyword sqlKeyword	nocache nocompress nologging noparallel nowait of offline on online start
    3              0.000039 syn keyword sqlKeyword	parallel successful synonym table tablespace then to trigger uid
    3              0.000029 syn keyword sqlKeyword	unique user validate values view when whenever
    3              0.000040 syn keyword sqlKeyword	where with option order pctfree pctused privileges procedure
    3              0.000033 syn keyword sqlKeyword	public resource return row rowlabel rownum rows
    3              0.000047 syn keyword sqlKeyword	session share size smallint type using
    3              0.000033 syn keyword sqlKeyword	join cross inner outer left right
                            
    3              0.000025 syn keyword sqlOperator	not and or
    3              0.000035 syn keyword sqlOperator	in any some all between exists
    3              0.000027 syn keyword sqlOperator	like escape
    3              0.000025 syn keyword sqlOperator	union intersect minus
    3              0.000023 syn keyword sqlOperator	prior distinct
    3              0.000028 syn keyword sqlOperator	sysdate out
                            
    3              0.000037 syn keyword sqlStatement analyze audit comment commit
    3              0.000039 syn keyword sqlStatement delete drop execute explain grant lock noaudit
    3              0.000040 syn keyword sqlStatement rename revoke rollback savepoint set
    3              0.000023 syn keyword sqlStatement truncate
                            " next ones are contained, so folding works.
    3              0.000031 syn keyword sqlStatement create update alter select insert contained
                            
    3              0.000031 syn keyword sqlType	boolean char character date float integer long
    3              0.000034 syn keyword sqlType	mlslabel number raw rowid varchar varchar2 varray
                            
                            " Strings:
    3              0.000087 syn region sqlString	matchgroup=Quote start=+n\?"+  skip=+\\\\\|\\"+  end=+"+
    3              0.000066 syn region sqlString	matchgroup=Quote start=+n\?'+  skip=+\\\\\|\\'+  end=+'+
    3              0.000056 syn region sqlString	matchgroup=Quote start=+n\?q'\z([^[(<{]\)+    end=+\z1'+
    3              0.000052 syn region sqlString	matchgroup=Quote start=+n\?q'<+   end=+>'+
    3              0.000047 syn region sqlString	matchgroup=Quote start=+n\?q'{+   end=+}'+
    3              0.000048 syn region sqlString	matchgroup=Quote start=+n\?q'(+   end=+)'+
    3              0.000049 syn region sqlString	matchgroup=Quote start=+n\?q'\[+  end=+]'+
                            
                            " Numbers:
    3              0.000043 syn match sqlNumber	"-\=\<\d*\.\=[0-9_]\>"
                            
                            " Comments:
    3              0.000080 syn region sqlComment	start="/\*"  end="\*/" contains=sqlTodo,@Spell fold 
    3              0.000063 syn match sqlComment	"--.*$" contains=sqlTodo,@Spell
                            
                            " Setup Folding:
                            " this is a hack, to get certain statements folded.
                            " the keywords create/update/alter/select/insert need to
                            " have contained option.
    3              0.000058 syn region sqlFold start='^\s*\zs\c\(Create\|Update\|Alter\|Select\|Insert\)' end=';$\|^$' transparent fold contains=ALL
                            
    3              0.000027 syn sync ccomment sqlComment
                            
                            " Functions:
                            " (Oracle 11g)
                            " Aggregate Functions
    3              0.000044 syn keyword sqlFunction	avg collect corr corr_s corr_k count covar_pop covar_samp cume_dist dense_rank first
    3              0.000040 syn keyword sqlFunction	group_id grouping grouping_id last max median min percentile_cont percentile_disc percent_rank rank
    3              0.000035 syn keyword sqlFunction	regr_slope regr_intercept regr_count regr_r2 regr_avgx regr_avgy regr_sxx regr_syy regr_sxy
    3              0.000035 syn keyword sqlFunction	stats_binomial_test stats_crosstab stats_f_test stats_ks_test stats_mode stats_mw_test
    3              0.000030 syn keyword sqlFunction	stats_one_way_anova stats_t_test_one stats_t_test_paired stats_t_test_indep stats_t_test_indepu
    3              0.000030 syn keyword sqlFunction	stats_wsr_test stddev stddev_pop stddev_samp sum
    3              0.000029 syn keyword sqlFunction	sys_xmlagg var_pop var_samp variance xmlagg
                            " Char Functions
    3              0.000077 syn keyword sqlFunction	ascii chr concat initcap instr length lower lpad ltrim
    3              0.000034 syn keyword sqlFunction	nls_initcap nls_lower nlssort nls_upper regexp_instr regexp_replace
    3              0.000040 syn keyword sqlFunction	regexp_substr replace rpad rtrim soundex substr translate treat trim upper
                            " Comparison Functions
    3              0.000025 syn keyword sqlFunction	greatest least
                            " Conversion Functions
    3              0.000033 syn keyword sqlFunction	asciistr bin_to_num cast chartorowid compose convert
    3              0.000034 syn keyword sqlFunction	decompose hextoraw numtodsinterval numtoyminterval rawtohex rawtonhex rowidtochar
    3              0.000031 syn keyword sqlFunction	rowidtonchar scn_to_timestamp timestamp_to_scn to_binary_double to_binary_float
    3              0.000040 syn keyword sqlFunction	to_char to_char to_char to_clob to_date to_dsinterval to_lob to_multi_byte
    3              0.000036 syn keyword sqlFunction	to_nchar to_nchar to_nchar to_nclob to_number to_dsinterval to_single_byte
    3              0.000032 syn keyword sqlFunction	to_timestamp to_timestamp_tz to_yminterval to_yminterval translate unistr
                            " DataMining Functions
    3              0.000034 syn keyword sqlFunction	cluster_id cluster_probability cluster_set feature_id feature_set
    3              0.000032 syn keyword sqlFunction	feature_value prediction prediction_bounds prediction_cost
    3              0.000027 syn keyword sqlFunction	prediction_details prediction_probability prediction_set
                            " Datetime Functions
    3              0.000030 syn keyword sqlFunction	add_months current_date current_timestamp dbtimezone extract
    3              0.000028 syn keyword sqlFunction	from_tz last_day localtimestamp months_between new_time
    3              0.000031 syn keyword sqlFunction	next_day numtodsinterval numtoyminterval round sessiontimezone
    3              0.000030 syn keyword sqlFunction	sys_extract_utc sysdate systimestamp to_char to_timestamp
    3              0.000029 syn keyword sqlFunction	to_timestamp_tz to_dsinterval to_yminterval trunc tz_offset
                            " Numeric Functions
    3              0.000035 syn keyword sqlFunction	abs acos asin atan atan2 bitand ceil cos cosh exp
    3              0.000033 syn keyword sqlFunction	floor ln log mod nanvl power remainder round sign
    3              0.000031 syn keyword sqlFunction	sin sinh sqrt tan tanh trunc width_bucket
                            " NLS Functions
    3              0.000027 syn keyword sqlFunction	ls_charset_decl_len nls_charset_id nls_charset_name
                            " Various Functions
    3              0.000044 syn keyword sqlFunction	bfilename cardin coalesce collect decode dump empty_blob empty_clob
    3              0.000039 syn keyword sqlFunction	lnnvl nullif nvl nvl2 ora_hash powermultiset powermultiset_by_cardinality
    3              0.000033 syn keyword sqlFunction	sys_connect_by_path sys_context sys_guid sys_typeid uid user userenv vsizeality
                            " XML Functions
    3              0.000037 syn keyword sqlFunction	appendchildxml deletexml depth extract existsnode extractvalue insertchildxml
    3              0.000037 syn keyword sqlFunction	insertxmlbefore path sys_dburigen sys_xmlagg sys_xmlgen updatexml xmlagg xmlcast
    3              0.000031 syn keyword sqlFunction	xmlcdata xmlcolattval xmlcomment xmlconcat xmldiff xmlelement xmlexists xmlforest
    3              0.000041 syn keyword sqlFunction	xmlparse xmlpatch xmlpi xmlquery xmlroot xmlsequence xmlserialize xmltable xmltransform
                            " Todo:
    3              0.000033 syn keyword sqlTodo TODO FIXME XXX DEBUG NOTE contained
                            
                            " Define the default highlighting.
    3              0.000073 hi def link Quote            Special
    3              0.000055 hi def link sqlComment	Comment
    3              0.000051 hi def link sqlFunction	Function
    3              0.000034 hi def link sqlKeyword	sqlSpecial
    3              0.000046 hi def link sqlNumber	Number
    3              0.000036 hi def link sqlOperator	sqlStatement
    3              0.000045 hi def link sqlSpecial	Special
    3              0.000050 hi def link sqlStatement	Statement
    3              0.000049 hi def link sqlString	String
    3              0.000050 hi def link sqlType		Type
    3              0.000050 hi def link sqlTodo		Todo
                            
    3              0.000017 let b:current_syntax = "sql"
                            " vim: ts=8

SCRIPT  /Users/czl/.vim/bundle/blade-php-vim/indent/blade.vim
Sourced 1 time
Total time:   0.001543
 Self time:   0.001030

count  total (s)   self (s)
                            " Language: Blade
                            " Author:	fantasyczl <czilong0618@gmail.com>
                            " Last Change:  2015 July 26th
                            " Version:  0.1
                            
                            
    1              0.000006 if exists("b:did_indent")
                                finish
                            endif
                            
    1   0.000833   0.000371 runtime! indent/html.vim
                            "silent! unlet b:did_indent
    1   0.000351   0.000300 runtime! indent/php.vim
                            
    1              0.000003 let b:did_indent = 1
                            
    1              0.000002 let b:startList = []
    1              0.000002 let b:centerList = []
    1              0.000002 let b:endList = []
                            
    1              0.000006 setlocal indentexpr=GetBladeIndent()
                            
    1              0.000004 setlocal indentkeys=o,O<Return>,<>>,{,},!^F,0{,0},0),:,!^F,e,*<Return>,=?>,=<?,=*/,@end,@stop
                            
                            
    1              0.000002 function! GetBladeIndent()
                                let lnum = v:lnum
                                let preNum = prevnonblank(lnum - 1)
                                
                                if preNum == 0
                                    return 0
                                endif
                            
                            	let indent = HtmlIndent()
                            
                                let preLine = getline(preNum)
                                let curLine = getline(lnum)
                            
                                if IsTagStart(preLine) == 1
                                    let indent += &sw
                                endif
                            
                                if IsTagEnd(curLine) == 1
                                    let indent -= &sw
                                endif
                            
                                silent! unlet preLine
                                silent! unlet curLine
                            
                                return indent
                            endfunc
                            
                            
    1              0.000002 function! IsTagStart(line)
                                if a:line =~? '^\s*@if' || a:line =~? '^\s*@else' || a:line =~? '^\s*@for' || a:line =~? '^\s*@sect' || a:line =~? '^\s*@while'
                                    return 1
                                endif
                            
                                return 0
                            endfun
                            
    1              0.000001 function! IsTagEnd(line)
                                if a:line =~? '^\s*@end' || a:line =~? '^\s*@stop' || a:line =~? '^\s*@else'
                                    return 1
                                endif
                            
                                return 0
                            endfun
                            
    1              0.000001 function! TestBlade()
                                if getline(a:lnum) =~ '\c</pre>' 
                                            \ || 0 < searchpair('\c<pre>', '', '\c</pre>', 'nWb')
                                            \ || 0 < searchpair('\c<pre>', '', '\c</pre>', 'nW')
                                    return -1
                                endif
                            
                                if getline(lnum) =~ '\c</pre>'
                                    let preline = prevnonblank(search('\c<pre>', 'bW') - 1)
                                    if preline > 0
                                        return indent(preline)
                                    endif
                                endif
                            
                                let ind = 1
                                "let ind = HtmlIndentSum(lnum, -1)
                                "echom "ind = " ind
                                "let ind = ind + HtmlIndentSum(a:lnum, 0)
                            
                                echom "lnum = " lnum
                                echom "indent(lnum) = " indent(lnum)
                                return indent(lnum) + (&sw * ind)
                            
                            endfunc
                            
    1              0.000001 function! HtmlIndentOpen(lnum, pattern)
                                let s = substitute('x'.getline(a:lnum)),
                                            \ '.\{-}\(\(<\)\('.a:pattern.'\)\>\)', "\1", 'g')
                                let s = substitute(s, "[^\1].*$", '', '')
                                return strlen(s)
                            endfun
                            
    1              0.000001 function! HtmlIndentClose(lnum, pattern)
                                let s = substitute('x'.getline(a:lnum)),
                                            \ '.\{-}\(\(<\)/\('.a:pattern.'\)\>>\)', "\1", 'g')
                                let s = substitute(s, "[^\1].*$", '', '')
                                return strlen(s)
                            endfunc
                            
    1              0.000001 function! HtmlIndentOpenAlt(lnum)
                                return strlen(substitute(getline(a:lnum), '[^{]\+', '', 'g'))
                            endfunc
                            
    1              0.000002 function! HtmlIndentCloseAlt(lnum)
                                return strlen(substitute(getline(a:lnum), '[^}]\+', '', 'g'))
                            endfunc
                            
    1              0.000002 function! HtmlIndentSum(lnum, style)
                                if a:style == match(getline(a:lnum), '^\s*</')
                                    if a:style == match(getline(a:lnum), '^\s*</\<\(' .g:html_indent_tags.'\)\>')
                                        let open = HtmlIndentOpen(a:lnum, g:html_indent_tags)
                                        let close = HtmlIndentClose(a:lnum, g:html_indent_tags)
                                        if 0 != open || 0 != close
                                            return open - close
                                        endif
                                    endif
                                endif
                            
                                if '' != &syntax && 
                                            \ synIDattr(synID(a:lnum, 1, 1), 'name') =~ '\(css\|java\).*' &&
                                            \ synIDattr(synID(a:lnum, strlen(getline(a:lnum)), 1), 'name')
                                            \ =~ '\(css\|java\).*'
                                    if a:style == match(getline(a:lnum), '^\s*}')
                                        return HtmlIndentOpenAlt(a:lnum) - HtmlIndentCloseAlt(a:lnum)
                                    endif
                                endif
                                return 0
                            endfunc

SCRIPT  /usr/local/Cellar/macvim/8.1-147/MacVim.app/Contents/Resources/vim/runtime/indent/html.vim
Sourced 1 time
Total time:   0.000441
 Self time:   0.000301

count  total (s)   self (s)
                            " Vim indent script for HTML
                            " Header: "{{{
                            " Maintainer:	Bram Moolenaar
                            " Original Author: Andy Wokula <anwoku@yahoo.de>
                            " Last Change:	2018 Mar 28
                            " Version:	1.0
                            " Description:	HTML indent script with cached state for faster indenting on a
                            "		range of lines.
                            "		Supports template systems through hooks.
                            "		Supports Closure stylesheets.
                            "
                            " Credits:
                            "	indent/html.vim (2006 Jun 05) from J. Zellner
                            "	indent/css.vim (2006 Dec 20) from N. Weibull
                            "
                            " History:
                            " 2014 June	(v1.0) overhaul (Bram)
                            " 2012 Oct 21	(v0.9) added support for shiftwidth()
                            " 2011 Sep 09	(v0.8) added HTML5 tags (thx to J. Zuckerman)
                            " 2008 Apr 28	(v0.6) revised customization
                            " 2008 Mar 09	(v0.5) fixed 'indk' issue (thx to C.J. Robinson)
                            "}}}
                            
                            " Init Folklore, check user settings (2nd time ++)
    1              0.000008 if exists("b:did_indent") "{{{
                              finish
                            endif
                            
                            " Load the Javascript indent script first, it defines GetJavascriptIndent().
                            " Undo the rest.
                            " Load base python indent.
    1              0.000004 if !exists('*GetJavascriptIndent')
                              runtime! indent/javascript.vim
                            endif
    1              0.000003 let b:did_indent = 1
                            
    1              0.000010 setlocal indentexpr=HtmlIndent()
    1              0.000005 setlocal indentkeys=o,O,<Return>,<>>,{,},!^F
                            
                            " Needed for % to work when finding start/end of a tag.
    1              0.000004 setlocal matchpairs+=<:>
                            
    1              0.000003 let b:undo_indent = "setlocal inde< indk<"
                            
                            " b:hi_indent keeps state to speed up indenting consecutive lines.
    1              0.000004 let b:hi_indent = {"lnum": -1}
                            
                            """""" Code below this is loaded only once. """""
    1              0.000005 if exists("*HtmlIndent") && !exists('g:force_reload_html')
    1   0.000161   0.000021   call HtmlIndent_CheckUserSettings()
    1              0.000002   finish
                            endif
                            
                            " Allow for line continuation below.
                            let s:cpo_save = &cpo
                            set cpo-=C
                            "}}}
                            
                            " Pattern to match the name of a tag, including custom elements.
                            let s:tagname = '\w\+\(-\w\+\)*'
                            
                            " Check and process settings from b:html_indent and g:html_indent... variables.
                            " Prefer using buffer-local settings over global settings, so that there can
                            " be defaults for all HTML files and exceptions for specific types of HTML
                            " files.
                            func! HtmlIndent_CheckUserSettings()
                              "{{{
                              let inctags = ''
                              if exists("b:html_indent_inctags")
                                let inctags = b:html_indent_inctags
                              elseif exists("g:html_indent_inctags")
                                let inctags = g:html_indent_inctags
                              endif
                              let b:hi_tags = {}
                              if len(inctags) > 0
                                call s:AddITags(b:hi_tags, split(inctags, ","))
                              endif
                            
                              let autotags = ''
                              if exists("b:html_indent_autotags")
                                let autotags = b:html_indent_autotags
                              elseif exists("g:html_indent_autotags")
                                let autotags = g:html_indent_autotags
                              endif
                              let b:hi_removed_tags = {}
                              if len(autotags) > 0
                                call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
                              endif
                            
                              " Syntax names indicating being inside a string of an attribute value.
                              let string_names = []
                              if exists("b:html_indent_string_names")
                                let string_names = b:html_indent_string_names
                              elseif exists("g:html_indent_string_names")
                                let string_names = g:html_indent_string_names
                              endif
                              let b:hi_insideStringNames = ['htmlString']
                              if len(string_names) > 0
                                for s in string_names
                                  call add(b:hi_insideStringNames, s)
                                endfor
                              endif
                            
                              " Syntax names indicating being inside a tag.
                              let tag_names = []
                              if exists("b:html_indent_tag_names")
                                let tag_names = b:html_indent_tag_names
                              elseif exists("g:html_indent_tag_names")
                                let tag_names = g:html_indent_tag_names
                              endif
                              let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
                              if len(tag_names) > 0
                                for s in tag_names
                                  call add(b:hi_insideTagNames, s)
                                endfor
                              endif
                            
                              let indone = {"zero": 0
                                          \,"auto": "indent(prevnonblank(v:lnum-1))"
                                          \,"inc": "b:hi_indent.blocktagind + shiftwidth()"}
                            
                              let script1 = ''
                              if exists("b:html_indent_script1")
                                let script1 = b:html_indent_script1
                              elseif exists("g:html_indent_script1")
                                let script1 = g:html_indent_script1
                              endif
                              if len(script1) > 0
                                let b:hi_js1indent = get(indone, script1, indone.zero)
                              else
                                let b:hi_js1indent = 0
                              endif
                            
                              let style1 = ''
                              if exists("b:html_indent_style1")
                                let style1 = b:html_indent_style1
                              elseif exists("g:html_indent_style1")
                                let style1 = g:html_indent_style1
                              endif
                              if len(style1) > 0
                                let b:hi_css1indent = get(indone, style1, indone.zero)
                              else
                                let b:hi_css1indent = 0
                              endif
                            
                              if !exists('b:html_indent_line_limit')
                                if exists('g:html_indent_line_limit')
                                  let b:html_indent_line_limit = g:html_indent_line_limit
                                else
                                  let b:html_indent_line_limit = 200
                                endif
                              endif
                            endfunc "}}}
                            
                            " Init Script Vars
                            "{{{
                            let b:hi_lasttick = 0
                            let b:hi_newstate = {}
                            let s:countonly = 0
                             "}}}
                            
                            " Fill the s:indent_tags dict with known tags.
                            " The key is "tagname" or "/tagname".  {{{
                            " The value is:
                            " 1   opening tag
                            " 2   "pre"
                            " 3   "script"
                            " 4   "style"
                            " 5   comment start
                            " 6   conditional comment start
                            " -1  closing tag
                            " -2  "/pre"
                            " -3  "/script"
                            " -4  "/style"
                            " -5  comment end
                            " -6  conditional comment end
                            let s:indent_tags = {}
                            let s:endtags = [0,0,0,0,0,0,0]   " long enough for the highest index
                            "}}}
                            
                            " Add a list of tag names for a pair of <tag> </tag> to "tags".
                            func! s:AddITags(tags, taglist)
                              "{{{
                              for itag in a:taglist
                                let a:tags[itag] = 1
                                let a:tags['/' . itag] = -1
                              endfor
                            endfunc "}}}
                            
                            " Take a list of tag name pairs that are not to be used as tag pairs.
                            func! s:RemoveITags(tags, taglist)
                              "{{{
                              for itag in a:taglist
                                let a:tags[itag] = 1
                                let a:tags['/' . itag] = 1
                              endfor
                            endfunc "}}}
                            
                            " Add a block tag, that is a tag with a different kind of indenting.
                            func! s:AddBlockTag(tag, id, ...)
                              "{{{
                              if !(a:id >= 2 && a:id < len(s:endtags))
                                echoerr 'AddBlockTag ' . a:id
                                return
                              endif
                              let s:indent_tags[a:tag] = a:id
                              if a:0 == 0
                                let s:indent_tags['/' . a:tag] = -a:id
                                let s:endtags[a:id] = "</" . a:tag . ">"
                              else
                                let s:indent_tags[a:1] = -a:id
                                let s:endtags[a:id] = a:1
                              endif
                            endfunc "}}}
                            
                            " Add known tag pairs.
                            " Self-closing tags and tags that are sometimes {{{
                            " self-closing (e.g., <p>) are not here (when encountering </p> we can find
                            " the matching <p>, but not the other way around).  Known self-closing tags:
                            " 'p', 'img', 'source'.
                            " Old HTML tags:
                            call s:AddITags(s:indent_tags, [
                                \ 'a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big',
                                \ 'blockquote', 'body', 'button', 'caption', 'center', 'cite', 'code',
                                \ 'colgroup', 'del', 'dfn', 'dir', 'div', 'dl', 'em', 'fieldset', 'font',
                                \ 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'html',
                                \ 'i', 'iframe', 'ins', 'kbd', 'label', 'legend', 'li',
                                \ 'map', 'menu', 'noframes', 'noscript', 'object', 'ol',
                                \ 'optgroup', 'q', 's', 'samp', 'select', 'small', 'span', 'strong', 'sub',
                                \ 'sup', 'table', 'textarea', 'title', 'tt', 'u', 'ul', 'var', 'th', 'td',
                                \ 'tr', 'tbody', 'tfoot', 'thead'])
                            
                            " New HTML5 elements:
                            call s:AddITags(s:indent_tags, [
                                \ 'area', 'article', 'aside', 'audio', 'bdi', 'canvas',
                                \ 'command', 'data', 'datalist', 'details', 'embed', 'figcaption',
                                \ 'figure', 'footer', 'header', 'keygen', 'main', 'mark', 'meter',
                                \ 'nav', 'output', 'picture', 'progress', 'rp', 'rt', 'ruby', 'section',
                                \ 'summary', 'svg', 'time', 'track', 'video', 'wbr'])
                            
                            " Tags added for web components:
                            call s:AddITags(s:indent_tags, [
                                \ 'content', 'shadow', 'template'])
                            "}}}
                            
                            " Add Block Tags: these contain alien content
                            "{{{
                            call s:AddBlockTag('pre', 2)
                            call s:AddBlockTag('script', 3)
                            call s:AddBlockTag('style', 4)
                            call s:AddBlockTag('<!--', 5, '-->')
                            call s:AddBlockTag('<!--[', 6, '![endif]-->')
                            "}}}
                            
                            " Return non-zero when "tagname" is an opening tag, not being a block tag, for
                            " which there should be a closing tag.  Can be used by scripts that include
                            " HTML indenting.
                            func! HtmlIndent_IsOpenTag(tagname)
                              "{{{
                              if get(s:indent_tags, a:tagname) == 1
                                return 1
                              endif
                              return get(b:hi_tags, a:tagname) == 1
                            endfunc "}}}
                            
                            " Get the value for "tagname", taking care of buffer-local tags.
                            func! s:get_tag(tagname)
                              "{{{
                              let i = get(s:indent_tags, a:tagname)
                              if (i == 1 || i == -1) && get(b:hi_removed_tags, a:tagname) != 0
                                return 0
                              endif
                              if i == 0
                                let i = get(b:hi_tags, a:tagname)
                              endif
                              return i
                            endfunc "}}}
                            
                            " Count the number of start and end tags in "text".
                            func! s:CountITags(text)
                              "{{{
                              " Store the result in s:curind and s:nextrel.
                              let s:curind = 0  " relative indent steps for current line [unit &sw]:
                              let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                              let s:block = 0		" assume starting outside of a block
                              let s:countonly = 1	" don't change state
                              call substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                              let s:countonly = 0
                            endfunc "}}}
                            
                            " Count the number of start and end tags in text.
                            func! s:CountTagsAndState(text)
                              "{{{
                              " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
                              let s:curind = 0  " relative indent steps for current line [unit &sw]:
                              let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                            
                              let s:block = b:hi_newstate.block
                              let tmp = substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
                              if s:block == 3
                                let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
                              endif
                              let b:hi_newstate.block = s:block
                            endfunc "}}}
                            
                            " Used by s:CountITags() and s:CountTagsAndState().
                            func! s:CheckTag(itag)
                              "{{{
                              " Returns an empty string or "SCRIPT".
                              " a:itag can be "tag" or "/tag" or "<!--" or "-->"
                              if (s:CheckCustomTag(a:itag))
                                return ""
                              endif
                              let ind = s:get_tag(a:itag)
                              if ind == -1
                                " closing tag
                                if s:block != 0
                                  " ignore itag within a block
                                  return ""
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              elseif ind == 1
                                " opening tag
                                if s:block != 0
                                  return ""
                                endif
                                let s:nextrel += 1
                              elseif ind != 0
                                " block-tag (opening or closing)
                                return s:CheckBlockTag(a:itag, ind)
                              " else ind==0 (other tag found): keep indent
                              endif
                              return ""
                            endfunc "}}}
                            
                            " Used by s:CheckTag(). Returns an empty string or "SCRIPT".
                            func! s:CheckBlockTag(blocktag, ind)
                              "{{{
                              if a:ind > 0
                                " a block starts here
                                if s:block != 0
                                  " already in a block (nesting) - ignore
                                  " especially ignore comments after other blocktags
                                  return ""
                                endif
                                let s:block = a:ind		" block type
                                if s:countonly
                                  return ""
                                endif
                                let b:hi_newstate.blocklnr = v:lnum
                                " save allover indent for the endtag
                                let b:hi_newstate.blocktagind = b:hi_indent.baseindent + (s:nextrel + s:curind) * shiftwidth()
                                if a:ind == 3
                                  return "SCRIPT"    " all except this must be lowercase
                                  " line is to be checked again for the type attribute
                                endif
                              else
                                let s:block = 0
                                " we get here if starting and closing a block-tag on the same line
                              endif
                              return ""
                            endfunc "}}}
                            
                            " Used by s:CheckTag().
                            func! s:CheckCustomTag(ctag)
                              "{{{
                              " Returns 1 if ctag is the tag for a custom element, 0 otherwise.
                              " a:ctag can be "tag" or "/tag" or "<!--" or "-->"
                              let pattern = '\%\(\w\+-\)\+\w\+'
                              if match(a:ctag, pattern) == -1
                                return 0
                              endif
                              if matchstr(a:ctag, '\/\ze.\+') == "/"
                                " closing tag
                                if s:block != 0
                                  " ignore ctag within a block
                                  return 1
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              else
                                " opening tag
                                if s:block != 0
                                  return 1
                                endif
                                let s:nextrel += 1
                              endif
                              return 1
                            endfunc "}}}
                            
                            " Return the <script> type: either "javascript" or ""
                            func! s:GetScriptType(str)
                              "{{{
                              if a:str == "" || a:str =~ "java"
                                return "javascript"
                              else
                                return ""
                              endif
                            endfunc "}}}
                            
                            " Look back in the file, starting at a:lnum - 1, to compute a state for the
                            " start of line a:lnum.  Return the new state.
                            func! s:FreshState(lnum)
                              "{{{
                              " A state is to know ALL relevant details about the
                              " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
                              " fast (incremental).
                              " TODO: this should be split up in detecting the block type and computing the
                              " indent for the block type, so that when we do not know the indent we do
                              " not need to clear the whole state and re-detect the block type again.
                              " State:
                              "	lnum		last indented line == prevnonblank(a:lnum - 1)
                              "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
                              "			3:<script>, 4:<style>, 5:<!--, 6:<!--[
                              "	baseindent	use this indent for line a:lnum as a start - kind of
                              "			autoindent (if block==0)
                              "	scripttype = ''	type attribute of a script tag (if block==3)
                              "	blocktagind	indent for current opening (get) and closing (set)
                              "			blocktag (if block!=0)
                              "	blocklnr	lnum of starting blocktag (if block!=0)
                              "	inattr		line {lnum} starts with attributes of a tag
                              let state = {}
                              let state.lnum = prevnonblank(a:lnum - 1)
                              let state.scripttype = ""
                              let state.blocktagind = -1
                              let state.block = 0
                              let state.baseindent = 0
                              let state.blocklnr = 0
                              let state.inattr = 0
                            
                              if state.lnum == 0
                                return state
                              endif
                            
                              " Heuristic:
                              " remember startline state.lnum
                              " look back for <pre, </pre, <script, </script, <style, </style tags
                              " remember stopline
                              " if opening tag found,
                              "	assume a:lnum within block
                              " else
                              "	look back in result range (stopline, startline) for comment
                              "	    \ delimiters (<!--, -->)
                              "	if comment opener found,
                              "	    assume a:lnum within comment
                              "	else
                              "	    assume usual html for a:lnum
                              "	    if a:lnum-1 has a closing comment
                              "		look back to get indent of comment opener
                              " FI
                            
                              " look back for a blocktag
                              let stopline2 = v:lnum + 1
                              if has_key(b:hi_indent, 'block') && b:hi_indent.block > 5
                                let [stopline2, stopcol2] = searchpos('<!--', 'bnW')
                              endif
                              let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bnW")
                              if stopline > 0 && stopline < stopline2
                                " ugly ... why isn't there searchstr()
                                let tagline = tolower(getline(stopline))
                                let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
                                if blocktag[0] != "/"
                                  " opening tag found, assume a:lnum within block
                                  let state.block = s:indent_tags[blocktag]
                                  if state.block == 3
                                    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
                                  endif
                                  let state.blocklnr = stopline
                                  " check preceding tags in the line:
                                  call s:CountITags(tagline[: stopcol-2])
                                  let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * shiftwidth()
                                  return state
                                elseif stopline == state.lnum
                                  " handle special case: previous line (= state.lnum) contains a
                                  " closing blocktag which is preceded by line-noise;
                                  " blocktag == "/..."
                                  let swendtag = match(tagline, '^\s*</') >= 0
                                  if !swendtag
                                    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bnW")
                                    call s:CountITags(tolower(getline(bline)[: bcol-2]))
                                    let state.baseindent = indent(bline) + (s:curind + s:nextrel) * shiftwidth()
                                    return state
                                  endif
                                endif
                              endif
                              if stopline > stopline2
                                let stopline = stopline2
                                let stopcol = stopcol2
                              endif
                            
                              " else look back for comment
                              let [comlnum, comcol, found] = searchpos('\(<!--\[\)\|\(<!--\)\|-->', 'bpnW', stopline)
                              if found == 2 || found == 3
                                " comment opener found, assume a:lnum within comment
                                let state.block = (found == 3 ? 5 : 6)
                                let state.blocklnr = comlnum
                                " check preceding tags in the line:
                                call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
                                if found == 2
                                  let state.baseindent = b:hi_indent.baseindent
                                endif
                                let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                return state
                              endif
                            
                              " else within usual HTML
                              let text = tolower(getline(state.lnum))
                            
                              " Check a:lnum-1 for closing comment (we need indent from the opening line).
                              " Not when other tags follow (might be --> inside a string).
                              let comcol = stridx(text, '-->')
                              if comcol >= 0 && match(text, '[<>]', comcol) <= 0
                                call cursor(state.lnum, comcol + 1)
                                let [comlnum, comcol] = searchpos('<!--', 'bW')
                                if comlnum == state.lnum
                                  let text = text[: comcol-2]
                                else
                                  let text = tolower(getline(comlnum)[: comcol-2])
                                endif
                                call s:CountITags(text)
                                let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                " TODO check tags that follow "-->"
                                return state
                              endif
                            
                              " Check if the previous line starts with end tag.
                              let swendtag = match(text, '^\s*</') >= 0
                            
                              " If previous line ended in a closing tag, line up with the opening tag.
                              if !swendtag && text =~ '</' . s:tagname . '\s*>\s*$'
                                call cursor(state.lnum, 99999)
                                normal! F<
                                let start_lnum = HtmlIndent_FindStartTag()
                                if start_lnum > 0
                                  let state.baseindent = indent(start_lnum)
                                  if col('.') > 2
                                    " check for tags before the matching opening tag.
                                    let text = getline(start_lnum)
                                    let swendtag = match(text, '^\s*</') >= 0
                                    call s:CountITags(text[: col('.') - 2])
                                    let state.baseindent += s:nextrel * shiftwidth()
                                    if !swendtag
                                      let state.baseindent += s:curind * shiftwidth()
                                    endif
                                  endif
                                  return state
                                endif
                              endif
                            
                              " Else: no comments. Skip backwards to find the tag we're inside.
                              let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
                              " Check if that line starts with end tag.
                              let text = getline(state.lnum)
                              let swendtag = match(text, '^\s*</') >= 0
                              call s:CountITags(tolower(text))
                              let state.baseindent = indent(state.lnum) + s:nextrel * shiftwidth()
                              if !swendtag
                                let state.baseindent += s:curind * shiftwidth()
                              endif
                              return state
                            endfunc "}}}
                            
                            " Indent inside a <pre> block: Keep indent as-is.
                            func! s:Alien2()
                              "{{{
                              return -1
                            endfunc "}}}
                            
                            " Return the indent inside a <script> block for javascript.
                            func! s:Alien3()
                              "{{{
                              let lnum = prevnonblank(v:lnum - 1)
                              while lnum > 1 && getline(lnum) =~ '^\s*/[/*]'
                                " Skip over comments to avoid that cindent() aligns with the <script> tag
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              if lnum == b:hi_indent.blocklnr
                                " indent for the first line after <script>
                                return eval(b:hi_js1indent)
                              endif
                              if b:hi_indent.scripttype == "javascript"
                                return GetJavascriptIndent()
                              else
                                return -1
                              endif
                            endfunc "}}}
                            
                            " Return the indent inside a <style> block.
                            func! s:Alien4()
                              "{{{
                              if prevnonblank(v:lnum-1) == b:hi_indent.blocklnr
                                " indent for first content line
                                return eval(b:hi_css1indent)
                              endif
                              return s:CSSIndent()
                            endfunc "}}}
                            
                            " Indending inside a <style> block.  Returns the indent.
                            func! s:CSSIndent()
                              "{{{
                              " This handles standard CSS and also Closure stylesheets where special lines
                              " start with @.
                              " When the line starts with '*' or the previous line starts with "/*"
                              " and does not end in "*/", use C indenting to format the comment.
                              " Adopted $VIMRUNTIME/indent/css.vim
                              let curtext = getline(v:lnum)
                              if curtext =~ '^\s*[*]'
                                    \ || (v:lnum > 1 && getline(v:lnum - 1) =~ '\s*/\*'
                                    \     && getline(v:lnum - 1) !~ '\*/\s*$')
                                return cindent(v:lnum)
                              endif
                            
                              let min_lnum = b:hi_indent.blocklnr
                              let prev_lnum = s:CssPrevNonComment(v:lnum - 1, min_lnum)
                              let [prev_lnum, found] = HtmlIndent_FindTagStart(prev_lnum)
                              if prev_lnum <= min_lnum
                                " Just below the <style> tag, indent for first content line after comments.
                                return eval(b:hi_css1indent)
                              endif
                            
                              " If the current line starts with "}" align with it's match.
                              if curtext =~ '^\s*}'
                                call cursor(v:lnum, 1)
                                try
                                  normal! %
                                  " Found the matching "{", align with it after skipping unfinished lines.
                                  let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
                                  return indent(align_lnum)
                                catch
                                  " can't find it, try something else, but it's most likely going to be
                                  " wrong
                                endtry
                              endif
                            
                              " add indent after {
                              let brace_counts = HtmlIndent_CountBraces(prev_lnum)
                              let extra = brace_counts.c_open * shiftwidth()
                            
                              let prev_text = getline(prev_lnum)
                              let below_end_brace = prev_text =~ '}\s*$'
                            
                              " Search back to align with the first line that's unfinished.
                              let align_lnum = s:CssFirstUnfinished(prev_lnum, min_lnum)
                            
                              " Handle continuation lines if aligning with previous line and not after a
                              " "}".
                              if extra == 0 && align_lnum == prev_lnum && !below_end_brace
                                let prev_hasfield = prev_text =~ '^\s*[a-zA-Z0-9-]\+:'
                                let prev_special = prev_text =~ '^\s*\(/\*\|@\)'
                                if curtext =~ '^\s*\(/\*\|@\)'
                                  " if the current line is not a comment or starts with @ (used by template
                                  " systems) reduce indent if previous line is a continuation line
                                  if !prev_hasfield && !prev_special
                                    let extra = -shiftwidth()
                                  endif
                                else
                                  let cur_hasfield = curtext =~ '^\s*[a-zA-Z0-9-]\+:'
                                  let prev_unfinished = s:CssUnfinished(prev_text)
                                  if !cur_hasfield && (prev_hasfield || prev_unfinished)
                                    " Continuation line has extra indent if the previous line was not a
                                    " continuation line.
                                    let extra = shiftwidth()
                                    " Align with @if
                                    if prev_text =~ '^\s*@if '
                                      let extra = 4
                                    endif
                                  elseif cur_hasfield && !prev_hasfield && !prev_special
                                    " less indent below a continuation line
                                    let extra = -shiftwidth()
                                  endif
                                endif
                              endif
                            
                              if below_end_brace
                                " find matching {, if that line starts with @ it's not the start of a rule
                                " but something else from a template system
                                call cursor(prev_lnum, 1)
                                call search('}\s*$')
                                try
                                  normal! %
                                  " Found the matching "{", align with it.
                                  let align_lnum = s:CssFirstUnfinished(line('.'), min_lnum)
                                  let special = getline(align_lnum) =~ '^\s*@'
                                catch
                                  let special = 0
                                endtry
                                if special
                                  " do not reduce indent below @{ ... }
                                  if extra < 0
                                    let extra += shiftwidth()
                                  endif
                                else
                                  let extra -= (brace_counts.c_close - (prev_text =~ '^\s*}')) * shiftwidth()
                                endif
                              endif
                            
                              " if no extra indent yet...
                              if extra == 0
                                if brace_counts.p_open > brace_counts.p_close
                                  " previous line has more ( than ): add a shiftwidth
                                  let extra = shiftwidth()
                                elseif brace_counts.p_open < brace_counts.p_close
                                  " previous line has more ) than (: subtract a shiftwidth
                                  let extra = -shiftwidth()
                                endif
                              endif
                            
                              return indent(align_lnum) + extra
                            endfunc "}}}
                            
                            " Inside <style>: Whether a line is unfinished.
                            func! s:CssUnfinished(text)
                              "{{{
                              return a:text =~ '\s\(||\|&&\|:\)\s*$'
                            endfunc "}}}
                            
                            " Search back for the first unfinished line above "lnum".
                            func! s:CssFirstUnfinished(lnum, min_lnum)
                              "{{{
                              let align_lnum = a:lnum
                              while align_lnum > a:min_lnum && s:CssUnfinished(getline(align_lnum - 1))
                                let align_lnum -= 1
                              endwhile
                              return align_lnum
                            endfunc "}}}
                            
                            " Find the non-empty line at or before "lnum" that is not a comment.
                            func! s:CssPrevNonComment(lnum, stopline)
                              "{{{
                              " caller starts from a line a:lnum + 1 that is not a comment
                              let lnum = prevnonblank(a:lnum)
                              while 1
                                let ccol = match(getline(lnum), '\*/')
                                if ccol < 0
                                  " No comment end thus it's something else.
                                  return lnum
                                endif
                                call cursor(lnum, ccol + 1)
                                " Search back for the /* that starts the comment
                                let lnum = search('/\*', 'bW', a:stopline)
                                if indent(".") == virtcol(".") - 1
                                  " The  found /* is at the start of the line. Now go back to the line
                                  " above it and again check if it is a comment.
                                  let lnum = prevnonblank(lnum - 1)
                                else
                                  " /* is after something else, thus it's not a comment line.
                                  return lnum
                                endif
                              endwhile
                            endfunc "}}}
                            
                            " Check the number of {} and () in line "lnum". Return a dict with the counts.
                            func! HtmlIndent_CountBraces(lnum)
                              "{{{
                              let brs = substitute(getline(a:lnum), '[''"].\{-}[''"]\|/\*.\{-}\*/\|/\*.*$\|[^{}()]', '', 'g')
                              let c_open = 0
                              let c_close = 0
                              let p_open = 0
                              let p_close = 0
                              for brace in split(brs, '\zs')
                                if brace == "{"
                                  let c_open += 1
                                elseif brace == "}"
                                  if c_open > 0
                                    let c_open -= 1
                                  else
                                    let c_close += 1
                                  endif
                                elseif brace == '('
                                  let p_open += 1
                                elseif brace == ')'
                                  if p_open > 0
                                    let p_open -= 1
                                  else
                                    let p_close += 1
                                  endif
                                endif
                              endfor
                              return {'c_open': c_open,
                                    \ 'c_close': c_close,
                                    \ 'p_open': p_open,
                                    \ 'p_close': p_close}
                            endfunc "}}}
                            
                            " Return the indent for a comment: <!-- -->
                            func! s:Alien5()
                              "{{{
                              let curtext = getline(v:lnum)
                              if curtext =~ '^\s*\zs-->'
                                " current line starts with end of comment, line up with comment start.
                                call cursor(v:lnum, 0)
                                let lnum = search('<!--', 'b')
                                if lnum > 0
                                  " TODO: what if <!-- is not at the start of the line?
                                  return indent(lnum)
                                endif
                            
                                " Strange, can't find it.
                                return -1
                              endif
                            
                              let prevlnum = prevnonblank(v:lnum - 1)
                              let prevtext = getline(prevlnum)
                              let idx = match(prevtext, '^\s*\zs<!--')
                              if idx >= 0
                                " just below comment start, add a shiftwidth
                                return idx + shiftwidth()
                              endif
                            
                              " Some files add 4 spaces just below a TODO line.  It's difficult to detect
                              " the end of the TODO, so let's not do that.
                            
                              " Align with the previous non-blank line.
                              return indent(prevlnum)
                            endfunc "}}}
                            
                            " Return the indent for conditional comment: <!--[ ![endif]-->
                            func! s:Alien6()
                              "{{{
                              let curtext = getline(v:lnum)
                              if curtext =~ '\s*\zs<!\[endif\]-->'
                                " current line starts with end of comment, line up with comment start.
                                let lnum = search('<!--', 'bn')
                                if lnum > 0
                                  return indent(lnum)
                                endif
                              endif
                              return b:hi_indent.baseindent + shiftwidth()
                            endfunc "}}}
                            
                            " When the "lnum" line ends in ">" find the line containing the matching "<".
                            func! HtmlIndent_FindTagStart(lnum)
                              "{{{
                              " Avoids using the indent of a continuation line.
                              " Moves the cursor.
                              " Return two values:
                              " - the matching line number or "lnum".
                              " - a flag indicating whether we found the end of a tag.
                              " This method is global so that HTML-like indenters can use it.
                              " To avoid matching " > " or " < " inside a string require that the opening
                              " "<" is followed by a word character and the closing ">" comes after a
                              " non-white character.
                              let idx = match(getline(a:lnum), '\S>\s*$')
                              if idx > 0
                                call cursor(a:lnum, idx)
                                let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
                                if lnum > 0
                                  return [lnum, 1]
                                endif
                              endif
                              return [a:lnum, 0]
                            endfunc "}}}
                            
                            " Find the unclosed start tag from the current cursor position.
                            func! HtmlIndent_FindStartTag()
                              "{{{
                              " The cursor must be on or before a closing tag.
                              " If found, positions the cursor at the match and returns the line number.
                              " Otherwise returns 0.
                              let tagname = matchstr(getline('.')[col('.') - 1:], '</\zs' . s:tagname . '\ze')
                              let start_lnum = searchpair('<' . tagname . '\>', '', '</' . tagname . '\>', 'bW')
                              if start_lnum > 0
                                return start_lnum
                              endif
                              return 0
                            endfunc "}}}
                            
                            " Moves the cursor from a "<" to the matching ">".
                            func! HtmlIndent_FindTagEnd()
                              "{{{
                              " Call this with the cursor on the "<" of a start tag.
                              " This will move the cursor to the ">" of the matching end tag or, when it's
                              " a self-closing tag, to the matching ">".
                              " Limited to look up to b:html_indent_line_limit lines away.
                              let text = getline('.')
                              let tagname = matchstr(text, s:tagname . '\|!--', col('.'))
                              if tagname == '!--'
                                call search('--\zs>')
                              elseif s:get_tag('/' . tagname) != 0
                                " tag with a closing tag, find matching "</tag>"
                                call searchpair('<' . tagname, '', '</' . tagname . '\zs>', 'W', '', line('.') + b:html_indent_line_limit)
                              else
                                " self-closing tag, find the ">"
                                call search('\S\zs>')
                              endif
                            endfunc "}}}
                            
                            " Indenting inside a start tag. Return the correct indent or -1 if unknown.
                            func! s:InsideTag(foundHtmlString)
                              "{{{
                              if a:foundHtmlString
                                " Inside an attribute string.
                                " Align with the previous line or use an external function.
                                let lnum = v:lnum - 1
                                if lnum > 1
                                  if exists('b:html_indent_tag_string_func')
                                    return b:html_indent_tag_string_func(lnum)
                                  endif
                                  return indent(lnum)
                                endif
                              endif
                            
                              " Should be another attribute: " attr="val".  Align with the previous
                              " attribute start.
                              let lnum = v:lnum
                              while lnum > 1
                                let lnum -= 1
                                let text = getline(lnum)
                                " Find a match with one of these, align with "attr":
                                "       attr=
                                "  <tag attr=
                                "  text<tag attr=
                                "  <tag>text</tag>text<tag attr=
                                " For long lines search for the first match, finding the last match
                                " gets very slow.
                                if len(text) < 300
                                  let idx = match(text, '.*\s\zs[_a-zA-Z0-9-]\+="')
                                else
                                  let idx = match(text, '\s\zs[_a-zA-Z0-9-]\+="')
                                endif
                                if idx == -1
                                  " try <tag attr
                                  let idx = match(text, '<' . s:tagname . '\s\+\zs\w')
                                endif
                                if idx == -1
                                  " after just <tag indent one level more
                                  let idx = match(text, '<' . s:tagname . '$')
                                  if idx >= 0
                            	call cursor(lnum, idx)
                            	return virtcol('.') + shiftwidth()
                                  endif
                                endif
                                if idx > 0
                                  " Found the attribute to align with.
                                  call cursor(lnum, idx)
                                  return virtcol('.')
                                endif
                              endwhile
                              return -1
                            endfunc "}}}
                            
                            " THE MAIN INDENT FUNCTION. Return the amount of indent for v:lnum.
                            func! HtmlIndent()
                              "{{{
                              if prevnonblank(v:lnum - 1) < 1
                                " First non-blank line has no indent.
                                return 0
                              endif
                            
                              let curtext = tolower(getline(v:lnum))
                              let indentunit = shiftwidth()
                            
                              let b:hi_newstate = {}
                              let b:hi_newstate.lnum = v:lnum
                            
                              " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
                              " a tag works very differently. Do not do this when the line starts with
                              " "<", it gets the "htmlTag" ID but we are not inside a tag then.
                              if curtext !~ '^\s*<'
                                normal! ^
                                let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
                                let foundHtmlString = 0
                                for synid in reverse(stack)
                                  let name = synIDattr(synid, "name")
                                  if index(b:hi_insideStringNames, name) >= 0
                                    let foundHtmlString = 1
                                  elseif index(b:hi_insideTagNames, name) >= 0
                                    " Yes, we are inside a tag.
                                    let indent = s:InsideTag(foundHtmlString)
                                    if indent >= 0
                                      " Do not keep the state. TODO: could keep the block type.
                                      let b:hi_indent.lnum = 0
                                      return indent
                                    endif
                                  endif
                                endfor
                              endif
                            
                              " does the line start with a closing tag?
                              let swendtag = match(curtext, '^\s*</') >= 0
                            
                              if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
                                " use state (continue from previous line)
                              else
                                " start over (know nothing)
                                let b:hi_indent = s:FreshState(v:lnum)
                              endif
                            
                              if b:hi_indent.block >= 2
                                " within block
                                let endtag = s:endtags[b:hi_indent.block]
                                let blockend = stridx(curtext, endtag)
                                if blockend >= 0
                                  " block ends here
                                  let b:hi_newstate.block = 0
                                  " calc indent for REST OF LINE (may start more blocks):
                                  call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
                                  if swendtag && b:hi_indent.block != 5
                                    let indent = b:hi_indent.blocktagind + s:curind * indentunit
                                    let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
                                  else
                                    let indent = s:Alien{b:hi_indent.block}()
                                    let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
                                  endif
                                else
                                  " block continues
                                  " indent this line with alien method
                                  let indent = s:Alien{b:hi_indent.block}()
                                endif
                              else
                                " not within a block - within usual html
                                let b:hi_newstate.block = b:hi_indent.block
                                if swendtag
                                  " The current line starts with an end tag, align with its start tag.
                                  call cursor(v:lnum, 1)
                                  let start_lnum = HtmlIndent_FindStartTag()
                                  if start_lnum > 0
                                    " check for the line starting with something inside a tag:
                                    " <sometag               <- align here
                                    "    attr=val><open>     not here
                                    let text = getline(start_lnum)
                                    let angle = matchstr(text, '[<>]')
                                    if angle == '>'
                                      call cursor(start_lnum, 1)
                                      normal! f>%
                                      let start_lnum = line('.')
                                      let text = getline(start_lnum)
                                    endif
                            
                                    let indent = indent(start_lnum)
                                    if col('.') > 2
                                      let swendtag = match(text, '^\s*</') >= 0
                                      call s:CountITags(text[: col('.') - 2])
                                      let indent += s:nextrel * shiftwidth()
                                      if !swendtag
                                        let indent += s:curind * shiftwidth()
                                      endif
                                    endif
                                  else
                                    " not sure what to do
                                    let indent = b:hi_indent.baseindent
                                  endif
                                  let b:hi_newstate.baseindent = indent
                                else
                                  call s:CountTagsAndState(curtext)
                                  let indent = b:hi_indent.baseindent
                                  let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
                                endif
                              endif
                            
                              let b:hi_lasttick = b:changedtick
                              call extend(b:hi_indent, b:hi_newstate, "force")
                              return indent
                            endfunc "}}}
                            
                            " Check user settings when loading this script the first time.
                            call HtmlIndent_CheckUserSettings()
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: fdm=marker ts=8 sw=2 tw=78

SCRIPT  /Users/czl/.vim/bundle/blade-php-vim/syntax/blade.vim
Sourced 1 time
Total time:   0.034594
 Self time:   0.000957

count  total (s)   self (s)
                            " Language: Blade
                            
                            
    1              0.000009 if exists("b:current_syntax") && b:current_syntax == 'blade'
                                finish
                            endif
                            
    1   0.034056   0.000419 runtime! syntax/php.vim
    1              0.000007 silent! unlet b:current_syntax
                            
    1              0.000034 syn region bladeUnescapedEcho matchgroup=bladeEchoDelim start=/@\@<!\s*{!!/ end=/!!}\s*/ oneline contains=@phpClTop containedin=ALLBUT,bladeComment
    1              0.000024 syn region bladeEscapedEcho matchgroup=bladeEchoDelim start=/@\@<!\s*{{{\@!/ end=/}}\s*/ oneline contains=@phpClTop containedin=ALLBUT,bladeComment
    1              0.000022 syn region bladeEscapedEcho matchgroup=bladeEchoDelim start=/@\@<!\s*{{{{\@!/ end=/}}}/ oneline contains=@phpClTop containedin=ALLBUT,bladeComment
                            
    1              0.000024 syn match bladeStructure /\s*@\(else\|empty\|endfor\|endforeach\|endforelse\|endif\|endpush\|endsection\|endunless\|endwhile\|overwrite\|show\|stop\)\>/
                            
    1              0.000029 syn match bladeStructure /\s*@\(append\|choice\|each\|elseif\|extends\|for\|foreach\|forelse\|if\|include\|lang\|push\|section\|stack\|unless\|while\|yield\|\)\>\s*/ nextgroup=bladeParens
                            
    1              0.000015 syn region bladeParens matchgroup=bladeParen start=/(/ end=/)/ contained contains=@bladeAll,@phpClTop
                            
    1              0.000017 syn region bladeComments start=/\s*{{--/ end=/--}}/ contains=bladeComment keepend
    1              0.000013 syn match bladeComment /.*/ contained containedin=bladeComments
                            
    1              0.000017 syn cluster bladeAll contains=bladeStructure,bladeParens
                            
    1              0.000016 hi def link bladeComment        Comment
    1              0.000012 hi def link bladeEchoDelim      Delimiter
    1              0.000033 hi def link bladeParen          Delimiter
    1              0.000017 hi def link bladeStructure      Keyword
                            
                            
    1              0.000007 if !exists('b:current_syntax')
    1              0.000003     let b:current_syntax = 'blade'
    1              0.000006 endif

FUNCTION  <SNR>53_dopopd()
Called 25 times
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
   25              0.000143   if !exists('w:fzf_dir') || s:fzf_getcwd() != w:fzf_dir[1]
   25              0.000028     return
                              endif
                              execute 'lcd' s:escape(w:fzf_dir[0])
                              unlet w:fzf_dir

FUNCTION  <SNR>45_is_excluded_ft()
Called 9 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    9              0.000037   if !exists("g:delimitMate_excluded_ft")
    9              0.000010     return 0
                              endif
                              return index(split(g:delimitMate_excluded_ft, ','), a:ft, 0, 1) >= 0

FUNCTION  <SNR>53_common_sink()
Called 1 time
Total time:   0.070276
 Self time:   0.000118

count  total (s)   self (s)
    1              0.000002   if len(a:lines) < 2
                                return
                              endif
    1              0.000003   let key = remove(a:lines, 0)
    1              0.000004   let Cmd = get(a:action, key, 'e')
    1              0.000006   if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
                              endif
    1              0.000002   if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
    1              0.000001   try
    1   0.000040   0.000017     let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
    1              0.000002     let autochdir = &autochdir
    1              0.000010     set noautochdir
    2              0.000004     for item in a:lines
    1              0.000001       if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
                                  else
    1   0.070145   0.000010         call s:open(Cmd, item)
    1              0.000001       endif
    1              0.000008       if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter') && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
    1              0.000001     endfor
    1              0.000001   catch /^Vim:Interrupt$/
                              finally
    1              0.000004     let &autochdir = autochdir
    1              0.000008     silent! autocmd! fzf_swap
    1              0.000001   endtry

FUNCTION  3()
Called 21 times
Total time:   0.000677
 Self time:   0.000505

count  total (s)   self (s)
   21              0.000034     let l:prependWorkingDir = 0
                            
   21   0.000248   0.000076     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)' && a:pathStr !~# '^\(\\\\\|\/\/\)'
                                else
   21              0.000114         let l:prependWorkingDir = a:pathStr !~# '^/'
   21              0.000015     endif
                            
   21              0.000037     let l:result = a:pathStr
                            
   21              0.000024     if l:prependWorkingDir
                                    let l:result = getcwd() . s:Path.Slash() . a:pathStr
                                endif
                            
   21              0.000021     return l:result

FUNCTION  emmet#useFilter()
Called 12 times
Total time:   0.000227
 Self time:   0.000227

count  total (s)   self (s)
   24              0.000040   for f in a:filters
   12              0.000025     if a:filter ==# '/' && f =~# '^/'
                                  return 1
                                elseif f ==# a:filter
                                  return 1
                                endif
   12              0.000010   endfor
   12              0.000011   return 0

FUNCTION  <SNR>53_fzf_call()
Called 8 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    8              0.000115     return call(a:fn, a:000)

FUNCTION  <SNR>80_init()
Called 1 time
Total time:   0.001153
 Self time:   0.000118

count  total (s)   self (s)
    1   0.001018   0.000019 	let g:phpcd_root = phpcd#GetRoot()
    1              0.000005 	let phpcd_vim = g:phpcd_root.'/.phpcd.vim'
    1              0.000014 	if filereadable(phpcd_vim)
                            		exec 'source '.phpcd_vim
                            	endif
                            
    1              0.000006 	if exists('g:phpcd_channel_id')
    1   0.000062   0.000026 		call rpc#stop(g:phpcd_channel_id)
                            
    1              0.000014 		unlet g:phpcd_channel_id
    1              0.000005 		if exists('g:phpid_channel_id')
    1              0.000018 			unlet g:phpid_channel_id
    1              0.000001 		endif
    1              0.000001 	endif

FUNCTION  <SNR>53_cmd()
Called 1 time
Total time:   0.044814
 Self time:   0.000169

count  total (s)   self (s)
    1              0.000009   let args = copy(a:000)
    1              0.000005   let opts = { 'options': ['--multi'] }
    1              0.000005   if len(args) && isdirectory(expand(args[-1]))
                                let opts.dir = substitute(substitute(remove(args, -1), '\\\(["'']\)', '\1', 'g'), '[/\\]*$', '/', '')
                                if s:is_win && !&shellslash
                                  let opts.dir = substitute(opts.dir, '/', '\\', 'g')
                                endif
                                let prompt = opts.dir
                              else
    1   0.000109   0.000020     let prompt = s:shortpath()
    1              0.000001   endif
    1              0.000008   let prompt = strwidth(prompt) < &columns - 20 ? prompt : '> '
    1              0.000007   call extend(opts.options, ['--prompt', prompt])
    1              0.000003   call extend(opts.options, args)
    1   0.044645   0.000089   call fzf#run(fzf#wrap('FZF', opts, a:bang))

FUNCTION  <SNR>45_get_syn_name()
Called 9 times
Total time:   0.003598
 Self time:   0.003598

count  total (s)   self (s)
    9              0.000033   let col = col('.')
    9              0.000025   if  col == col('$')
    4              0.000008     let col = col - 1
    4              0.000003   endif
    9              0.003506   return synIDattr(synIDtrans(synID(line('.'), col, 1)), 'name')

FUNCTION  <SNR>78_DisableOnLargeFile()
Called 795 times
Total time:   0.005288
 Self time:   0.005288

count  total (s)   self (s)
  795              0.003118   if exists( 'b:ycm_largefile' )
  793              0.001330     return b:ycm_largefile
                              endif
                            
    2              0.000005   let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
    2              0.000029   let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
    2              0.000002   if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
    2              0.000002   return b:ycm_largefile

FUNCTION  <SNR>45_get()
Called 352 times
Total time:   0.006654
 Self time:   0.006654

count  total (s)   self (s)
  352              0.000374   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
   20              0.000126     let bufoptions = get(s:options, bufnr('%'), {})
   20              0.000135     return deepcopy(get(bufoptions, a:name, a:1))
                              else
  332              0.002518     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  emmet#newNode()
Called 5 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    5              0.000060   return { 'name': '', 'attr': {}, 'child': [], 'snippet': '', 'basevalue': 0, 'basedirect': 1, 'multiplier': 1, 'parent': {}, 'value': '', 'pos': 0, 'important': 0, 'attrs_order': ['id', 'class'], 'block': 0, 'empty': 0 }

FUNCTION  <SNR>78_PollCompletion()
Called 391 times
Total time:   0.265913
 Self time:   0.017639

count  total (s)   self (s)
  391   0.196608   0.004931   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
  189              0.003821     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
  189              0.000349     return
                              endif
                            
  202   0.052076   0.002090   let response = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
  202              0.001885   let s:completion = {   'start_column': response.completion_start_column,   'candidates': response.completions }
  202   0.007971   0.001360   call s:Complete()

FUNCTION  emmet#isExtends()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003   if a:type ==# a:extend
                                return 1
                              endif
    1              0.000003   if !has_key(s:emmet_settings, a:type)
                                return 0
                              endif
    1              0.000003   if !has_key(s:emmet_settings[a:type], 'extends')
    1              0.000001     return 0
                              endif
                              let extends = s:emmet_settings[a:type].extends
                              if type(extends) ==# 1
                                let tmp = split(extends, '\s*,\s*')
                                unlet! extends
                                let extends = tmp
                              endif
                              for ext in extends
                                if a:extend ==# ext
                                  return 1
                                endif
                              endfor
                              return 0

FUNCTION  emmet#parseIntoTree()
Called 2 times
Total time:   0.019754
 Self time:   0.000193

count  total (s)   self (s)
    2              0.000004   let abbr = a:abbr
    2              0.000003   let type = a:type
    2   0.019746   0.000185   return emmet#lang#{emmet#lang#type(type)}#parseIntoTree(abbr, type)

FUNCTION  <SNR>91_CountTagsAndState()
Called 35 times
Total time:   0.002489
 Self time:   0.001350

count  total (s)   self (s)
                              "{{{
                              " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
   35              0.000055   let s:curind = 0  " relative indent steps for current line [unit &sw]:
   35              0.000041   let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                            
   35              0.000069   let s:block = b:hi_newstate.block
   35   0.001939   0.000800   let tmp = substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
   35              0.000043   if s:block == 3
                                let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
                              endif
   35              0.000069   let b:hi_newstate.block = s:block

FUNCTION  <SNR>4_BMTruncName()
Called 7 times
Total time:   0.000593
 Self time:   0.000593

count  total (s)   self (s)
    7              0.000026   let name = a:fname
    7              0.000014   if g:bmenu_max_pathlen < 5
                                let name = ""
                              else
    7              0.000029     let len = strlen(name)
    7              0.000012     if len > g:bmenu_max_pathlen
    1              0.000003       let amountl = (g:bmenu_max_pathlen / 2) - 2
    1              0.000002       let amountr = g:bmenu_max_pathlen - amountl - 3
    1              0.000003       let pattern = '^\(.\{,' . amountl . '}\).\{-}\(.\{,' . amountr . '}\)$'
    1              0.000173       let left = substitute(name, pattern, '\1', '')
    1              0.000164       let right = substitute(name, pattern, '\2', '')
    1              0.000004       if strlen(left) + strlen(right) < len
    1              0.000002 	let name = left . '...' . right
    1              0.000000       endif
    1              0.000001     endif
    7              0.000004   endif
    7              0.000011   return name

FUNCTION  <SNR>39_findAndRevealPath()
Called 1 time
Total time:   0.075685
 Self time:   0.000240

count  total (s)   self (s)
    1              0.000073     let l:pathStr = !empty(a:pathStr) ? a:pathStr : expand('%:p')
                            
    1              0.000004     if empty(l:pathStr)
                                    call nerdtree#echoWarning('no file for the current buffer')
                                    return
                                endif
                            
    1              0.000001     try
    1   0.000554   0.000020         let l:pathObj = g:NERDTreePath.New(l:pathStr)
    1              0.000001     catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echoWarning('invalid path')
                                    return
                                endtry
                            
    1   0.000254   0.000014     if !g:NERDTree.ExistsForTab()
                                    try
                                        let l:cwd = g:NERDTreePath.New(getcwd())
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('current directory does not exist.')
                                        let l:cwd = l:pathObj.getParent()
                                    endtry
                            
                                    if l:pathObj.isUnder(l:cwd)
                                        call g:NERDTreeCreator.CreateTabTree(l:cwd.str())
                                    else
                                        call g:NERDTreeCreator.CreateTabTree(l:pathObj.getParent().str())
                                    endif
                                else
    1   0.042002   0.000016         NERDTreeFocus
                            
    1   0.000230   0.000008         if !l:pathObj.isUnder(b:NERDTree.root.path)
                                        call s:chRoot(g:NERDTreeDirNode.New(l:pathObj.getParent(), b:NERDTree))
                                    endif
    1              0.000000     endif
                            
    1   0.000251   0.000007     if l:pathObj.isHiddenUnder(b:NERDTree.root.path)
                                    call b:NERDTree.ui.setShowHidden(1)
                                endif
                            
    1   0.017999   0.000028     let l:node = b:NERDTree.root.reveal(l:pathObj)
    1   0.012118   0.000005     call b:NERDTree.render()
    1   0.002148   0.000013     call l:node.putCursorHere(1, 0)

FUNCTION  <SNR>78_AllowedToCompleteInCurrentBuffer()
Called 799 times
Total time:   0.052881
 Self time:   0.006420

count  total (s)   self (s)
  799   0.052342   0.005881   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>53_pushd()
Called 1 time
Total time:   0.000038
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000025   0.000006   if s:present(a:dict, 'dir')
                                let cwd = s:fzf_getcwd()
                                if get(a:dict, 'prev_dir', '') ==# cwd
                                  return 1
                                endif
                                let a:dict.prev_dir = cwd
                                execute 'lcd' s:escape(a:dict.dir)
                                let a:dict.dir = s:fzf_getcwd()
                                return 1
                              endif
    1              0.000001   return 0

FUNCTION  MatchTagAlways#Setup()
Called 5 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
                              " When vim is in diff mode, don't run
    5              0.000009   if &diff
                                return
                              endif
                            
                              " If this is not an allowed filetype, don't do anything
    5              0.000019   if !get( g:mta_filetypes, &filetype, 0 )
    4              0.000003     return
                              endif
                            
    1              0.000001   augroup matchtagalways
    1              0.000013     autocmd! CursorMoved,CursorMovedI,WinEnter <buffer> call s:HighlightEnclosingTagsIfPossible()
    1              0.000001   augroup END
                            
    1              0.000002   if !g:mta_use_matchparen_group && g:mta_set_default_matchtag_color
                                hi MatchTag ctermfg=black ctermbg=lightblue guifg=black guibg=lightblue
                              endif

FUNCTION  <SNR>53_defaults()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000005   let rules = copy(get(g:, 'fzf_colors', {}))
    1              0.000012   let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
    1              0.000003   return empty(colors) ? '' : ('--color='.colors)

FUNCTION  htmlcomplete#DetectOmniFlavor()
Called 2 times
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
    2              0.000006   if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
                              else
    2              0.000005     let b:html_omni_flavor = 'html401t'
    2              0.000002   endif
    2              0.000002   let i = 1
    2              0.000006   let line = ""
   11              0.000029   while i < 10 && i < line("$")
    9              0.000021     let line = getline(i)
    9              0.000037     if line =~ '<!DOCTYPE.*\<DTD '
                                  break
                                endif
    9              0.000009     let i += 1
    9              0.000006   endwhile
    2              0.000013   if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
                              endif

FUNCTION  HtmlIndent_FindTagStart()
Called 36 times
Total time:   0.001503
 Self time:   0.001503

count  total (s)   self (s)
                              "{{{
                              " Avoids using the indent of a continuation line.
                              " Moves the cursor.
                              " Return two values:
                              " - the matching line number or "lnum".
                              " - a flag indicating whether we found the end of a tag.
                              " This method is global so that HTML-like indenters can use it.
                              " To avoid matching " > " or " < " inside a string require that the opening
                              " "<" is followed by a word character and the closing ">" comes after a
                              " non-white character.
   36              0.000396   let idx = match(getline(a:lnum), '\S>\s*$')
   36              0.000046   if idx > 0
   21              0.000076     call cursor(a:lnum, idx)
   21              0.000503     let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
   21              0.000028     if lnum > 0
   21              0.000041       return [lnum, 1]
                                endif
                              endif
   15              0.000032   return [a:lnum, 0]

FUNCTION  <SNR>53_split()
Called 1 time
Total time:   0.011753
 Self time:   0.000401

count  total (s)   self (s)
    1              0.000012   let directions = { 'up':    ['topleft', 'resize', &lines], 'down':  ['botright', 'resize', &lines], 'left':  ['vertical topleft', 'vertical resize', &columns], 'right': ['vertical botright', 'vertical resize', &columns] }
    1   0.000018   0.000008   let ppos = s:getpos()
    1              0.000001   try
    1   0.000031   0.000009     if s:present(a:dict, 'window')
                                  execute 'keepalt' a:dict.window
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
    4              0.000010       for [dir, triple] in items(directions)
    4              0.000012         let val = get(a:dict, dir, '')
    4              0.000008         if !empty(val)
    1              0.000003           let [cmd, resz, max] = triple
    1              0.000005           if (dir == 'up' || dir == 'down') && val[0] == '~'
    1   0.000081   0.000011             let sz = s:calc_size(max, val, a:dict)
    1              0.000001           else
                                        let sz = s:calc_size(max, val, {})
                                      endif
    1   0.011449   0.000225           execute cmd sz.'new'
    1              0.000005           execute resz sz
    1              0.000003           return [ppos, {}]
                                    endif
    3              0.000002       endfor
                                endif
                                return [ppos, { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }]
                              finally
    1              0.000014     setlocal winfixwidth winfixheight
    1              0.000001   endtry

FUNCTION  delimitMate#Get()
Called 286 times
Total time:   0.006572
 Self time:   0.001397

count  total (s)   self (s)
  286   0.006479   0.001304   return call('s:get', a:000)

FUNCTION  <SNR>53_fzf_fnamemodify()
Called 1 time
Total time:   0.000057
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000057   0.000010   return s:fzf_call('fnamemodify', a:fname, a:mods)

FUNCTION  <SNR>45_is_jump()
Called 1 time
Total time:   0.000181
 Self time:   0.000053

count  total (s)   self (s)
                              " Returns 1 if the next character is a closing delimiter.
    1   0.000035   0.000006   let char = s:get_char(0)
    1   0.000055   0.000012   let list = s:get('right_delims') + s:get('quotes_list')
                            
                              " Closing delimiter on the right.
    1              0.000005   if (!a:0 && index(list, char) > -1) || (a:0 && char == a:1)
                                return 1
                              endif
                            
                              " Closing delimiter with space expansion.
    1   0.000025   0.000005   let nchar = s:get_char(1)
    1              0.000002   if !a:0 && s:get('expand_space') && char == " "
                                if index(list, nchar) > -1
                                  return 2
                                endif
                              elseif a:0 && s:get('expand_space') && nchar == a:1 && char == ' '
                                return 3
                              endif
                            
    1   0.000022   0.000005   if !s:get('jump_expansion')
    1              0.000001     return 0
                              endif
                            
                              " Closing delimiter with CR expansion.
                              let uchar = matchstr(getline(line('.') + 1), '^\s*\zs\S')
                              if !a:0 && s:get('expand_cr') && char == ""
                                if index(list, uchar) > -1
                                  return 4
                                endif
                              elseif a:0 && s:get('expand_cr') && uchar == a:1
                                return 5
                              endif
                              return 0

FUNCTION  emmet#lang#html#parseIntoTree()
Called 2 times
Total time:   0.019485
 Self time:   0.004404

count  total (s)   self (s)
    2              0.000004   let abbr = a:abbr
    2              0.000003   let type = a:type
                            
    2   0.000012   0.000008   let settings = emmet#getSettings()
    2              0.000005   if !has_key(settings, type)
                                let type = 'html'
                              endif
    2              0.000007   if len(type) == 0 | let type = 'html' | endif
                            
    2   0.000091   0.000011   let indent = emmet#getIndentation(type)
    2              0.000026   let pmap = {'p': 'span','ul': 'li','ol': 'li','table': 'tr','tr': 'td','tbody': 'tr','thead': 'tr','tfoot': 'tr','colgroup': 'col','select': 'option','optgroup': 'option','audio': 'source','video': 'source','object': 'param','map': 'area'}
                            
    2              0.000037   let inlineLevel = split('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var',',')
                            
    2   0.000343   0.000016   let custom_expands = emmet#getResource(type, 'custom_expands', {})
    2              0.000008   if empty(custom_expands) && has_key(settings, 'custom_expands')
    2              0.000005     let custom_expands = settings['custom_expands']
    2              0.000001   endif
                            
                              " try 'foo' to (foo-x)
    2   0.001067   0.000024   let rabbr = emmet#getExpandos(type, abbr)
    2              0.000004   if rabbr == abbr
                                " try 'foo+(' to (foo-x)
    1              0.000017     let rabbr = substitute(abbr, '\%(+\|^\)\([a-zA-Z][a-zA-Z0-9+]\+\)+\([(){}>]\|$\)', '\="(".emmet#getExpandos(type, submatch(1)).")".submatch(2)', 'i')
    1              0.000001   endif
    2              0.000003   let abbr = rabbr
                            
    2   0.000042   0.000016   let root = emmet#newNode()
    2              0.000006   let root['variables'] = {}
    2              0.000003   let parent = root
    2              0.000003   let last = root
    2              0.000002   let pos = []
    5              0.000009   while len(abbr)
                                " parse line
    3              0.000177     let match = matchstr(abbr, s:mx)
    3              0.000149     let str = substitute(match, s:mx, '\0', 'ig')
    3              0.000138     let operator = substitute(match, s:mx, '\1', 'ig')
    3              0.000132     let block_start = substitute(match, s:mx, '\2', 'ig')
    3              0.000132     let tag_name = substitute(match, s:mx, '\3', 'ig')
    3              0.000131     let attributes = substitute(match, s:mx, '\4', 'ig')
    3              0.000129     let value = substitute(match, s:mx, '\5', 'ig')
    3              0.000130     let basevalue = substitute(match, s:mx, '\6', 'ig')
    3              0.000136     let multiplier = 0 + substitute(match, s:mx, '\7', 'ig')
    3              0.000129     let block_end = substitute(match, s:mx, '\8', 'ig')
    3              0.000005     let custom = ''
    3              0.000004     let important = 0
    3              0.000007     if len(str) == 0
                                  break
                                endif
    3              0.000010     if tag_name =~# '^#'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
    3              0.000016     if tag_name =~# '[^!]!$'
                                  let tag_name = tag_name[:-2]
                                  let important = 1
                                endif
    3              0.000008     if tag_name =~# '^\.'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
    3              0.000011     if tag_name =~# '^\[.*\]$'
                                  let attributes = tag_name . attributes
                                  let tag_name = ''
                                endif
                            
    6              0.000015     for k in keys(custom_expands)
    3              0.000017       if tag_name =~ k
                                    let custom = tag_name
                                    let tag_name = ''
                                    break
                                  endif
    3              0.000004     endfor
                            
    3              0.000006     if empty(tag_name)
                                  let pname = len(parent.child) > 0 ? parent.child[0].name : ''
                                  if !empty(pname) && has_key(pmap, pname)
                                    let tag_name = pmap[pname]
                                  elseif !empty(pname) && index(inlineLevel, pname) > -1
                                    let tag_name = 'span'
                                  elseif len(parent.child) == 0 || len(custom) == 0
                                    let tag_name = 'div'
                                  else
                                    let tag_name = custom
                                  endif
                                endif
                            
    3              0.000014     let basedirect = basevalue[1] ==# '-' ? -1 : 1
    3              0.000011     let basevalue = 0 + abs(basevalue[1:])
    5              0.000012     if multiplier <= 0 | let multiplier = 1 | endif
                            
                                " make default node
    3   0.000053   0.000016     let current = emmet#newNode()
                            
    3              0.000007     let current.name = tag_name
    3              0.000006     let current.important = important
                            
                                " aliases
    3   0.003964   0.000059     let aliases = emmet#getResource(type, 'aliases', {})
    3              0.000009     if has_key(aliases, tag_name)
                                  let current.name = aliases[tag_name]
                                endif
                            
    3   0.000292   0.000024     let use_pipe_for_cursor = emmet#getResource(type, 'use_pipe_for_cursor', 1)
                            
                                " snippets
    3   0.001897   0.000038     let snippets = emmet#getResource(type, 'snippets', {})
    3              0.000007     if !empty(snippets)
    3              0.000006       let snippet_name = tag_name
    3              0.000007       if has_key(snippets, snippet_name)
                                    let snippet = snippet_name
                                    while has_key(snippets, snippet)
                                      let snippet = snippets[snippet]
                                    endwhile
                                    if use_pipe_for_cursor
                                      let snippet = substitute(snippet, '|', '${cursor}', 'g')
                                    endif
                                    " just redirect to expanding
                                    if type == 'html' && snippet !~ '^\s*[{\[<]'
                                       return emmet#lang#html#parseIntoTree(snippet, a:type)
                                    endif
                                    let lines = split(snippet, "\n", 1)
                                    call map(lines, 'substitute(v:val, "\\(    \\|\\t\\)", escape(indent, "\\\\"), "g")')
                                    let current.snippet = join(lines, "\n")
                                    let current.name = ''
                                  endif
    3              0.000002     endif
                            
    6              0.000013     for k in keys(custom_expands)
    3              0.000019       if tag_name =~# k
                                    let snippet = '${' . (empty(custom) ? tag_name : custom) . '}'
                                    if current.name != ''
                                      let snode = emmet#newNode()
                                      let snode.snippet = snippet
                                      let snode.parent = current
                                      let snode.multiplier = 1
                                      call add(current.child, snode)
                                    else
                                      let current.snippet = snippet
                                    endif
                                    break
                                  elseif custom =~# k
                                    let snippet = '${' . custom . '}'
                                    let current.snippet = '${' . custom . '}'
                                    if current.name != ''
                                      let snode = emmet#newNode()
                                      let snode.snippet = snippet
                                      let snode.parent = current
                                      call add(current.child, snode)
                                    else
                                      let current.snippet = snippet
                                    endif
                                    break
                                  endif
    3              0.000002     endfor
                            
                                " default_attributes
    3   0.007615   0.000083     let default_attributes = emmet#getResource(type, 'default_attributes', {})
    3              0.000006     if !empty(default_attributes)
    9              0.000015       for pat in [current.name, tag_name]
    6              0.000015         if has_key(default_attributes, pat)
                                      if type(default_attributes[pat]) == 4
                                        let a = default_attributes[pat]
                                        let current.attrs_order += keys(a)
                                        if use_pipe_for_cursor
                                          for k in keys(a)
                                            let current.attr[k] = len(a[k]) ? substitute(a[k], '|', '${cursor}', 'g') : '${cursor}'
                                          endfor
                                        else
                                          for k in keys(a)
                                            let current.attr[k] = a[k]
                                          endfor
                                        endif
                                      else
                                        for a in default_attributes[pat]
                                          let current.attrs_order += keys(a)
                                          if use_pipe_for_cursor
                                            for k in keys(a)
                                              let current.attr[k] = len(a[k]) ? substitute(a[k], '|', '${cursor}', 'g') : '${cursor}'
                                            endfor
                                          else
                                            for k in keys(a)
                                              let current.attr[k] = a[k]
                                            endfor
                                          endif
                                        endfor
                                      endif
                                      if has_key(settings.html.default_attributes, current.name)
                                        let current.name = substitute(current.name, ':.*$', '', '')
                                      endif
                                      break
                                    endif
    6              0.000005       endfor
    3              0.000001     endif
                            
                                " parse attributes
    3              0.000007     if len(attributes)
    1              0.000001       let attr = attributes
    2              0.000004       while len(attr)
    1              0.000037         let item = matchstr(attr, '\(\%(\%(#[{}a-zA-Z0-9_\-\$]\+\)\|\%(\[\%(\[[^\]]*\]\|"[^"]*"\|[^"\[\]]*\)\+\]\)\|\%(\.[{}a-zA-Z0-9_\-\$]\+\)*\)\)')
    1              0.000003         if g:emmet_debug > 1
                                      echomsg 'attr=' . item
                                    endif
    1              0.000002         if len(item) == 0
                                      break
                                    endif
    1              0.000003         if item[0] ==# '#'
                                      let current.attr.id = item[1:]
                                      let root['variables']['id'] = current.attr.id
                                    endif
    1              0.000002         if item[0] ==# '.'
    1              0.000007           let current.attr.class = substitute(item[1:], '\.', ' ', 'g')
    1              0.000003           let root['variables']['class'] = current.attr.class
    1              0.000001         endif
    1              0.000002         if item[0] ==# '['
                                      let atts = item[1:-2]
                                      if matchstr(atts, '^\s*\zs[0-9a-zA-Z_\-:]\+\(="[^"]*"\|=''[^'']*''\|=[^ ''"]\+\)') ==# ''
                                        let ks = []
                            			if has_key(default_attributes, current.name)
                                          let dfa = default_attributes[current.name]
                                          let ks = type(dfa) == 3 ? len(dfa) > 0 ? keys(dfa[0]) : [] : keys(dfa)
                                        endif
                                        if len(ks) == 0 && has_key(default_attributes, current.name . ':src')
                                          let dfa = default_attributes[current.name . ':src']
                                          let ks = type(dfa) == 3 ? len(dfa) > 0 ? keys(dfa[0]) : [] : keys(dfa)
                                        endif
                                        if len(ks) > 0
                                          let current.attr[ks[0]] = atts
                                        else
                                          let current.attr[atts] = ''
                                        endif
                                      else
                                        while len(atts)
                                          let amat = matchstr(atts, '^\s*\zs\([0-9a-zA-Z-:]\+\%(={{.\{-}}}\|="[^"]*"\|=''[^'']*''\|=[^ ''"]\+\|[^ ''"\]]*\)\{0,1}\)')
                                          if len(amat) == 0
                                            break
                                          endif
                                          let key = split(amat, '=')[0]
                                          let Val = amat[len(key)+1:]
                                          if key =~# '\.$' && Val ==# ''
                                            let key = key[:-2]
                                            unlet Val
                                            let Val = function('emmet#types#true')
                                          elseif Val =~# '^["'']'
                                            let Val = Val[1:-2]
                                          endif
                                          let current.attr[key] = Val
                                          if index(current.attrs_order, key) == -1
                                            let current.attrs_order += [key]
                                          endif
                                          let atts = atts[stridx(atts, amat) + len(amat):]
                                          unlet Val
                                        endwhile
                                      endif
                                    endif
    1              0.000009         let attr = substitute(strpart(attr, len(item)), '^\s*', '', '')
    1              0.000001       endwhile
    1              0.000001     endif
                            
                                " parse text
    3              0.000012     if tag_name =~# '^{.*}$'
                                  let current.name = ''
                                  let current.value = tag_name
                                else
    3              0.000005       let current.value = value
    3              0.000002     endif
    3              0.000005     let current.basedirect = basedirect
    3              0.000005     let current.basevalue = basevalue
    3              0.000003     let current.multiplier = multiplier
                            
                                " parse step inside/outside
    3              0.000005     if !empty(last)
    3              0.000008       if operator =~# '>'
    1              0.000002         unlet! parent
    1              0.000001         let parent = last
    1              0.000002         let current.parent = last
    1              0.000002         let current.pos = last.pos + 1
    1              0.000001       else
    2              0.000004         let current.parent = parent
    2              0.000003         let current.pos = last.pos
    2              0.000003       endif
    3              0.000003     else
                                  let current.parent = parent
                                  let current.pos = 1
                                endif
    3              0.000013     if operator =~# '[<^]'
                                  for c in range(len(operator))
                                    let tmp = parent.parent
                                    if empty(tmp)
                                      break
                                    endif
                                    let parent = tmp
                                    let current.parent = tmp
                                  endfor
                                endif
                            
    3              0.000009     call add(parent.child, current)
    3              0.000004     let last = current
                            
                                " parse block
    3              0.000009     if block_start =~# '('
                                  if operator =~# '>'
                                    let last.pos += 1
                                  endif
                                  let last.block = 1
                                  for n in range(len(block_start))
                                    let pos += [last.pos]
                                  endfor
                                endif
    3              0.000007     if block_end =~# ')'
                                  for n in split(substitute(substitute(block_end, ' ', '', 'g'), ')', ',),', 'g'), ',')
                                    if n ==# ')'
                                      if len(pos) > 0 && last.pos >= pos[-1]
                                        for c in range(last.pos - pos[-1])
                                          let tmp = parent.parent
                                          if !has_key(tmp, 'parent')
                                            break
                                          endif
                                          let parent = tmp
                                        endfor
                                        if len(pos) > 0
                                          call remove(pos, -1)
                                        endif
                                        let last = parent
                                        let last.pos += 1
                                      endif
                                    elseif len(n)
                                      let st = 0
                                      for nc in range(len(last.child))
                                        if last.child[nc].block
                                          let st = nc
                                          break
                                        endif
                                      endfor
                                      let cl = last.child[st :]
                                      let cls = []
                                      for c in range(n[1:])
                                        for cc in cl
                                          if cc.multiplier > 1
                                            let cc.basedirect = c + 1
                                          else
                                            let cc.basevalue = c + 1
                                          endif
                                        endfor
                                        let cls += deepcopy(cl)
                                      endfor
                                      if st > 0
                                        let last.child = last.child[:st-1] + cls
                                      else
                                        let last.child = cls
                                      endif
                                    endif
                                  endfor
                                endif
    3              0.000017     let abbr = abbr[stridx(abbr, match) + len(match):]
    3              0.000004     if abbr == '/'
                                  let current.empty = 1
                                endif
                            
    3              0.000004     if g:emmet_debug > 1
                                  echomsg 'str='.str
                                  echomsg 'block_start='.block_start
                                  echomsg 'tag_name='.tag_name
                                  echomsg 'operator='.operator
                                  echomsg 'attributes='.attributes
                                  echomsg 'value='.value
                                  echomsg 'basevalue='.basevalue
                                  echomsg 'multiplier='.multiplier
                                  echomsg 'block_end='.block_end
                                  echomsg 'abbr='.abbr
                                  echomsg 'pos='.string(pos)
                                  echomsg '---'
                                endif
    3              0.000002   endwhile
    2              0.000003   return root

FUNCTION  <SNR>67_InitColor()
Called 9 times
Total time:   0.001507
 Self time:   0.001507

count  total (s)   self (s)
    9              0.000023     if !g:indentLine_setColors
                                    return
                                endif
                            
    9              0.000041     if !exists("g:indentLine_color_term")
    9              0.000025         if &background ==# "light"
    9              0.000020             let term_color = 249
    9              0.000007         else
                                        let term_color = 239
                                    endif
    9              0.000005     else
                                    let term_color = g:indentLine_color_term
                                endif
                            
    9              0.000039     if !exists("g:indentLine_bgcolor_term")
    9              0.000017         let term_bgcolor = "NONE"
    9              0.000004     else
                                    let term_bgcolor = g:indentLine_bgcolor_term
                                endif
                            
    9              0.000026     if !exists("g:indentLine_color_gui")
    9              0.000014         if &background ==# "light"
    9              0.000013             let gui_color = "Grey70"
    9              0.000006         else
                                        let gui_color = "Grey30"
                                    endif
    9              0.000006     else
                                    let gui_color = g:indentLine_color_gui
                                endif
                            
    9              0.000027     if !exists("g:indentLine_bgcolor_gui")
    9              0.000060         let gui_bgcolor = "NONE"
    9              0.000007     else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
                                endif
                            
    9              0.000431     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    9              0.000402     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    9              0.000023     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif

FUNCTION  <SNR>53_escape()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000009   let path = fnameescape(a:path)
    1              0.000003   return s:is_win ? escape(path, '$') : path

FUNCTION  <SNR>80_GetFullName()
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000003 	if a:namespace == '\'
                            		let full_classname = a:classname
                            	else
    2              0.000006 		let full_classname = a:namespace . '\' . a:classname
    2              0.000002 	endif
                            
    2              0.000003 	return full_classname

FUNCTION  <SNR>91_get_tag()
Called 39 times
Total time:   0.000629
 Self time:   0.000629

count  total (s)   self (s)
                              "{{{
   39              0.000149   let i = get(s:indent_tags, a:tagname)
   39              0.000170   if (i == 1 || i == -1) && get(b:hi_removed_tags, a:tagname) != 0
                                return 0
                              endif
   39              0.000039   if i == 0
                                let i = get(b:hi_tags, a:tagname)
                              endif
   39              0.000041   return i

FUNCTION  <SNR>78_OnBufferEnter()
Called 23 times
Total time:   0.063406
 Self time:   0.018278

count  total (s)   self (s)
   23   0.001637   0.000123   if !s:VisitedBufferRequiresReparse()
    5              0.000004     return
                              endif
                            
   18   0.000556   0.000087   call s:SetUpCompleteopt()
   18   0.000204   0.000086   call s:SetCompleteFunc()
   18   0.000366   0.000081   call s:StartMessagePoll()
                            
   18              0.017457   exec s:python_command "ycm_state.OnBufferVisit()"
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
   18   0.043041   0.000299   call s:OnFileReadyToParse( 1 )

FUNCTION  emmet#expandCursorExpr()
Called 2 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
    2              0.000005   let expand = a:expand
    2              0.000012   if expand !~# '\${cursor}'
                                if a:mode ==# 2
                                  let expand = '${cursor}' . expand
                                else
                                  let expand .= '${cursor}'
                                endif
                              endif
    2              0.000024   let expand = substitute(expand, '\${\d\+:\?\([^}]\+\)}', '$select$$cursor$\1$select$', 'g')
    2              0.000016   let expand = substitute(expand, '\${\d\+}', '$select$$cursor$$select$', 'g')
    2              0.000016   let expand = substitute(expand, '\${cursor}', '$cursor$', '')
    2              0.000013   let expand = substitute(expand, '\${cursor}', '', 'g')
    2              0.000012   let expand = substitute(expand, '\${cursor}', '', 'g')
    2              0.000003   return expand

FUNCTION  <SNR>53_calc_size()
Called 1 time
Total time:   0.000070
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000010   let val = substitute(a:val, '^\~', '', '')
    1              0.000005   if val =~ '%$'
    1              0.000005     let size = a:max * str2nr(val[:-2]) / 100
    1              0.000001   else
                                let size = min([a:max, str2nr(val)])
                              endif
                            
    1              0.000001   let srcsz = -1
    1              0.000005   if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
                              endif
                            
    1   0.000018   0.000010   let opts = s:evaluate_opts(get(a:dict, 'options', '')).$FZF_DEFAULT_OPTS
    1              0.000007   let margin = stridx(opts, '--inline-info') > stridx(opts, '--no-inline-info') ? 1 : 2
    1              0.000006   let margin += stridx(opts, '--header') > stridx(opts, '--no-header')
    1              0.000003   return srcsz >= 0 ? min([srcsz + margin, size]) : size

FUNCTION  lightline#update()
Called 35 times
Total time:   0.071983
 Self time:   0.002668

count  total (s)   self (s)
   35              0.000083   if s:_
                                call lightline#init()
                                call lightline#colorscheme()
                              endif
   35              0.000098   if !s:lightline.enable.statusline
                                return
                              endif
   35              0.000126   let w = winnr()
   35   0.069779   0.000464   let s = winnr('$') == 1 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   88              0.000241   for n in range(1, winnr('$'))
   53              0.000780     call setwinvar(n, '&statusline', s[n!=w])
   53              0.000253     call setwinvar(n, 'lightline', n!=w)
   53              0.000044   endfor

FUNCTION  <SNR>67_IndentLinesEnable()
Called 7 times
Total time:   0.003601
 Self time:   0.003425

count  total (s)   self (s)
    7              0.000012     if g:indentLine_newVersion
    7              0.000008         if &diff
                                        return
                                    endif
                            
    7              0.000022         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
                                    endif
                            
    7              0.000019         if !exists("w:indentLine_indentLineId")
    2              0.000005             let w:indentLine_indentLineId = []
    2              0.000001         endif
                            
    7   0.000210   0.000034         call s:SetConcealOption()
                            
    7              0.000011         if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
                                    endif
                            
    7              0.000016         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
  147              0.000192         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
  140              0.002807             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': g:indentLine_char}))
  140              0.000116         endfor
                            
    7              0.000008         return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  <SNR>45_get_char()
Called 4 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    4              0.000014   let idx = col('.') - 1
    4              0.000008   if !a:0 || (a:0 && a:1 >= 0)
                                " Get char from cursor.
    3              0.000013     let line = getline('.')[idx :]
    3              0.000006     let pos = a:0 ? a:1 : 0
    3              0.000034     return matchstr(line, '^'.repeat('.', pos).'\zs.')
                              endif
                              " Get char behind cursor.
    1              0.000004   let line = getline('.')[: idx - 1]
    1              0.000002   let pos = 0 - (1 + a:1)
    1              0.000010   return matchstr(line, '.\ze'.repeat('.', pos).'$')

FUNCTION  <SNR>91_CheckTag()
Called 39 times
Total time:   0.002670
 Self time:   0.001490

count  total (s)   self (s)
                              "{{{
                              " Returns an empty string or "SCRIPT".
                              " a:itag can be "tag" or "/tag" or "<!--" or "-->"
   39   0.000792   0.000241   if (s:CheckCustomTag(a:itag))
                                return ""
                              endif
   39   0.000824   0.000195   let ind = s:get_tag(a:itag)
   39              0.000045   if ind == -1
                                " closing tag
    9              0.000009     if s:block != 0
                                  " ignore itag within a block
                                  return ""
                                endif
    9              0.000010     if s:nextrel == 0
                                  let s:curind -= 1
                                else
    9              0.000017       let s:nextrel -= 1
    9              0.000007     endif
    9              0.000008   elseif ind == 1
                                " opening tag
   30              0.000036     if s:block != 0
                                  return ""
                                endif
   30              0.000056     let s:nextrel += 1
   30              0.000030   elseif ind != 0
                                " block-tag (opening or closing)
                                return s:CheckBlockTag(a:itag, ind)
                              " else ind==0 (other tag found): keep indent
                              endif
   39              0.000038   return ""

FUNCTION  <SNR>78_InvokeCompletion()
Called 204 times
Total time:   0.568592
 Self time:   0.209132

count  total (s)   self (s)
  204   0.383737   0.206389   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
  204   0.184378   0.002266   call s:PollCompletion()

FUNCTION  <SNR>78_OnFileTypeSet()
Called 5 times
Total time:   0.018587
 Self time:   0.005688

count  total (s)   self (s)
    5   0.000321   0.000026   if !s:AllowedToCompleteInCurrentBuffer()
    1              0.000001     return
                              endif
                            
    4   0.000101   0.000015   call s:SetUpCompleteopt()
    4   0.000039   0.000014   call s:SetCompleteFunc()
    4   0.000069   0.000020   call s:StartMessagePoll()
                            
    4              0.005524   exec s:python_command "ycm_state.OnBufferVisit()"
    4   0.012511   0.000067   call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>44_option_init()
Called 184 times
Total time:   0.010722
 Self time:   0.003619

count  total (s)   self (s)
  184              0.000725   let b = exists("b:delimitMate_" . a:name)
  184              0.000594   let g = exists("g:delimitMate_" . a:name)
                              " Find value to use.
  184              0.000192   if !b && !g
  176              0.000238     let value = a:default
  176              0.000149   elseif b
    2              0.000011     exec "let value = b:delimitMate_" . a:name
    2              0.000002   else
    6              0.000023     exec "let value = g:delimitMate_" . a:name
    6              0.000006   endif
  184   0.007883   0.000780   call s:set(a:name, value)

FUNCTION  <SNR>53_fzf_exec()
Called 1 time
Total time:   0.000065
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000004   if !exists('s:exec')
                                if executable(s:fzf_go)
                                  let s:exec = s:fzf_go
                                elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif s:is_win && !has('win32unix')
                                  call s:warn('fzf executable not found.')
                                  call s:warn('Download fzf binary for Windows from https://github.com/junegunn/fzf-bin/releases/')
                                  call s:warn('and place it as '.s:base_dir.'\bin\fzf.exe')
                                  throw 'fzf executable not found'
                                elseif !s:installed && executable(s:install) && input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                  redraw
                                  echo
                                  call s:warn('Downloading fzf binary. Please wait ...')
                                  let s:installed = 1
                                  call system(s:install.' --bin')
                                  return s:fzf_exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
                                endif
                              endif
    1   0.000027   0.000004   return fzf#shellescape(s:exec)

FUNCTION  <SNR>6_LoadFTPlugin()
Called 5 times
Total time:   0.030602
 Self time:   0.015210

count  total (s)   self (s)
    5              0.000078     if exists("b:undo_ftplugin")
    2              0.000138       exe b:undo_ftplugin
    2              0.000007       unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000002     endif
                            
    5              0.000071     let s = expand("<amatch>")
    5              0.000021     if s != ""
    5              0.000161       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   10              0.000151       for name in split(s, '\.')
    5   0.029745   0.014353 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    5              0.000048       endfor
    5              0.000006     endif

FUNCTION  74()
Called 45 times
Total time:   0.001516
 Self time:   0.001516

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
   45              0.000074     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
   45              0.000181     if self.key =~# specialNotationRegex
    8              0.000068         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
    8              0.000007     else
   37              0.000051         let keymapInvokeString = self.key
   37              0.000020     endif
                            
   45              0.000082     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
   45              0.000742     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  <SNR>78_OnInsertChar()
Called 185 times
Total time:   0.021127
 Self time:   0.004040

count  total (s)   self (s)
  185   0.016141   0.001420   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  185              0.000923   call timer_stop( s:pollers.completion.id )
  185   0.003324   0.000958   call s:CloseCompletionMenu()

FUNCTION  14()
Called 60 times
Total time:   0.000326
 Self time:   0.000326

count  total (s)   self (s)
   60              0.000093     if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
   60              0.000057     return self.cachedDisplayString

FUNCTION  15()
Called 1 time
Total time:   0.156557
 Self time:   0.006328

count  total (s)   self (s)
    1   0.156557   0.006328     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  16()
Called 21 times
Total time:   0.000524
 Self time:   0.000361

count  total (s)   self (s)
   21   0.000225   0.000062     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
   21              0.000050         let self.drive = ''
   21              0.000012     endif
                            

FUNCTION  105()
Called 1 time
Total time:   0.172310
 Self time:   0.000047

count  total (s)   self (s)
    1   0.172309   0.000046     call self.open(a:0 ? a:1 : {})

FUNCTION  phpcd#OpenFileNoAutoRestart()
Called 2 times
Total time:   0.006646
 Self time:   0.000164

count  total (s)   self (s)
    2              0.000010 	if g:phpcd_root == '/'
    1   0.001169   0.000016 		call s:init()
    1              0.000000 	endif
                            
    2   0.005435   0.000106 	call s:startChannel()

FUNCTION  <SNR>45_joinUndo()
Called 8 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    8              0.000029   if v:version < 704 || ( v:version == 704 && !has('patch849') )
                                return ''
                              endif
    8              0.000017   return "\<C-G>U"

FUNCTION  20()
Called 19 times
Total time:   0.005922
 Self time:   0.000362

count  total (s)   self (s)
   19   0.000204   0.000056     if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
                                else
   19              0.000152         let path = '/'. join(self.pathSegments[0:-2], '/')
   19              0.000014     endif
                            
   19   0.005479   0.000067     return s:Path.New(path)

FUNCTION  21()
Called 357 times
Total time:   0.003272
 Self time:   0.003272

count  total (s)   self (s)
  357              0.000619     if empty(self.pathSegments)
                                    return ''
                                endif
  357              0.000627     let toReturn = self.pathSegments[-1]
  357              0.000404     if a:dirSlash && self.isDirectory
                                    let toReturn = toReturn . '/'
                                endif
  357              0.000331     return toReturn

FUNCTION  25()
Called 1 time
Total time:   0.000244
 Self time:   0.000046

count  total (s)   self (s)
                            
    1   0.000201   0.000003     if !self.isUnder(a:path)
                                    return 0
                                endif
                            
    1              0.000002     let l:startIndex = len(a:path.pathSegments)
    1              0.000004     let l:segments = self.pathSegments[l:startIndex : ]
                            
    5              0.000007     for l:segment in l:segments
                            
    4              0.000012         if l:segment =~# '^\.'
                                        return 1
                                    endif
    4              0.000002     endfor
                            
    1              0.000001     return 0

FUNCTION  26()
Called 168 times
Total time:   0.002360
 Self time:   0.000875

count  total (s)   self (s)
  168   0.002312   0.000827     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  28()
Called 168 times
Total time:   0.016164
 Self time:   0.006578

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
  168   0.000734   0.000499     if a:nerdtree.ui.isIgnoreFilterEnabled()
  336              0.000413         for i in g:NERDTreeIgnore
  168   0.006224   0.000583             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
  168              0.000111         endfor
                            
  168   0.001512   0.000554         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
  168              0.000090     endif
                            
                                "dont show hidden files unless instructed to
  168   0.003437   0.000871     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
   20              0.000018         return 1
                                endif
                            
  148   0.000740   0.000554     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
  148              0.000101     return 0

FUNCTION  29()
Called 168 times
Total time:   0.005641
 Self time:   0.004075

count  total (s)   self (s)
  168              0.000211     let pat = a:pattern
  168              0.000650     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
  168   0.002382   0.000816     return self.getLastPathComponent(0) =~# pat

FUNCTION  <SNR>39_activateFileNode()
Called 1 time
Total time:   0.172338
 Self time:   0.000028

count  total (s)   self (s)
    1   0.172335   0.000025     call a:node.activate({'reuse': 'all', 'where': 'p'})

FUNCTION  <SNR>95_itemno()
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000004   let current = a:current
    3              0.000003   if current.basedirect > 0
    3              0.000003     if current.basevalue ==# 0
    3              0.000003       return a:itemno
                                else
                                  return current.basevalue - 1 + a:itemno
                                endif
                              else
                                if current.basevalue ==# 0
                                  return current.multiplier - 1 - a:itemno
                                else
                                  return current.multiplier + current.basevalue - 2 - a:itemno
                                endif
                              endif

FUNCTION  111()
Called 24 times
Total time:   0.000522
 Self time:   0.000152

count  total (s)   self (s)
   24   0.000515   0.000145     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  112()
Called 4 times
Total time:   0.000731
 Self time:   0.000028

count  total (s)   self (s)
    4   0.000727   0.000024     return self.path.str() ==# a:treenode.path.str()

FUNCTION  113()
Called 3 times
Total time:   0.000567
 Self time:   0.000018

count  total (s)   self (s)
    3   0.000561   0.000012     if a:path.equals(self.path)
    2              0.000002         return self
                                endif
    1              0.000001     return {}

FUNCTION  116()
Called 173 times
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
  173              0.000180     return self._nerdtree

FUNCTION  118()
Called 1 time
Total time:   0.009414
 Self time:   0.000032

count  total (s)   self (s)
                            
    1              0.000001     try
    1   0.002515   0.000014         let l:path = b:NERDTree.ui.getPath(line('.'))
                            
    1              0.000002         if empty(l:path)
                                        return {}
                                    endif
                            
    1   0.006887   0.000006         return b:NERDTree.root.findNode(l:path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  emmet#getSettings()
Called 9 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    9              0.000013   return s:emmet_settings

FUNCTION  <SNR>78_OnCompleteDone()
Called 216 times
Total time:   0.020604
 Self time:   0.020604

count  total (s)   self (s)
  216              0.020408   exec s:python_command "ycm_state.OnCompleteDone()"

FUNCTION  162()
Called 4 times
Total time:   0.037566
 Self time:   0.002638

count  total (s)   self (s)
    4              0.000008     let opts = a:0 ? a:1 : {}
                            
    4   0.000815   0.000014     if !a:path.isUnder(self.path)
                                    throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
                                endif
                            
    4   0.001726   0.000021     call self.open()
                            
    4   0.002153   0.000090     if self.path.equals(a:path.getParent())
    1   0.000564   0.000004         let n = self.findNode(a:path)
    1              0.000002         if has_key(opts, "open")
                                        call n.open()
                                    endif
    1              0.000001         return n
                                endif
                            
    3              0.000003     let p = a:path
    9   0.004592   0.000198     while !p.getParent().equals(self.path)
    6   0.001925   0.000069         let p = p.getParent()
    6              0.000006     endwhile
                            
    3   0.006070   0.000014     let n = self.findNode(p)
    3              0.000011     return n.reveal(a:path, opts)

FUNCTION  31()
Called 6 times
Total time:   0.001221
 Self time:   0.000100

count  total (s)   self (s)
    6              0.000007     if a:path.isDirectory == 0
                                    return 0
                                endif
                            
    6   0.000549   0.000024     let this = self.str()
    6   0.000520   0.000022     let that = a:path.str()
    6   0.000130   0.000032     return stridx(this, that . s:Path.Slash()) == 0

FUNCTION  33()
Called 51 times
Total time:   0.009421
 Self time:   0.000339

count  total (s)   self (s)
   51   0.009406   0.000324     return self.str() ==# a:path.str()

FUNCTION  34()
Called 21 times
Total time:   0.006409
 Self time:   0.000822

count  total (s)   self (s)
   21              0.000437     let l:newPath = copy(self)
                            
   21   0.005604   0.000171     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
   21              0.000041     let l:newPath.cachedDisplayString = ''
   21   0.000259   0.000105     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
   21              0.000022     return l:newPath

FUNCTION  35()
Called 195 times
Total time:   0.003439
 Self time:   0.001884

count  total (s)   self (s)
                            
  195   0.002138   0.000583     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
  195              0.000166     return '/'

FUNCTION  36()
Called 42 times
Total time:   0.001363
 Self time:   0.001363

count  total (s)   self (s)
   42              0.000834     let tmp = resolve(a:path)
   42              0.000510     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  37()
Called 21 times
Total time:   0.004756
 Self time:   0.002204

count  total (s)   self (s)
   21   0.000603   0.000079     call self.extractDriveLetter(a:fullpath)
                            
   21   0.000346   0.000084     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
   21              0.000195     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
   21              0.000448     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
   21              0.000041     let self.isReadOnly = 0
   21              0.000123     if isdirectory(a:fullpath)
   19              0.000041         let self.isDirectory = 1
   19              0.000032     elseif filereadable(a:fullpath)
    2              0.000006         let self.isDirectory = 0
    2              0.000036         let self.isReadOnly = filewritable(a:fullpath) ==# 0
    2              0.000002     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
   21              0.000029     let self.isExecutable = 0
   21              0.000023     if !self.isDirectory
    2              0.000021         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    2              0.000002     endif
                            
                                "grab the last part of the path (minus the trailing slash)
   21   0.000329   0.000108     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
   21   0.001034   0.000165     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
   21   0.000806   0.000130     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
   21              0.000023     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  <SNR>53_shortpath()
Called 1 time
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    1              0.000053   let short = fnamemodify(getcwd(), ':~:.')
    1              0.000006   if !has('win32unix')
    1              0.000004     let short = pathshorten(short)
    1              0.000001   endif
    1              0.000003   let slash = (s:is_win && !&shellslash) ? '\' : '/'
    1              0.000018   return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)

FUNCTION  <SNR>53_callback()
Called 1 time
Total time:   0.070342
 Self time:   0.000054

count  total (s)   self (s)
                              " Since anything can be done in the sink function, there is no telling that
                              " the change of the working directory was made by &autochdir setting.
                              "
                              " We use the following heuristic to determine whether to restore CWD:
                              " - Always restore the current directory when &autochdir is disabled.
                              "   FIXME This makes it impossible to change directory from inside the sink
                              "   function when &autochdir is not used.
                              " - In case of an error or an interrupt, a:lines will be empty.
                              "   And it will be an array of a single empty string when fzf was finished
                              "   without a match. In these cases, we presume that the change of the
                              "   directory is not expected and should be undone.
    1              0.000007   let popd = has_key(a:dict, 'prev_dir') && (!&autochdir || (empty(a:lines) || len(a:lines) == 1 && empty(a:lines[0])))
    1              0.000000   if popd
                                let w:fzf_dir = [a:dict.prev_dir, a:dict.dir]
                              endif
                            
    1              0.000001   try
    1              0.000002     if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
                                endif
    1              0.000002     if has_key(a:dict, 'sink*')
    1   0.070295   0.000007       call a:dict['sink*'](a:lines)
    1              0.000001     endif
    1              0.000001   catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
                              endtry
                            
                              " We may have opened a new window or tab
    1              0.000001   if popd
                                let w:fzf_dir = [a:dict.prev_dir, a:dict.dir]
                                call s:dopopd()
                              endif

FUNCTION  <SNR>67_LeadingSpaceDisable()
Called 5 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    5              0.000011     if g:indentLine_newVersion
    5              0.000020         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
    5              0.000003         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  120()
Called 4 times
Total time:   0.000797
 Self time:   0.000049

count  total (s)   self (s)
    4   0.000028   0.000016     if !g:NERDTree.ExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
    4   0.000757   0.000021     return self.equals(self.getNerdtree().root)

FUNCTION  122()
Called 1 time
Total time:   0.172263
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000001     let opts = a:0 ? a:1 : {}
    1   0.000066   0.000010     let opener = g:NERDTreeOpener.New(self.path, opts)
    1   0.172193   0.000014     call opener.open(self)

FUNCTION  126()
Called 1 time
Total time:   0.002135
 Self time:   0.000040

count  total (s)   self (s)
    1   0.002110   0.000015     let ln = self.getNerdtree().ui.getLineNum(self)
    1              0.000001     if ln != -1
    1              0.000001         if a:isJump
    1              0.000002             mark '
    1              0.000000         endif
    1              0.000003         call cursor(ln, col("."))
    1              0.000001     else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif

FUNCTION  emmet#util#getcurpos()
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000008   let pos = getpos('.')
    2              0.000008   if mode(0) ==# 'i' && pos[2] > 0
                                let pos[2] -=1
                              endif
    2              0.000003   return pos

FUNCTION  nerdtree#checkForBrowse()
Called 23 times
Total time:   0.000541
 Self time:   0.000541

count  total (s)   self (s)
   23              0.000470     if !isdirectory(a:dir)
   23              0.000034         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>91_CheckCustomTag()
Called 39 times
Total time:   0.000551
 Self time:   0.000551

count  total (s)   self (s)
                              "{{{
                              " Returns 1 if ctag is the tag for a custom element, 0 otherwise.
                              " a:ctag can be "tag" or "/tag" or "<!--" or "-->"
   39              0.000078   let pattern = '\%\(\w\+-\)\+\w\+'
   39              0.000341   if match(a:ctag, pattern) == -1
   39              0.000041     return 0
                              endif
                              if matchstr(a:ctag, '\/\ze.\+') == "/"
                                " closing tag
                                if s:block != 0
                                  " ignore ctag within a block
                                  return 1
                                endif
                                if s:nextrel == 0
                                  let s:curind -= 1
                                else
                                  let s:nextrel -= 1
                                endif
                              else
                                " opening tag
                                if s:block != 0
                                  return 1
                                endif
                                let s:nextrel += 1
                              endif
                              return 1

FUNCTION  41()
Called 195 times
Total time:   0.017596
 Self time:   0.008993

count  total (s)   self (s)
  195              0.000354     let options = a:0 ? a:1 : {}
  195              0.000233     let toReturn = ""
                            
  195              0.000375     if has_key(options, 'format')
    6              0.000013         let format = options['format']
    6              0.000018         if has_key(self, '_strFor' . format)
    6   0.000108   0.000047             exec 'let toReturn = self._strFor' . format . '()'
    6              0.000005         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    6              0.000003     else
  189   0.008379   0.000691         let toReturn = self._str()
  189              0.000128     endif
                            
  195   0.001295   0.000677     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
  195              0.000387     if has_key(options, 'truncateTo')
    2              0.000003         let limit = options['truncateTo']
    2              0.000007         if strdisplaywidth(toReturn) > limit-1
   24              0.000100             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
   22              0.000102                 let toReturn = substitute(toReturn, '^.', '', '')
   22              0.000022             endwhile
    2              0.000013             if len(split(toReturn, '/')) > 1
    2              0.000021                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
    2              0.000002             else
                                            let toReturn = '<' . toReturn
                                        endif
    2              0.000000         endif
    2              0.000001     endif
                            
  195              0.000212     return toReturn

FUNCTION  42()
Called 5 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    5              0.000028     let toReturn = '/' . join(self.pathSegments, '/')
    5              0.000010     if self.isDirectory && toReturn != '/'
    4              0.000009         let toReturn  = toReturn . '/'
    4              0.000003     endif
    5              0.000005     return toReturn

FUNCTION  44()
Called 1 time
Total time:   0.000185
 Self time:   0.000075

count  total (s)   self (s)
                            
                                " Make the path relative to the current working directory, if possible.
    1   0.000152   0.000050     let l:result = fnamemodify(self.str(), ':.')
                            
                                " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                " back, if necessary.
    1   0.000015   0.000007     if nerdtree#runningWindows() && l:result[0] == s:Path.Slash()
                                    let l:result = self.drive . l:result
                                endif
                            
    1              0.000008     let l:result = fnameescape(l:result)
                            
    1              0.000002     if empty(l:result)
                                    let l:result = '.'
                                endif
                            
    1              0.000001     return l:result

FUNCTION  46()
Called 189 times
Total time:   0.007688
 Self time:   0.002920

count  total (s)   self (s)
  189   0.004001   0.000660     let l:separator = s:Path.Slash()
  189              0.000309     let l:leader = l:separator
                            
  189   0.001955   0.000528     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
  189              0.000775     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  47()
Called 21 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   21              0.000175     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  48()
Called 1 time
Total time:   0.000374
 Self time:   0.000282

count  total (s)   self (s)
    1   0.000096   0.000004     let str = self.str()
    7              0.000013     for t in range(tabpagenr('$'))
   13              0.000025         for b in tabpagebuflist(t+1)
    7              0.000190             if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
    7              0.000003         endfor
    6              0.000001     endfor
    1              0.000001     return 0

FUNCTION  49()
Called 21 times
Total time:   0.000262
 Self time:   0.000100

count  total (s)   self (s)
   21   0.000223   0.000061     if !nerdtree#runningWindows()
   21              0.000028         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  emmet#getFilters()
Called 2 times
Total time:   0.000363
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000348   0.000021   let filterstr = emmet#getResource(a:type, 'filters', '')
    2              0.000013   return split(filterstr, '\s*,\s*')

FUNCTION  130()
Called 2 times
Total time:   0.023549
 Self time:   0.000016

count  total (s)   self (s)
    2   0.023547   0.000014     return self._renderToString(0, 0)

FUNCTION  131()
Called 62 times
Total time:   0.045837
 Self time:   0.035958

count  total (s)   self (s)
   62              0.000064     let output = ""
   62              0.000070     if a:drawText ==# 1
                            
   60              0.000167         let treeParts = repeat('  ', a:depth - 1)
                            
   60              0.000075         if !self.path.isDirectory
   24              0.000039             let treeParts = treeParts . '  '
   24              0.000016         endif
                            
   60   0.005871   0.000289         let line = treeParts . self.displayString()
                            
   60              0.000134         let output = output . line . "\n"
   60              0.000039     endif
                            
                                " if the node is an open dir, draw its children
   62              0.000087     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    8   0.007785   0.000039         let childNodesToDraw = self.getVisibleChildren()
                            
    8   0.007528   0.000039         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
   68              0.000064             for i in childNodesToDraw
   60              0.000198                 let output = output . i._renderToString(a:depth + 1, 1)
   60              0.000044             endfor
    8              0.000004         endif
    8              0.000007     endif
                            
   62              0.000063     return output

FUNCTION  138()
Called 36 times
Total time:   0.005060
 Self time:   0.001279

count  total (s)   self (s)
   36              0.000040     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
   36              0.000046     let l:label = ''
   36   0.003328   0.000128     let l:cascade = self.getCascade()
   72              0.000097     for l:dirNode in l:cascade
   36   0.000361   0.000162         let l:label .= l:dirNode.path.displayString()
   36              0.000022     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
   36              0.000063     if l:cascade[-1].isOpen
    6              0.000011         let l:symbol = g:NERDTreeDirArrowCollapsible
    6              0.000005     else
   30              0.000045         let l:symbol = g:NERDTreeDirArrowExpandable
   30              0.000014     endif
                            
   36   0.000540   0.000158     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
   36              0.000117     let l:result = l:symbol . ' ' . l:flags . l:label
   36              0.000036     return l:result

FUNCTION  139()
Called 35 times
Total time:   0.029676
 Self time:   0.006232

count  total (s)   self (s)
   35   0.006598   0.000117     if a:path.equals(self.path)
    3              0.000003         return self
                                endif
   32   0.005890   0.000245     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   24              0.000023         return {}
                                endif
                            
    8              0.000008     if self.path.isDirectory
   33              0.000044         for i in self.children
   33   0.000669   0.000102             let retVal = i.findNode(a:path)
   33              0.000044             if retVal != {}
    8              0.000008                 return retVal
                                        endif
   25              0.000017         endfor
                                endif
                                return {}

FUNCTION  <SNR>53_execute_term()
Called 1 time
Total time:   0.043440
 Self time:   0.004480

count  total (s)   self (s)
    1              0.000007   let winrest = winrestcmd()
    1              0.000003   let pbuf = bufnr('')
    1   0.011776   0.000023   let [ppos, winopts] = s:split(a:dict)
    1   0.000021   0.000006   call s:use_sh()
    1              0.000002   let b:fzf = a:dict
    1              0.000011   let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps, 'winopts': winopts, 'winrest': winrest, 'lines': &lines, 'columns': &columns, 'command': a:command }
    1              0.000003   function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
    1              0.000001   function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  execute 'tabnext' self.ppos.tab
                                  execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                let lines = s:collect(self.temps)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                              endfunction
                            
    1              0.000000   try
    1   0.000021   0.000004     if s:present(a:dict, 'dir')
                                  execute 'lcd' s:escape(a:dict.dir)
                                endif
    1              0.000001     if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
                                else
    1              0.000001       let command = a:command
    1              0.000001     endif
    1              0.000003     let command .= s:term_marker
    1              0.000003     if has('nvim')
                                  call termopen(command, fzf)
                                else
    1   0.010601   0.004095       let fzf.buf = term_start([&shell, &shellcmdflag, command], {'curwin': 1, 'exit_cb': function(fzf.on_exit)})
    1              0.000051       if !has('patch-8.0.1261') && !has('nvim') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
    1              0.000001     endif
    1              0.000002   finally
    1   0.000144   0.000068     if s:present(a:dict, 'dir')
                                  lcd -
                                endif
    1              0.000002   endtry
    1   0.000704   0.000071   setlocal nospell bufhidden=wipe nobuflisted nonumber
    1   0.019978   0.000018   setf fzf
    1              0.000005   startinsert
    1              0.000003   return []

FUNCTION  HtmlIndent_FindStartTag()
Called 4 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
                              "{{{
                              " The cursor must be on or before a closing tag.
                              " If found, positions the cursor at the match and returns the line number.
                              " Otherwise returns 0.
    4              0.000063   let tagname = matchstr(getline('.')[col('.') - 1:], '</\zs' . s:tagname . '\ze')
    4              0.000062   let start_lnum = searchpair('<' . tagname . '\>', '', '</' . tagname . '\>', 'bW')
    4              0.000006   if start_lnum > 0
    4              0.000004     return start_lnum
                              endif
                              return 0

FUNCTION  lightline#link()
Called 1422 times
Total time:   0.072314
 Self time:   0.072314

count  total (s)   self (s)
 1422              0.017638   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
 1422              0.004521   if s:mode == mode
 1376              0.002145     return ''
                              endif
   46              0.000105   let s:mode = mode
   46              0.000161   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
                              endif
   46              0.000812   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
  138              0.000565   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
  506              0.001461     for [i, t] in map(range(0, l), '[v:val, 0]') + types
  414              0.000457       if i != l
  322              0.005894         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
  322              0.000229       endif
 2300              0.005871       for [j, s] in map(range(0, l), '[v:val, 0]') + types
 1886              0.003371         if i + 1 == j || t || s && i != l
  874              0.015076           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
  874              0.000609         endif
 1886              0.001227       endfor
  414              0.000262     endfor
   92              0.000057   endfor
   46              0.000623   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
   46              0.000065   return ''

FUNCTION  <SNR>44_ExtraMappings()
Called 8 times
Total time:   0.002174
 Self time:   0.001539

count  total (s)   self (s)
                              " If pair is empty, delete both delimiters:
    8              0.000069   inoremap <silent> <Plug>delimitMateBS <C-R>=delimitMate#BS()<CR>
    8              0.000114   if !hasmapto('<Plug>delimitMateBS','i')
    8              0.000066     if empty(maparg('<BS>', 'i'))
                                  silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
                                endif
    8              0.000055     if empty(maparg('<C-H>', 'i'))
                                  silent! imap <unique> <buffer> <C-h> <Plug>delimitMateBS
                                endif
    8              0.000004   endif
                              " If pair is empty, delete closing delimiter:
    8              0.000087   inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<Del>" : "\<S-BS>"
    8              0.000129   if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
    8              0.000064     silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
    8              0.000005   endif
                              " Expand return if inside an empty pair:
    8              0.000082   inoremap <expr><silent> <Plug>delimitMateCR <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandReturn()\<CR>"
    8   0.000270   0.000048   if s:get('expand_cr') && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
                                silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
                              endif
                              " Expand space if inside an empty pair:
    8              0.000084   inoremap <expr><silent> <Plug>delimitMateSpace <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandSpace()\<CR>"
    8   0.000242   0.000040   if s:get('expand_space') && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                                silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
                              endif
                              " Jump over any delimiter:
    8              0.000084   inoremap <expr><silent> <Plug>delimitMateS-Tab <SID>TriggerAbb()."\<C-R>=delimitMate#JumpAny()\<CR>"
    8   0.000375   0.000164   if s:get('tab2exit') && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
                                silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
                              endif
                              " Jump over next delimiters
    8              0.000112   inoremap <expr><buffer> <Plug>delimitMateJumpMany <SID>TriggerAbb()."\<C-R>=delimitMate#JumpMany()\<CR>"
    8              0.000135   if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
    8              0.000057     imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
    8              0.000004   endif

FUNCTION  140()
Called 38 times
Total time:   0.004139
 Self time:   0.000191

count  total (s)   self (s)
   38   0.004077   0.000129     if !self.isCascadable()
   38              0.000044         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  148()
Called 54 times
Total time:   0.018756
 Self time:   0.002379

count  total (s)   self (s)
   54              0.000067     let toReturn = []
  222              0.000327     for i in self.children
  168   0.017351   0.000974         if i.path.ignore(self.getNerdtree()) ==# 0
  148              0.000308             call add(toReturn, i)
  148              0.000092         endif
  168              0.000100     endfor
   54              0.000047     return toReturn

FUNCTION  emmet#unescapeDollarExpr()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000012   return substitute(a:expand, '\\\$', '$', 'g')

FUNCTION  <SNR>53_validate_layout()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000006   for key in keys(a:layout)
    1              0.000003     if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s', key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
                                endif
    1              0.000000   endfor
    1              0.000002   return a:layout

FUNCTION  150()
Called 46 times
Total time:   0.011437
 Self time:   0.000427

count  total (s)   self (s)
   46              0.000069     if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
                                endif
                            
   46   0.011165   0.000155     let c = self.getVisibleChildren()
   46              0.000098     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  153()
Called 4 times
Total time:   0.001705
 Self time:   0.000182

count  total (s)   self (s)
    4              0.000008     let l:options = a:0 ? a:1 : {}
                            
                                " If special options were specified, process them and return.
    4              0.000013     if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
                                endif
                            
                                " Open any ancestors of this node that render within the same cascade.
    4              0.000007     let l:parent = self.parent
    4   0.000609   0.000025     while !empty(l:parent) && !l:parent.isRoot()
    2   0.000958   0.000019         if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
                                    else
    2              0.000002             break
                                    endif
                                endwhile
                            
    4              0.000011     let self.isOpen = 1
                            
    4              0.000007     let l:numChildrenCached = 0
    4              0.000008     if empty(self.children)
                                    let l:numChildrenCached = self._initChildren(0)
                                endif
                            
    4              0.000004     return l:numChildrenCached

FUNCTION  <SNR>78_OnFileReadyToParse()
Called 71 times
Total time:   0.115193
 Self time:   0.110282

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
   71              0.000240   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
   71   0.005315   0.000404   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
   60              0.107084     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
   60              0.000635     call timer_stop( s:pollers.file_parse_response.id )
   60              0.001062     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
   60              0.000120   endif

FUNCTION  <SNR>78_Pyeval()
Called 1226 times
Total time:   0.343709
 Self time:   0.343709

count  total (s)   self (s)
 1226              0.002812   if s:using_python3
 1226              0.339103     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  71()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000007     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
    2              0.000002     return s:keyMaps

FUNCTION  72()
Called 1 time
Total time:   0.000049
 Self time:   0.000043

count  total (s)   self (s)
    8   0.000017   0.000011     for i in s:KeyMap.All()
    8              0.000016          if i.key ==# a:key && i.scope ==# a:scope
    1              0.000001             return i
                                    endif
    7              0.000005     endfor
                                return {}

FUNCTION  73()
Called 1 time
Total time:   0.001814
 Self time:   0.000291

count  total (s)   self (s)
   46   0.000089   0.000082     for i in s:KeyMap.All()
   45   0.001672   0.000156         call i.bind()
   45              0.000041     endfor

FUNCTION  77()
Called 1 time
Total time:   0.181957
 Self time:   0.000109

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    1   0.000016   0.000008     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
    1   0.009463   0.000049     let node = g:NERDTreeFileNode.GetSelected()
    1              0.000003     if !empty(node)
                            
                                    "try file node
    1              0.000001         if !node.path.isDirectory
    1   0.000057   0.000008             let km = s:KeyMap.FindFor(a:key, "FileNode")
    1              0.000001             if !empty(km)
    1   0.172403   0.000026                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "DirNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, "Node")
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  <SNR>67_Setup()
Called 7 times
Total time:   0.004514
 Self time:   0.000241

count  total (s)   self (s)
    7              0.000017     if &filetype ==# ""
    2   0.000278   0.000010         call s:InitColor()
    2              0.000002     endif
                            
    7   0.000249   0.000046     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
    7   0.003644   0.000043         call s:IndentLinesEnable()
    7              0.000005     endif
                            
    7   0.000262   0.000061     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif

FUNCTION  <SNR>78_OnCursorMovedNormalMode()
Called 300 times
Total time:   0.054146
 Self time:   0.034613

count  total (s)   self (s)
  300   0.021415   0.001882   if !s:AllowedToCompleteInCurrentBuffer()
    4              0.000004     return
                              endif
                            
  296              0.031793   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  rpc#start()
Called 1 time
Total time:   0.005004
 Self time:   0.005004

count  total (s)   self (s)
    1              0.000003 	if has('nvim')
                            		return jobstart(a:000, {'rpc': v:true, 'on_stderr': function('s:OnError')})
                            	else
    1              0.004977 		return job_start(a:000, {'out_cb': function('s:OnCall'), 'err_cb': function('s:OnError2')})
                            	end

FUNCTION  168()
Called 2 times
Total time:   0.000044
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000002     if self._keepopen
                                    return
                                endif
                            
    2              0.000006     if (a:newtab && self._where == 't') || !a:newtab
    1   0.000027   0.000021         call g:NERDTree.CloseIfQuitOnOpen()
    1              0.000001     endif

FUNCTION  <SNR>44_Unmap()
Called 5 times
Total time:   0.004739
 Self time:   0.004027

count  total (s)   self (s)
    5   0.001446   0.000734   let imaps = s:get('right_delims', []) + s:get('left_delims', []) + s:get('quotes_list', []) + s:get('apostrophes_list', []) + ['<BS>', '<C-h>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                            
  167              0.000168   for map in imaps
  162              0.001620     if maparg(map, "i") =~# '^<Plug>delimitMate'
   57              0.000100       if map == '|'
                                    let map = '<Bar>'
                                  endif
   57              0.000602       exec 'silent! iunmap <buffer> ' . map
   57              0.000038     endif
  162              0.000108   endfor
    5              0.000040   silent! doautocmd <nomodeline> User delimitMate_unmap
    5              0.000012   let b:delimitMate_enabled = 0

FUNCTION  <SNR>78_Complete()
Called 406 times
Total time:   0.012350
 Self time:   0.009230

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
  406              0.002573   if s:completion.start_column > col( '.' ) || empty( s:completion.candidates )
  190   0.002257   0.000956     call s:CloseCompletionMenu()
  190              0.000175   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects the
                                " first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim to
                                " deselect the first candidate and in turn preserve the user's current text
                                " until he explicitly chooses to replace it with a completion.
  216   0.003441   0.001622     call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
  216              0.000184   endif

FUNCTION  emmet#lang#exists()
Called 15 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
   15              0.000041   if len(a:type) == 0
                                return 0
                              elseif has_key(s:exists, a:type)
   15              0.000031     return s:exists[a:type]
                              endif
                              let s:exists[a:type] = len(globpath(&rtp, 'autoload/emmet/lang/'.a:type.'.vim')) > 0
                              return s:exists[a:type]

FUNCTION  170()
Called 1 time
Total time:   0.014634
 Self time:   0.000041

count  total (s)   self (s)
    1   0.000008   0.000005     if b:NERDTree.isWinTree()
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
    1   0.000014   0.000005         call self._checkToCloseTree(1)
                            
    1              0.000001         if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
    1   0.014551   0.000005             call self._previousWindow()
    1              0.000001         endif
                            
    1   0.000041   0.000006         call self._checkToCloseTree(0)
    1              0.000001     endif

FUNCTION  171()
Called 2 times
Total time:   0.011312
 Self time:   0.000101

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    2              0.000004     if winnr("$") ==# 1
                                    return 0
                                endif
                            
    2              0.000004     let oldwinnr = winnr()
    2   0.006386   0.000021     call nerdtree#exec(a:winnumber . "wincmd p")
    2              0.000017     let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
    2              0.000005     let modified = &modified
    2   0.004861   0.000015     call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    2              0.000002     if specialWindow
                                    return 0
                                endif
                            
    2              0.000002     if &hidden
                                    return 1
                                endif
                            
    2              0.000007     return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  172()
Called 1 time
Total time:   0.000056
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000015     let l:newOpener = copy(self)
                            
    1   0.000009   0.000006     let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    1              0.000002     let l:newOpener._nerdtree = b:NERDTree
    1              0.000002     let l:newOpener._path = a:path
    1              0.000003     let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
    1   0.000006   0.000003     let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
    1              0.000004     let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                            
    1   0.000010   0.000004     call l:newOpener._saveCursorPos()
                            
    1              0.000001     return l:newOpener

FUNCTION  175()
Called 1 time
Total time:   0.172179
 Self time:   0.000025

count  total (s)   self (s)
                            
    1              0.000001     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                    return
                                endif
                            
    1   0.172171   0.000017     call self._openFile()

FUNCTION  176()
Called 1 time
Total time:   0.172154
 Self time:   0.000045

count  total (s)   self (s)
                            
    1   0.000924   0.000006     if self._reuseWindow()
                                    return
                                endif
                            
    1   0.014642   0.000008     call self._gotoTargetWin()
                            
    1              0.000001     if self._stay
                                    silent call self._path.edit()
                                    call self._restoreCursorPos()
                                    return
                                endif
                            
    1   0.156578   0.000021     call self._path.edit()

FUNCTION  178()
Called 1 time
Total time:   0.014546
 Self time:   0.000044

count  total (s)   self (s)
    1   0.005899   0.000009     if !self._isWindowUsable(winnr("#")) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
    1              0.000001         try
    1   0.005430   0.000008             if !self._isWindowUsable(winnr("#"))
                                            call nerdtree#exec(self._firstUsableWindow() . "wincmd w")
                                        else
    1   0.003195   0.000005                 call nerdtree#exec('wincmd p')
    1              0.000001             endif
    1              0.000001         catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
    1              0.000000     endif

FUNCTION  <SNR>78_InsideCommentOrString()
Called 214 times
Total time:   0.071274
 Self time:   0.071274

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
  214              0.068142   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
  214              0.000817   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
  214              0.000515   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
  214              0.000183   return 0

FUNCTION  <SNR>78_SendKeys()
Called 307 times
Total time:   0.002634
 Self time:   0.002634

count  total (s)   self (s)
                              " By default keys are added to the end of the typeahead buffer. If there are
                              " already keys in the buffer, they will be processed first and may change the
                              " state that our keys combination was sent for (e.g. <C-X><C-U><C-P> in normal
                              " mode instead of insert mode or <C-e> outside of completion mode). We avoid
                              " that by inserting the keys at the start of the typeahead buffer with the 'i'
                              " option. Also, we don't want the keys to be remapped to something else so we
                              " add the 'n' option.
  307              0.001436   call feedkeys( a:keys, 'in' )

FUNCTION  emmet#util#unique()
Called 3 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    3              0.000004   let m = {}
    3              0.000003   let r = []
   10              0.000012   for i in a:arr
    7              0.000014     if !has_key(m, i)
    6              0.000011       let m[i] = 1
    6              0.000015       call add(r, i)
    6              0.000001     endif
    7              0.000006   endfor
    3              0.000003   return r

FUNCTION  <SNR>53_exit_handler()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002   if a:code == 130
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
    1              0.000001   return 1

FUNCTION  ResetPhpOptions()
Called 2 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    2              0.000028     if ! b:optionsset && &filetype =~ "php"
    2              0.000005 	if b:PHP_autoformatcomment
                            
    2              0.000020 	    setlocal comments=s1:/*,mb:*,ex:*/,://,:#
                            
    2              0.000014 	    setlocal formatoptions-=t
    2              0.000007 	    setlocal formatoptions+=q
    2              0.000006 	    setlocal formatoptions+=r
    2              0.000007 	    setlocal formatoptions+=o
    2              0.000006 	    setlocal formatoptions+=c
    2              0.000007 	    setlocal formatoptions+=b
    2              0.000002 	endif
    2              0.000004 	let b:optionsset = 1
    2              0.000002     endif

FUNCTION  <SNR>53_use_sh()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000009   let [shell, shellslash] = [&shell, &shellslash]
    2              0.000004   if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                              else
    2              0.000012     set shell=sh
    2              0.000001   endif
    2              0.000004   return [shell, shellslash]

FUNCTION  emmet#getExpandos()
Called 2 times
Total time:   0.001043
 Self time:   0.000036

count  total (s)   self (s)
    2   0.001027   0.000020   let expandos = emmet#getResource(a:type, 'expandos', {})
    2              0.000006   if has_key(expandos, a:key)
    1              0.000002     return expandos[a:key]
                              endif
    1              0.000002   return a:key

FUNCTION  emmet#getDollarExprs()
Called 2 times
Total time:   0.000760
 Self time:   0.000337

count  total (s)   self (s)
    2              0.000003   let expand = a:expand
    2              0.000003   let dollar_list = []
    2              0.000005   let dollar_reg = '\%(\\\)\@<!\${\(\([^{}]\|\%(\\\)\@\<=[{}]\)\{}\)}'
    4              0.000006   while 1
    4              0.000091     let matcharr = matchlist(expand, dollar_reg)
    4              0.000012     if len(matcharr) > 0
    2              0.000006       let key = get(matcharr, 1)
    2              0.000014       if key !~# '^\d\+:'
    2              0.000014         let key = substitute(key, '\\{', '{', 'g')
    2              0.000011         let key = substitute(key, '\\}', '}', 'g')
    2   0.000441   0.000018         let value = emmet#getDollarValueByKey(key)
    2              0.000008         if type(value) ==# type('')
                                      let expr = get(matcharr, 0)
                                      call add(dollar_list, {'expr': expr, 'value': value})
                                    endif
    2              0.000002       endif
    2              0.000002     else
    2              0.000002       break
                                endif
    2              0.000051     let expand = substitute(expand, dollar_reg, '', '')
    2              0.000002   endwhile
    2              0.000003   return dollar_list

FUNCTION  <SNR>53_getpos()
Called 4 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    4              0.000054   return {'tab': tabpagenr(), 'win': winnr(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}

FUNCTION  <SNR>78_OnBufferUnload()
Called 8 times
Total time:   0.003365
 Self time:   0.003048

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
    8              0.000059   let buffer_number = str2nr( expand( '<abuf>' ) )
    8   0.000370   0.000053   if !s:AllowedToCompleteInBuffer( buffer_number )
    3              0.000003     return
                              endif
                            
    5              0.002896   exec s:python_command "ycm_state.OnBufferUnload( " . buffer_number . " )"

FUNCTION  180()
Called 1 time
Total time:   0.000918
 Self time:   0.000452

count  total (s)   self (s)
    1              0.000002     if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
    1   0.000503   0.000411     let winnr = bufwinnr('^' . self._path.str() . '$')
    1              0.000002     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
    1              0.000002     if self._reuse == 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
    1   0.000381   0.000007     let tabnr = self._path.tabnr()
    1              0.000001     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec('normal! ' . tabnr . 'gt')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
                                endif
                            
    1              0.000000     return 0

FUNCTION  181()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003     let self._bufnr = bufnr("")
    1              0.000003     let self._tabnr = tabpagenr()

FUNCTION  182()
Called 1 time
Total time:   0.001943
 Self time:   0.000129

count  total (s)   self (s)
                                "make <cr> do the same as the activate node mapping
    1              0.000072     nnoremap <silent> <buffer> <cr> :call nerdtree#ui_glue#invokeKeyMap(g:NERDTreeMapActivateNode)<cr>
                            
    1   0.001822   0.000008     call g:NERDTreeKeyMap.BindAll()
                            
    1              0.000006     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
    1              0.000006     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
    1              0.000008     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
    1              0.000005     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
    1              0.000005     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
    1              0.000005     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
    1              0.000005     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
    1              0.000002     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()

FUNCTION  <SNR>53_fzf_tempname()
Called 1 time
Total time:   0.000010
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000010   0.000005   return s:fzf_call('tempname')

FUNCTION  <SNR>78_IdentifierFinishedOperations()
Called 214 times
Total time:   0.034552
 Self time:   0.014438

count  total (s)   self (s)
  214   0.021284   0.001170   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
  189              0.000286     return
                              endif
   25              0.012422   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
   25              0.000129   let s:force_semantic = 0
   25              0.000091   let s:completion = s:default_completion

FUNCTION  <SNR>73_flatten_twice()
Called 106 times
Total time:   0.003295
 Self time:   0.003295

count  total (s)   self (s)
  106              0.000162   let ys = []
  335              0.000417   for xs in a:xss
  633              0.000562     for x in xs
  404              0.000550       let ys += x
  404              0.000298     endfor
  229              0.000149   endfor
  106              0.000117   return ys

FUNCTION  fzf#shellescape()
Called 4 times
Total time:   0.000146
 Self time:   0.000121

count  total (s)   self (s)
    4              0.000023   let shell = get(a:000, 0, &shell)
    4              0.000026   if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
    4   0.000057   0.000032   return s:fzf_call('shellescape', a:arg)

FUNCTION  192()
Called 1 time
Total time:   0.027315
 Self time:   0.000429

count  total (s)   self (s)
                                "create the nerd tree window
    1              0.000005     let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
    1              0.000002     let splitSize = g:NERDTreeWinSize
                            
    1   0.000224   0.000005     if !g:NERDTree.ExistsForTab()
                                    let t:NERDTreeBufName = self._nextBufferName()
                                    silent! exec splitLocation . 'vertical ' . splitSize . ' new'
                                    silent! exec "edit " . t:NERDTreeBufName
                                else
    1   0.004033   0.000124         silent! exec splitLocation . 'vertical ' . splitSize . ' split'
    1   0.003609   0.000260         silent! exec "buffer " . t:NERDTreeBufName
    1              0.000001     endif
                            
    1              0.000009     setlocal winfixwidth
    1   0.019418   0.000009     call self._setCommonBufOptions()

FUNCTION  194()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000025     let newCreator = copy(self)
    1              0.000001     return newCreator

FUNCTION  199()
Called 1 time
Total time:   0.019409
 Self time:   0.000074

count  total (s)   self (s)
                                "throwaway buffer options
    1              0.000003     setlocal noswapfile
    1              0.000004     setlocal buftype=nofile
    1              0.000007     setlocal bufhidden=hide
    1              0.000003     setlocal nowrap
    1              0.000006     setlocal foldcolumn=0
    1              0.000003     setlocal foldmethod=manual
    1              0.000003     setlocal nofoldenable
    1              0.000002     setlocal nobuflisted
    1              0.000002     setlocal nospell
    1              0.000002     if g:NERDTreeShowLineNumbers
                                    setlocal nu
                                else
    1              0.000004         setlocal nonu
    1              0.000002         if v:version >= 703
    1              0.000003             setlocal nornu
    1              0.000001         endif
    1              0.000001     endif
                            
    1              0.000001     iabc <buffer>
                            
    1              0.000001     if g:NERDTreeHighlightCursorline
    1              0.000003         setlocal cursorline
    1              0.000001     endif
                            
    1   0.000015   0.000006     call self._setupStatusline()
    1   0.001948   0.000005     call self._bindMappings()
    1   0.017389   0.000006     setlocal filetype=nerdtree

FUNCTION  emmet#lang#type()
Called 7 times
Total time:   0.000238
 Self time:   0.000164

count  total (s)   self (s)
    7              0.000007   let type = a:type
    7              0.000010   let base = type
    7   0.000051   0.000037   let settings = emmet#getSettings()
    7              0.000016   while base != ''
    7              0.000038     for b in split(base, '\.')
    7   0.000091   0.000031       if emmet#lang#exists(b)
    7              0.000007         return b
                                  endif
                                  if has_key(settings, b) && has_key(settings[b], 'extends')
                                    let base = settings[b].extends
                                    break
                                  else
                                    let base = ''
                                  endif
                                endfor
                              endwhile
                              return 'html'

FUNCTION  phpcd#GetCallChainReturnType()
Called 2 times
Total time:   0.000233
 Self time:   0.000148

count  total (s)   self (s)
                            	" Tries to get the classname and namespace for a chained method call like:
                            	"	$this->foo()->bar()->baz()->
                            
    2              0.000007 	if a:class_candidate_namespace[0] == '\'
                            		let imports = {}
                            	else
    2              0.000003 		let imports = a:imports
    2              0.000002 	endif
                            
    2              0.000004 	let classname_candidate = a:classname_candidate " {{{
    2              0.000005 	let class_candidate_namespace = a:class_candidate_namespace
    2              0.000004 	let methodstack = a:methodstack
    2              0.000002 	let unknown_result = ''
    2              0.000022 	let prev_method_is_array = (methodstack[0] =~ '\v^[^([]+\[' ? 1 : 0)
    2              0.000012 	let classname_candidate_is_array = (classname_candidate =~ '\[\]$' ? 1 : 0) " }}}
                            
    2              0.000003 	if prev_method_is_array " {{{
                            		if classname_candidate_is_array
                            			let classname_candidate = substitute(classname_candidate, '\[\]$', '', '')
                            		else
                            			return unknown_result
                            		endif
                            	endif " }}}
                            
    2              0.000004 	if (len(methodstack) == 1) " {{{
    2   0.000089   0.000026 		let [classname_candidate, class_candidate_namespace] = phpcd#ExpandClassName(classname_candidate, class_candidate_namespace, imports)
    2   0.000041   0.000019 		let return_type = s:GetFullName(class_candidate_namespace, classname_candidate)
                            
    2              0.000002 		return return_type
                            	endif " }}}
                            
                            	call remove(methodstack, 0)
                            	let [classname_candidate, class_candidate_namespace] = phpcd#ExpandClassName(classname_candidate, class_candidate_namespace, imports)
                            	let full_classname = s:GetFullName(class_candidate_namespace, classname_candidate)
                            
                            	if methodstack[0] =~ '('
                            		let method = matchstr(methodstack[0], '\v^\$*\zs[^[(]+\ze')
                            		let return_types = rpc#request(g:phpcd_channel_id, 'functype', full_classname, method, expand('%:p'))
                            	else
                            		let prop = matchstr(methodstack[0], '\v^\$*\zs[^[(]+\ze')
                            		let return_types = rpc#request(g:phpcd_channel_id, 'proptype', full_classname, prop, expand('%:p'))
                            	endif
                            
                            	if len(return_types) > 0
                            		let return_type = phpcd#SelectOne(return_types)
                            		return phpcd#GetCallChainReturnType(return_type, '', imports, methodstack)
                            	endif
                            
                            	return unknown_result

FUNCTION  <SNR>53_evaluate_opts()
Called 3 times
Total time:   0.000192
 Self time:   0.000069

count  total (s)   self (s)
    3   0.000190   0.000067   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  phpcd#GetRoot()
Called 1 time
Total time:   0.000999
 Self time:   0.000999

count  total (s)   self (s)
    1              0.000084 	let pwd = expand("%:p:h")
                            
    1              0.000008 	if pwd[0] != '/' " for editing non exists dir file
                            		let pwd = getcwd()
                            	endif
                            
    1              0.000003 	let root = pwd
                            
    1              0.000005 	if g:phpcd_root != '/' && stridx(root, g:phpcd_root) == 0
                            		return g:phpcd_root
                            	endif
                            
   10              0.000024 	while root != "/"
    9              0.000596 		if (filereadable(root.'/.phpcd.vim'))
                            			return root
                            		endif
    9              0.000058 		let root = fnamemodify(root, ":h")
    9              0.000012 	endwhile
                            
    1              0.000003 	let root = pwd
    4              0.000009 	while root != "/"
    4              0.000093 		if (filereadable(root . "/vendor/autoload.php"))
    1              0.000003 			return root
                            		endif
    3              0.000016 		let root = fnamemodify(root, ":h")
    3              0.000003 	endwhile
                            
                            	return root

FUNCTION  <SNR>53_collect()
Called 1 time
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
    1              0.000001   try
    1              0.000076     return filereadable(a:temps.result) ? readfile(a:temps.result) : []
                              finally
    2              0.000007     for tf in values(a:temps)
    1              0.000112       silent! call delete(tf)
    1              0.000002     endfor
    1              0.000001   endtry

FUNCTION  <SNR>53_upgrade()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000005   let copy = copy(a:dict)
    1              0.000003   if has_key(copy, 'tmux')
                                let copy.down = remove(copy, 'tmux')
                              endif
    1              0.000002   if has_key(copy, 'tmux_height')
                                let copy.down = remove(copy, 'tmux_height')
                              endif
    1              0.000002   if has_key(copy, 'tmux_width')
                                let copy.right = remove(copy, 'tmux_width')
                              endif
    1              0.000001   return copy

FUNCTION  <SNR>72_HighlightEnclosingTags()
Called 367 times
Total time:   0.208076
 Self time:   0.028052

count  total (s)   self (s)
  367   0.184180   0.004156   let [ opening_tag_line, opening_tag_column, closing_tag_line, closing_tag_column ] = s:GetEnclosingTagLocations()
  367              0.001655   let first_window_line = line( 'w0' )
                            
  367              0.000873   if opening_tag_line < first_window_line
   65              0.000062     return
                              endif
                            
  302              0.018591   exe '2match ' . s:match_group . ' /' . '\(\%' . opening_tag_line . 'l\%' . opening_tag_column . 'c<\/\?\_s*\zs.\{-}\ze[ >\/\n]\)\|' . '\(\%' . closing_tag_line . 'l\%' . closing_tag_column . 'c<\/\?\_s*\zs.\{-}\ze[ >\/]\)' . '/'
  302              0.000846   let w:tags_highlighted = 1

FUNCTION  nerdtree#runningWindows()
Called 467 times
Total time:   0.003635
 Self time:   0.003635

count  total (s)   self (s)
  467              0.003500     return has("win16") || has("win32") || has("win64")

FUNCTION  lightline#statusline()
Called 53 times
Total time:   0.069315
 Self time:   0.001270

count  total (s)   self (s)
   53              0.000179   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
                              endif
   53   0.068937   0.000892   return s:line(0, a:inactive)

FUNCTION  <SNR>78_UpdateMatches()
Called 48 times
Total time:   0.032408
 Self time:   0.032408

count  total (s)   self (s)
   48              0.032355   exec s:python_command "ycm_state.UpdateMatches()"

FUNCTION  StripEndlineComments()
Called 7 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    7              0.000119     return substitute(a:line,"\\(//\\|#\\)\\(\\(\\([^\"']*\\([\"']\\)[^\"']*\\5\\)\\+[^\"']*$\\)\\|\\([^\"']*$\\)\\)",'','')

FUNCTION  emmet#expandAbbr()
Called 2 times
Total time:   0.028820
 Self time:   0.001582

count  total (s)   self (s)
    2   0.000305   0.000027   let type = emmet#getFileType()
    2   0.000288   0.000025   let rtype = emmet#lang#type(emmet#getFileType(1))
    2   0.000104   0.000017   let indent = emmet#getIndentation(type)
    2              0.000003   let expand = ''
    2              0.000003   let line = ''
    2              0.000003   let part = ''
    2              0.000002   let rest = ''
                            
    2   0.000378   0.000015   let filters = emmet#getFilters(type)
    2              0.000006   if len(filters) ==# 0
    2              0.000004     let filters = ['html']
    2              0.000002   endif
                            
    2              0.000003   if a:mode ==# 2
                                let leader = substitute(input('Tag: ', ''), '^\s*\(.*\)\s*$', '\1', 'g')
                                if len(leader) ==# 0
                                  return ''
                                endif
                                if leader =~# s:filtermx
                                  let filters = map(split(matchstr(leader, s:filtermx)[1:], '\s*[^\\]\zs,\s*'), 'substitute(v:val, "\\\\\\\\zs.\\\\ze", "&", "g")')
                                  let leader = substitute(leader, s:filtermx, '', '')
                                endif
                                if leader =~# '\*'
                                  let query = substitute(leader, '*', '*' . (a:lastline - a:firstline + 1), '')
                                  if query !~# '}\s*$' && query !~# '\$#'
                                    let query .= '>{$#}'
                                  endif
                                  if emmet#useFilter(filters, '/')
                                    let spl = emmet#splitFilterArg(filters)
                                    let fline = getline(a:firstline)
                                    let query = substitute(query, '>\{0,1}{\$#}\s*$', '{\\$column\\$}*' . len(split(fline, spl)), '')
                                  else
                                    let spl = ''
                                  endif
                                  let items = emmet#parseIntoTree(query, type).child
                                  let itemno = 0
                                  for item in items
                                    let inner = emmet#toString(item, type, 0, filters, 0, indent)
                                    let inner = substitute(inner, '\$#', '$line'.(itemno*(a:lastline - a:firstline + 1)/len(items)+1).'$', 'g')
                                    let expand .= inner
                                    let itemno = itemno + 1
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  let line = getline(a:firstline)
                                  let part = substitute(line, '^\s*', '', '')
                                  for n in range(a:firstline, a:lastline)
                                    let lline = getline(n)
                                    let lpart = substitute(lline, '^\s\+', '', '')
                                    if emmet#useFilter(filters, 't')
                                      let lpart = substitute(lpart, '^[0-9.-]\+\s\+', '', '')
                                      let lpart = substitute(lpart, '\s\+$', '', '')
                                    endif
                                    if emmet#useFilter(filters, '/')
                                      for column in split(lpart, spl)
                                        let expand = substitute(expand, '\$column\$', '\=column', '')
                                      endfor
                                    else
                                      let expand = substitute(expand, '\$line'.(n-a:firstline+1).'\$', '\=lpart', 'g')
                                    endif
                                  endfor
                                  let expand = substitute(expand, '\$line\d*\$', '', 'g')
                                  let expand = substitute(expand, '\$column\$', '', 'g')
                                  let content = join(getline(a:firstline, a:lastline), "\n")
                                  if stridx(expand, '$#') < len(expand)-2
                                    let expand = substitute(expand, '^\(.*\)\$#\s*$', '\1', '')
                                  endif
                                  let expand = substitute(expand, '\$#', '\=content', 'g')
                                else
                                  let str = ''
                                  if visualmode() ==# 'V'
                                    let line = getline(a:firstline)
                                    let lspaces = matchstr(line, '^\s*', '', '')
                                    let part = substitute(line, '^\s*', '', '')
                                    for n in range(a:firstline, a:lastline)
                                      if len(leader) > 0
                                        let line = getline(a:firstline)
                                        let spaces = matchstr(line, '^\s*', '', '')
                                        if len(spaces) >= len(lspaces)
                                          let str .= indent . getline(n)[len(lspaces):] . "\n"
                                        else
                                          let str .= getline(n) . "\n"
                                        endif
                                      else
                                        let lpart = substitute(getline(n), '^\s*', '', '')
                                        let str .= lpart . "\n"
                                      endif
                                    endfor
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  else
                                    let save_regcont = @"
                                    let save_regtype = getregtype('"')
                                    silent! normal! gvygv
                                    let str = @"
                                    call setreg('"', save_regcont, save_regtype)
                                    if stridx(leader, '{$#}') ==# -1
                                      let leader .= '{$#}'
                                    endif
                                    let items = emmet#parseIntoTree(leader, type).child
                                  endif
                                  for item in items
                                    let expand .= emmet#toString(item, type, 0, filters, 0, '')
                                  endfor
                                  if emmet#useFilter(filters, 'e')
                                    let expand = substitute(expand, '&', '\&amp;', 'g')
                                    let expand = substitute(expand, '<', '\&lt;', 'g')
                                    let expand = substitute(expand, '>', '\&gt;', 'g')
                                  endif
                                  if stridx(leader, '{$#}') !=# -1
                                    let expand = substitute(expand, '\$#', '\="\n" . str', 'g')
                                  endif
                                endif
                              elseif a:mode ==# 4
                                let line = getline('.')
                                let spaces = matchstr(line, '^\s*')
                                if line !~# '^\s*$'
                                  put =spaces.a:abbr
                                else
                                  call setline('.', spaces.a:abbr)
                                endif
                                normal! $
                                call emmet#expandAbbr(0, '')
                                return ''
                              else
    2              0.000007     let line = getline('.')
    2              0.000007     if col('.') < len(line)
                                  let line = matchstr(line, '^\(.*\%'.col('.').'c\)')
                                endif
    2              0.000003     if a:mode ==# 1
                                  let part = matchstr(line, '\([a-zA-Z0-9:_\-\@|]\+\)$')
                                else
    2              0.000029       let part = matchstr(line, '\(\S.*\)$')
    2   0.000035   0.000015       let ftype = emmet#lang#exists(type) ? type : 'html'
    2   0.000551   0.000025       let part = emmet#lang#{ftype}#findTokens(part)
    2              0.000014       let line = line[0: strridx(line, part) + len(part) - 1]
    2              0.000002     endif
    2              0.000008     if col('.') ==# col('$')
                                  let rest = ''
                                else
    2              0.000009       let rest = getline('.')[len(line):]
    2              0.000001     endif
    2              0.000003     let str = part
    2              0.000020     if str =~# s:filtermx
                                  let filters = split(matchstr(str, s:filtermx)[1:], '\s*,\s*')
                                  let str = substitute(str, s:filtermx, '', '')
                                endif
    2   0.019773   0.000019     let items = emmet#parseIntoTree(str, type).child
    4              0.000007     for item in items
    2   0.004489   0.000028       let expand .= emmet#toString(item, type, 0, filters, 0, indent)
    2              0.000002     endfor
    2   0.000063   0.000014     if emmet#useFilter(filters, 'e')
                                  let expand = substitute(expand, '&', '\&amp;', 'g')
                                  let expand = substitute(expand, '<', '\&lt;', 'g')
                                  let expand = substitute(expand, '>', '\&gt;', 'g')
                                endif
    2              0.000025     let expand = substitute(expand, '\$line\([0-9]\+\)\$', '\=submatch(1)', 'g')
    2              0.000002   endif
    2   0.000872   0.000019   let expand = emmet#expandDollarExpr(expand)
    2   0.000142   0.000023   let expand = emmet#expandCursorExpr(expand, a:mode)
    2              0.000005   if len(expand)
    2              0.000011     if has_key(s:emmet_settings, 'timezone') && len(s:emmet_settings.timezone)
                                  let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S') . s:emmet_settings.timezone, 'g')
                                else
                                  " TODO: on windows, %z/%Z is 'Tokyo(Standard)'
    2              0.000048       let expand = substitute(expand, '${datetime}', strftime('%Y-%m-%dT%H:%M:%S %z'), 'g')
    2              0.000002     endif
    2   0.000030   0.000014     let expand = emmet#unescapeDollarExpr(expand)
    2              0.000006     if a:mode ==# 2 && visualmode() ==# 'v'
                                  if a:firstline ==# a:lastline
                                    let expand = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
                                    let expand = substitute(expand, '[\n]$', '', 'g')
                                  endif
                                  silent! normal! gv
                                  let col = col('''<')
                                  silent! normal! c
                                  let line = getline('.')
                                  let lhs = matchstr(line, '.*\%<'.col.'c.')
                                  let rhs = matchstr(line, '\%>'.(col-1).'c.*')
                                  let expand = lhs.expand.rhs
                                  let lines = split(expand, '\n')
                                  call setline(line('.'), lines[0])
                                  if len(lines) > 1
                                    call append(line('.'), lines[1:])
                                  endif
                                else
    2              0.000026       if line[:-len(part)-1] =~# '^\s\+$'
    2              0.000009         let indent = line[:-len(part)-1]
    2              0.000003       else
                                    let indent = ''
                                  endif
    2              0.000025       let expand = substitute(expand, '[\r\n]\s*$', '', 'g')
    2   0.000061   0.000014       if emmet#useFilter(filters, 's')
                                    let epart = substitute(expand, '[\r\n]\s*', '', 'g')
                                  else
    2              0.000028         let epart = substitute(expand, '[\r\n]', "\n" . indent, 'g')
    2              0.000002       endif
    2              0.000013       let expand = line[:-len(part)-1] . epart . rest
    2              0.000027       let lines = split(expand, '[\r\n]', 1)
    2              0.000003       if a:mode ==# 2
                                    silent! exe 'normal! gvc'
                                  endif
    2              0.000033       call setline('.', lines[0])
    2              0.000006       if len(lines) > 1
    1              0.000020         call append('.', lines[1:])
    1              0.000001       endif
    2              0.000002     endif
    2              0.000000   endif
    2              0.000003   if g:emmet_debug > 1
                                call getchar()
                              endif
    2              0.000031   if search('\ze\$\(cursor\|select\)\$', 'c')
    2              0.000008     let oldselection = &selection
    2              0.000017     let &selection = 'inclusive'
    2              0.000011     if foldclosed(line('.')) !=# -1
                                  silent! foldopen
                                endif
    2   0.000046   0.000019     let pos = emmet#util#getcurpos()
    2   0.000393   0.000018     let use_selection = emmet#getResource(type, 'use_selection', 0)
    2              0.000003     try
    2              0.000006       let l:gdefault = &gdefault
    2              0.000011       let &gdefault = 0
    2              0.000008       if use_selection && getline('.')[col('.')-1:] =~# '^\$select'
                                    let pos[2] += 1
                                    silent! s/\$select\$//
                                    let next = searchpos('.\ze\$select\$', 'nW')
                                    silent! %s/\$\(cursor\|select\)\$//g
                                    call emmet#util#selectRegion([pos[1:2], next])
                                    return "\<esc>gv"
                                  else
    2              0.000063         silent! %s/\$\(cursor\|select\)\$//g
    2              0.000009         silent! call setpos('.', pos)
    2              0.000009         if col('.') < col('$')
    2              0.000007           return "\<right>"
                                    endif
                                  endif
                                finally
    2              0.000010       let &gdefault = l:gdefault
    2              0.000004     endtry
                                let &selection = oldselection
                              endif
                              return ''

FUNCTION  <SNR>53_has_any()
Called 2 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    9              0.000016   for key in a:keys
    7              0.000020     if has_key(a:dict, key)
                                  return 1
                                endif
    7              0.000004   endfor
    2              0.000002   return 0

FUNCTION  <SNR>80_startChannel()
Called 2 times
Total time:   0.005329
 Self time:   0.000325

count  total (s)   self (s)
    2              0.000010 	if has('nvim')
                            		let messenger = 'msgpack'
                            	else
    2              0.000004 		let messenger = 'json'
    2              0.000001 	endif
                            
    2              0.000027 	if !exists('g:phpcd_channel_id')
    1              0.000004 		let g:php_autoload_path = g:phpcd_root.'/'.g:phpcd_autoload_path
    1   0.005194   0.000190 		let g:phpcd_channel_id = rpc#start(g:phpcd_php_cli_executable, s:phpcd_path, g:phpcd_root, messenger, g:php_autoload_path, g:phpcd_disable_modifier)
                            
    1              0.000022 		if g:phpcd_root != '/'
    1              0.000016 			let g:phpid_channel_id = g:phpcd_channel_id
    1              0.000002 		endif
    1              0.000001 	endif

FUNCTION  <SNR>58_Highlight_Matching_Pair()
Called 788 times
Total time:   0.672812
 Self time:   0.672812

count  total (s)   self (s)
                              " Remove any previous match.
  788              0.003646   if exists('w:paren_hl_on') && w:paren_hl_on
  136              0.000779     silent! call matchdelete(3)
  136              0.000338     let w:paren_hl_on = 0
  136              0.000136   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  788              0.006878   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  788              0.002603   let c_lnum = line('.')
  788              0.002090   let c_col = col('.')
  788              0.000996   let before = 0
                            
  788              0.002468   let text = getline(c_lnum)
  788              0.015983   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  788              0.002082   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  788              0.004181     let [c_before, c] = matches[1:2]
  788              0.000623   endif
  788              0.012956   let plist = split(&matchpairs, '.\zs[:,]')
  788              0.002963   let i = index(plist, c)
  788              0.000990   if i < 0
                                " not found, in Insert mode try character before the cursor
  551              0.002386     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  278              0.000808       let before = strlen(c_before)
  278              0.000410       let c = c_before
  278              0.000696       let i = index(plist, c)
  278              0.000199     endif
  551              0.000648     if i < 0
                                  " not found, nothing to do
  545              0.000656       return
                                endif
    6              0.000003   endif
                            
                              " Figure out the arguments for searchpairpos().
  243              0.000342   if i % 2 == 0
   65              0.000107     let s_flags = 'nW'
   65              0.000195     let c2 = plist[i + 1]
   65              0.000055   else
  178              0.000270     let s_flags = 'nbW'
  178              0.000243     let c2 = c
  178              0.000468     let c = plist[i - 1]
  178              0.000139   endif
  243              0.000458   if c == '['
    6              0.000008     let c = '\['
    6              0.000007     let c2 = '\]'
    6              0.000006   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  243              0.000301   if before > 0
    6              0.000022     let has_getcurpos = exists("*getcurpos")
    6              0.000008     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    6              0.000018       let save_cursor = getcurpos()
    6              0.000005     else
                                  let save_cursor = winsaveview()
                                endif
    6              0.000020     call cursor(c_lnum, c_col - before)
    6              0.000000   endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
  243              0.001060   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
  243              0.115295   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
  243              0.001083   let stoplinebottom = line('w$')
  243              0.000726   let stoplinetop = line('w0')
  243              0.000344   if i % 2 == 0
   65              0.000159     let stopline = stoplinebottom
   65              0.000063   else
  178              0.000385     let stopline = stoplinetop
  178              0.000133   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  243              0.000878   if mode() == 'i' || mode() == 'R'
  154              0.000814     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
  154              0.000112   else
   89              0.000473     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   89              0.000064   endif
  243              0.000243   try
  243              0.430762     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
  243              0.000544   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
  243              0.000335   if before > 0
    6              0.000006     if has_getcurpos
    6              0.000022       call setpos('.', save_cursor)
    6              0.000005     else
                                  call winrestview(save_cursor)
                                endif
    6              0.000010   endif
                            
                              " If a match is found setup match highlighting.
  243              0.000638   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  136              0.000494     if exists('*matchaddpos')
  136              0.005492       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
  136              0.000159     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
  136              0.000301     let w:paren_hl_on = 1
  136              0.000106   endif

FUNCTION  emmet#getResource()
Called 38 times
Total time:   0.017162
 Self time:   0.003906

count  total (s)   self (s)
   38              0.000147   if exists('b:emmet_' . a:name)
                                return get(b:, 'emmet_' . a:name)
                              endif
   38              0.000052   let global = {}
   38              0.000151   if has_key(s:emmet_settings, '*') && has_key(s:emmet_settings['*'], a:name)
                                let global = extend(global, s:emmet_settings['*'][a:name])
                              endif
                            
   38              0.000091   if has_key(s:emmet_settings, a:type)
   38              0.000071     let types = [a:type]
   38              0.000029   else
                                let types = split(a:type, '\.')
                              endif
                            
   47              0.000085   for type in types
   38              0.000092     if !has_key(s:emmet_settings, type)
                                  continue
                                endif
   38              0.000061     let ret = a:default
                            
   38              0.000116     if has_key(s:emmet_settings[type], 'extends')
                                  let extends = s:emmet_settings[type].extends
                                  if type(extends) ==# 1
                                    let tmp = split(extends, '\s*,\s*')
                                    unlet! extends
                                    let extends = tmp
                                  endif
                                  for ext in extends
                                    if has_key(s:emmet_settings, ext) && has_key(s:emmet_settings[ext], a:name)
                                      if type(ret) ==# 3 || type(ret) ==# 4
                                        call emmet#mergeConfig(ret, s:emmet_settings[ext][a:name])
                                      else
                                        let ret = s:emmet_settings[ext][a:name]
                                      endif
                                    endif
                                  endfor
                                endif
                            
   38              0.000117     if has_key(s:emmet_settings[type], a:name)
   14              0.000046       if type(ret) ==# 3 || type(ret) ==# 4
   11   0.013349   0.000093         call emmet#mergeConfig(ret, s:emmet_settings[type][a:name])
   11              0.000149         return extend(global, ret)
                                  else
    3              0.000007         return s:emmet_settings[type][a:name]
                                  endif
                                endif
   24              0.000050     if !empty(ret)
   15              0.000048       if type(ret) ==# 3 || type(ret) ==# 4
                                    let ret = extend(global, ret)
                                  endif
   15              0.000015       return ret
                                endif
    9              0.000009   endfor
                            
    9              0.000014   let ret = a:default
    9              0.000032   if type(ret) ==# 3 || type(ret) ==# 4
    5              0.000012     let ret = extend(global, ret)
    5              0.000004   endif
    9              0.000010   return ret

FUNCTION  <SNR>73_expand()
Called 106 times
Total time:   0.025909
 Self time:   0.015630

count  total (s)   self (s)
  106              0.000167   let components = []
  106              0.000136   let expanded = []
  106              0.000132   let indices = []
  106              0.000143   let previndex = -1
  106   0.014018   0.003739   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
  510              0.000871   for [component, expand, index] in xs
  404              0.000815     if previndex != index
  229              0.000601       call add(indices, index)
  229              0.000456       call add(components, [])
  229              0.000423       call add(expanded, [])
  229              0.000161     endif
  404              0.001178     call extend(components[-1], component)
  404              0.002166     call extend(expanded[-1], repeat([expand], len(component)))
  404              0.000619     let previndex = index
  404              0.000284   endfor
  106              0.000524   call add(indices, string(len(a:components)))
  106              0.000228   return [components, expanded, indices]

FUNCTION  emmet#getFileType()
Called 6 times
Total time:   0.000709
 Self time:   0.000603

count  total (s)   self (s)
    6              0.000028   let flg = get(a:000, 0, 0)
    6              0.000009   let type = ''
                            
    6              0.000032   if has_key(s:emmet_settings, &filetype)
                                let type = &filetype
                              else
    6              0.000046     let types = split(&filetype, '\.')
   12              0.000023     for part in types
    6   0.000109   0.000035       if emmet#lang#exists(part)
                                    let type = part
                                    break
                                  endif
    6   0.000070   0.000038       let base = emmet#getBaseType(part)
    6              0.000012       if base !=# ''
                                    if flg
                                      let type = &filetype
                                    else
                                      let type = base
                                    endif
                                    unlet base
                                    break
                                  endif
    6              0.000005     endfor
    6              0.000006   endif
    6              0.000011   if type ==# 'html'
                                let pos = emmet#util#getcurpos()
                                let type = synIDattr(synID(pos[1], pos[2], 1), 'name')
                                if type =~# '^css\w'
                                  let type = 'css'
                                endif
                                if type =~# '^html\w'
                                  let type = 'html'
                                endif
                                if type =~# '^javaScript'
                                  let type = 'javascript'
                                endif
                                if len(type) ==# 0 && type =~# '^xml'
                                  let type = 'xml'
                                endif
                              endif
    6              0.000026   if len(type) ==# 0 | let type = 'html' | endif
    6              0.000009   return type

FUNCTION  lightline#mode()
Called 1228 times
Total time:   0.006834
 Self time:   0.006834

count  total (s)   self (s)
 1228              0.006085   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>44_set()
Called 184 times
Total time:   0.007103
 Self time:   0.001079

count  total (s)   self (s)
  184   0.007028   0.001004   return call('delimitMate#Set', a:000)

FUNCTION  <SNR>78_SetCompleteFunc()
Called 22 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
   22              0.000135   let &completefunc = 'youcompleteme#CompleteFunc'

FUNCTION  NERDTreeFocus()
Called 1 time
Total time:   0.041986
 Self time:   0.000059

count  total (s)   self (s)
    1   0.001342   0.000008     if g:NERDTree.IsOpen()
                                    call g:NERDTree.CursorToTreeWin()
                                else
    1   0.040631   0.000038         call g:NERDTreeCreator.ToggleTabTree("")
    1              0.000000     endif

FUNCTION  <SNR>78_OnInsertLeave()
Called 15 times
Total time:   0.038548
 Self time:   0.015412

count  total (s)   self (s)
   15   0.001160   0.000092   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   15              0.000068   call timer_stop( s:pollers.completion.id )
   15              0.000034   let s:force_semantic = 0
   15              0.000059   let s:completion = s:default_completion
                            
   15   0.022193   0.000125   call s:OnFileReadyToParse()
   15              0.014680   exec s:python_command "ycm_state.OnInsertLeave()"
   15              0.000130   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  phpcd#CompletePHP()
Called 4 times
Total time:   0.177348
 Self time:   0.001506

count  total (s)   self (s)
                            	" we need to wait phpcd {{{
    4              0.000027 	if !exists('g:phpcd_channel_id')
                            		return
                            	endif " }}}
                            
    4              0.000005 	if a:findstart " {{{
    2              0.000005 		unlet! b:php_menu
                            		" locate the start of the word
    2              0.000011 		let line = getline('.')
    2              0.000010 		let start = col('.') - 1
    2              0.000007 		let compl_begin = col('.') - 2
    2              0.000056 		while start >= 0 && line[start - 1] =~ '[\\a-zA-Z_0-9\x7f-\xff$]'
                            			let start -= 1
                            		endwhile
                            
                            		" TODO  phpbegin
    2              0.000491 		let phpbegin = searchpairpos('<?', '', '?>', 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"')
    2              0.000051 		let b:phpbegin = phpbegin
    2   0.009349   0.000084 		let b:compl_context = phpcd#GetCurrentInstruction(line('.'), max([0, col('.') - 2]), phpbegin)
                            
    2              0.000009 		if b:compl_context =~ 'new\s\+\\'
                            			let start = start + 1
                            		endif
                            
    2              0.000003 		return start
                            	endif " }}}
                            
                            	" If exists b:php_menu it means completion was already constructed {{{
                            	" we don't need to do anything more
    2              0.000005 	if exists('b:php_menu')
                            		return b:php_menu
                            	endif " }}}
                            
                            	" a:base is very short - we need context {{{
    2              0.000006 	if exists('b:compl_context')
    2              0.000004 		let context = b:compl_context
    2              0.000004 		unlet! b:compl_context
                            		" chop of the "base" from the end of the current instruction
    2              0.000004 		if a:base != ""
                            			let context = substitute(context, '\s*[$a-zA-Z_0-9\x7f-\xff]*$', '', '')
                            		end
    2              0.000002 	else
                            		let context = ''
                            	end " }}}
                            
    2              0.000002 	try " {{{
    2              0.000004 		let winheight = winheight(0)
    2              0.000004 		let winnr = winnr()
                            
    2              0.000008 		if context =~? '^namespace' "{{{
                            			return phpcd#GetPsrNamespace()
                            		endif "}}}
                            
    2              0.000022 		if context =~? '\v^((abstract|final)\s+)?(class|interface|trait)' "{{{
                            			return [expand('%:t:r')]
                            		end "}}}
                            
    2   0.079804   0.000029 		let [current_namespace, imports] = phpcd#GetCurrentNameSpace()
                            
    2              0.000024 		if context =~# '\v^(use$|use+\s.*)' " {{{
                            			return rpc#request(g:phpcd_channel_id, 'classmap', a:base)
                            		endif " }}}
                            
    2              0.000159 		if context =~ '\(->\|::\)$' " {{{
    2   0.045245   0.000049 			let classname = phpcd#GetClassName(line('.'), context, current_namespace, imports)
                            
                            			" TODO Fix it for variables with reference to $this etc.
    2              0.000024 			let public_only = (context !~# '^\(\$this\|self\|static\|parent\)')
    2              0.000003 			let is_static = 'only_nonstatic'
                            
    2              0.000011 			if strridx(context, '::') == strlen(context) - 2 " context =~ '::$' {{{
                            				if stridx(context, 'parent') != 0
                            					let is_static = 'only_static'
                            				else
                            					let is_static = 'both'
                            				endif
                            			endif" }}}
                            
    2              0.000007 			if get(g:, 'phpcd_disable_static_filter', 0) "{{{
                            					let is_static = 'both'
                            			endif "}}}
                            
    2   0.041646   0.000040 			return rpc#request(g:phpcd_channel_id, 'info', classname, a:base, is_static, public_only)
                            		elseif context =~? 'implements'
                            			" TODO complete class Foo implements
                            		elseif context =~? 'extends\s\+.\+$' && a:base == ''
                            			" TODO complete class Foo extends
                            		elseif context =~? 'extends'
                            			" TODO complete class Foo extends Prefix..
                            		elseif context =~? 'class [a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
                            			" special case when you've typed the class keyword and the name too,
                            			" only extends and implements allowed there
                            			return filter(['extends', 'implements'], 'stridx(v:val, a:base) == 0')
                            		elseif context =~? 'new\s\+\\'
                            			return rpc#request(g:phpcd_channel_id, 'classes', a:base)
                            		endif " }}}
                            
                            		if a:base =~ '^[^$]' " {{{
                            			return phpcd#CompleteGeneral(a:base, current_namespace, imports)
                            		endif " }}}
                            	finally
    2              0.000025 		silent! exec winnr.'resize '.winheight
    2              0.000003 	endtry " }}}

FUNCTION  <SNR>73_convert()
Called 404 times
Total time:   0.006984
 Self time:   0.006984

count  total (s)   self (s)
  404              0.001106   if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '"]'), 'v:val[0] != []')
                              else
  404              0.001157     return [[[a:name], 0, a:index]]
                              endif

FUNCTION  <SNR>78_VisitedBufferRequiresReparse()
Called 23 times
Total time:   0.001514
 Self time:   0.000359

count  total (s)   self (s)
   23              0.000143   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
    2              0.000003     return 0
                              endif
                            
   21   0.001294   0.000139   return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  <SNR>78_ReceiveMessages()
Called 40 times
Total time:   0.031907
 Self time:   0.003574

count  total (s)   self (s)
   40   0.030138   0.001805   let poll_again = s:Pyeval( 'ycm_state.OnPeriodicTick()' )
                            
   40              0.000253   if poll_again
   20              0.000666     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
   20              0.000067   else
                                " Don't poll again until we open another buffer
   20              0.000118     let s:pollers.receive_messages.id = -1
   20              0.000030   endif

FUNCTION  <SNR>53_open()
Called 1 time
Total time:   0.070135
 Self time:   0.004210

count  total (s)   self (s)
    1   0.000108   0.000016   if stridx('edit', a:cmd) == 0 && s:fzf_fnamemodify(a:target, ':p') ==# s:fzf_expand('%:p')
                                return
                              endif
    1   0.070025   0.004192   execute a:cmd s:escape(a:target)

FUNCTION  emmet#getIndentation()
Called 4 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
    4              0.000005   if a:0 > 0
    4              0.000005     let type = a:1
    4              0.000004   else
                                let type = emmet#getFileType()
                              endif
    4              0.000026   if has_key(s:emmet_settings, type) && has_key(s:emmet_settings[type], 'indentation')
                                let indent = s:emmet_settings[type].indentation
                              elseif has_key(s:emmet_settings, 'indentation')
                                let indent = s:emmet_settings.indentation
                              elseif has_key(s:emmet_settings.variables, 'indentation')
                                let indent = s:emmet_settings.variables.indentation
                              else
    4              0.000023     let sw = exists('*shiftwidth') ? shiftwidth() : &l:shiftwidth
    4              0.000020     let indent = (&l:expandtab || &l:tabstop !=# sw) ? repeat(' ', sw) : "\t"
    4              0.000004   endif
    4              0.000005   return indent

FUNCTION  <SNR>44_setup()
Called 8 times
Total time:   0.032131
 Self time:   0.000671

count  total (s)   self (s)
    8              0.000022   let swap = a:0 && a:1 == 2
    8              0.000015   let enable = a:0 && a:1
    8              0.000009   let disable = a:0 && !a:1
                              " First, remove all magic, if needed:
    8              0.000032   if get(b:, 'delimitMate_enabled', 0)
    5   0.004818   0.000079     call s:Unmap()
                                " Switch
    5              0.000005     if swap
                                  echo "delimitMate is disabled."
                                  return
                                endif
    5              0.000005   endif
    8              0.000008   if disable
                                " Just disable the mappings.
                                return
                              endif
    8              0.000008   if !a:0
                                " Check if this file type is excluded:
    8              0.000049     if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                                  " Finish here:
                                  return 1
                                endif
                                " Check if user tried to disable using b:loaded_delimitMate
    8              0.000029     if exists("b:loaded_delimitMate")
                                  return 1
                                endif
    8              0.000003   endif
                              " Initialize settings:
    8   0.015829   0.000061   if ! s:init()
                                " Something went wrong.
                                return
                              endif
    8              0.000030   if enable || swap || !get(g:, 'delimitMate_offByDefault', 0)
                                " Now, add magic:
    8   0.010997   0.000044     call s:Map()
    8              0.000009     if a:0
                                  echo "delimitMate is enabled."
                                endif
    8              0.000005   endif

FUNCTION  nerdtree#has_opt()
Called 197 times
Total time:   0.000624
 Self time:   0.000624

count  total (s)   self (s)
  197              0.000552     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  delimitMate#ParenDelim()
Called 7 times
Total time:   0.005084
 Self time:   0.000885

count  total (s)   self (s)
    7   0.000569   0.000158   let left = s:get('left_delims')[index(s:get('right_delims'),a:right)]
    7   0.003271   0.000050   if s:is_forbidden(a:right)
                                return left
                              endif
                              " Try to balance matchpairs
    7   0.000179   0.000043   if s:get('balance_matchpairs') && s:balance_matchpairs(a:right) < 0
                                return left
                              endif
    7              0.000024   let line = getline('.')
    7              0.000020   let col = col('.')-2
    7   0.000171   0.000035   if s:get('smart_matchpairs') != ''
    7   0.000241   0.000114     let smart_matchpairs = substitute(s:get('smart_matchpairs'), '\\!', left, 'g')
    7              0.000053     let smart_matchpairs = substitute(smart_matchpairs, '\\#', a:right, 'g')
    7              0.000093     if line[col+1:] =~ smart_matchpairs
                                  return left
                                endif
    7              0.000005   endif
    7   0.000097   0.000042   if len(line) == (col + 1) && s:get('insert_eol_marker') == 1
    3   0.000067   0.000013     let tail = s:get('eol_marker')
    3              0.000001   else
    4              0.000006     let tail = ''
    4              0.000003   endif
    7   0.000185   0.000126   return left . a:right . tail . repeat(s:joinUndo() . "\<Left>", len(split(tail, '\zs')) + 1)

FUNCTION  <SNR>7_LoadIndent()
Called 5 times
Total time:   0.007172
 Self time:   0.004125

count  total (s)   self (s)
    5              0.000028     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    5              0.000135     let s = expand("<amatch>")
    5              0.000110     if s != ""
    5              0.000016       if exists("b:did_indent")
    2              0.000004 	unlet b:did_indent
    2              0.000002       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   10              0.000271       for name in split(s, '\.')
    5   0.006257   0.003210 	exe 'runtime! indent/' . name . '.vim'
    5              0.000016       endfor
    5              0.000005     endif

FUNCTION  emmet#mergeConfig()
Called 11 times
Total time:   0.013256
 Self time:   0.013256

count  total (s)   self (s)
   11              0.000038   let [lhs, rhs] = [a:lhs, a:rhs]
   11              0.000022   if type(lhs) ==# 3
                                if type(rhs) ==# 3
                                  let lhs += rhs
                                  if len(lhs)
                                    call remove(lhs, 0, len(lhs)-1)
                                  endif
                                  for rhi in rhs
                                    call add(lhs, rhs[rhi])
                                  endfor
                                elseif type(rhs) ==# 4
                                  let lhs += map(keys(rhs), '{v:val : rhs[v:val]}')
                                endif
                              elseif type(lhs) ==# 4
   11              0.000020     if type(rhs) ==# 3
                                  for V in rhs
                                    if type(V) != 4
                                      continue
                                    endif
                                    for k in keys(V)
                                      let lhs[k] = V[k]
                                    endfor
                                  endfor
                                elseif type(rhs) ==# 4
  462              0.000629       for key in keys(rhs)
  451              0.000989         if type(rhs[key]) ==# 3
  252              0.000475           if !has_key(lhs, key)
  252              0.000423             let lhs[key] = []
  252              0.000150           endif
  252              0.000471           if type(lhs[key]) == 3
  252              0.000552             let lhs[key] += rhs[key]
  252              0.000391           elseif type(lhs[key]) == 4
                                        for k in keys(rhs[key])
                                          let lhs[key][k] = rhs[key][k]
                                        endfor
                                      endif
  252              0.000384         elseif type(rhs[key]) ==# 4
    3              0.000006           if has_key(lhs, key)
                                        call emmet#mergeConfig(lhs[key], rhs[key])
                                      else
    3              0.000008             let lhs[key] = rhs[key]
    3              0.000001           endif
    3              0.000003         else
  196              0.000444           let lhs[key] = rhs[key]
  196              0.000142         endif
  451              0.000272       endfor
   11              0.000006     endif
   11              0.000007   endif

FUNCTION  <SNR>78_OnTextChangedInsertMode()
Called 214 times
Total time:   0.789744
 Self time:   0.061043

count  total (s)   self (s)
  214   0.012930   0.001069   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  214              0.000283   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
  214   0.035609   0.001057   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
  214              0.000875   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
  214   0.110908   0.002951   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
  204   0.007092   0.001353     call s:Complete()
  204   0.569646   0.001054     call s:InvokeCompletion()
  204              0.000263   endif
                            
  214              0.045647   exec s:python_command "ycm_state.OnCursorMoved()"
                            
  214              0.001057   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  emmet#expandDollarExpr()
Called 2 times
Total time:   0.000853
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000853   0.000016   return emmet#reExpandDollarExpr(a:expand, 0)

FUNCTION  <SNR>4_BMHash()
Called 3 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
                              " Make name all upper case, so that chars are between 32 and 96
    3              0.000033   let nm = substitute(a:name, ".*", '\U\0', "")
    3              0.000011   if has("ebcdic")
                                " HACK: Replace all non alphabetics with 'Z'
                                "       Just to make it work for now.
                                let nm = substitute(nm, "[^A-Z]", 'Z', "g")
                                let sp = char2nr('A') - 1
                              else
    3              0.000007     let sp = char2nr(' ')
    3              0.000002   endif
                              " convert first six chars into a number for sorting:
    3              0.000045   return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)

FUNCTION  76()
Called 1 time
Total time:   0.172377
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000006     let Callback = function(self.callback)
    1              0.000001     if a:0
    1   0.172359   0.000021         call Callback(a:1)
    1              0.000001     else
                                    call Callback()
                                endif

FUNCTION  phpcd#GetClassName()
Called 2 times
Total time:   0.045196
 Self time:   0.002465

count  total (s)   self (s)
    2              0.000006 	let class_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*' " {{{
    2              0.000005 	let function_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
    2              0.000006 	let function_invocation_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*('
    2              0.000004 	let variable_name_pattern = '\$[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
                            
    2              0.000004 	let classname_candidate = ''
    2              0.000004 	let class_candidate_namespace = a:current_namespace
    2              0.000004 	let class_candidate_imports = a:imports
    2   0.000805   0.000025 	let methodstack = phpcd#GetMethodStack(a:context) " }}}
                            
    2              0.000005 	if empty(methodstack) "{{{
                            		return ''
                            	endif "}}}
                            
    2              0.000017 	if methodstack[-1] =~# '\vmake|app|get' " {{{
                            		" just for laravel and container-interop
                            		let container_interface = matchstr(methodstack[-1], '^\(make\|app\|get\)(\zs.\+\ze::class)')
                            		if container_interface != ''
                            			let [classname_candidate, class_candidate_namespace] = phpcd#ExpandClassName(container_interface, a:current_namespace, a:imports)
                            			return s:GetFullName(class_candidate_namespace, classname_candidate)
                            		endif
                            	endif " }}}
    2              0.000019 	if a:context =~? '^\$this->' || a:context =~? '^\(self\|static\)::' || a:context =~? 'parent::' " {{{
    1              0.000001 		let i = 1
   14              0.000017 		while i < a:start_line
   14              0.000041 			let line = getline(a:start_line - i)
                            
                            			" Don't complete self:: or $this if outside of a class
                            			" (assumes correct indenting)
   14              0.000036 			if line =~ '^}'
                            				return ''
                            			endif
                            
   14              0.000112 			if line =~? '\v^\s*(abstract\s+|final\s+)*\s*(class|trait)\s'
    1              0.000024 				let class_name = matchstr(line, '\c\(class\|trait\)\s\+\zs'.class_name_pattern.'\ze')
    1              0.000025 				let extended_class = matchstr(line, '\cclass\s\+'.class_name_pattern.'\s\+extends\s\+\zs'.class_name_pattern.'\ze')
                            
    1              0.000006 				let classname_candidate = a:context =~? 'parent::' ? extended_class : class_name
    1              0.000002 				if classname_candidate != ''
    1   0.000159   0.000020 					return phpcd#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
                            				endif
                            			endif
                            
   13              0.000012 			let i += 1
   13              0.000008 		endwhile " }}}
                            	elseif a:context =~ 'function' " {{{
                            		let i = 1
                            		while i < a:start_line
                            			let line = getline(a:start_line - i)
                            
                            			" Don't complete self:: or $this if outside of a class
                            			" (assumes correct indenting)
                            			if line =~ '^}'
                            				return ''
                            			endif
                            
                            			if line =~? '\v^\s*interface\s'
                            				let class_name = matchstr(line, '\cinterface\s\+\zs'.class_name_pattern.'\ze')
                            
                            				if class_name != ''
                            					return a:current_namespace . '\' . class_name
                            				endif
                            			endif
                            
                            			if line =~? '\v^\s*abstract\s'
                            				let class_name = matchstr(line, '\cabstract\s\+class\s\+\zs'.class_name_pattern.'\ze')
                            
                            				if class_name != ''
                            					return a:current_namespace . '\' . class_name
                            				endif
                            			endif
                            
                            			let i += 1
                            		endwhile " }}}
                            	elseif a:context =~? '(\s*new\s\+'.class_name_pattern.'\s*\(([^)]*)\)\?)->' " {{{
                            		let classname_candidate = matchstr(a:context, '\cnew\s\+\zs'.class_name_pattern.'\ze')
                            		if classname_candidate =~? '\vstatic|self' " {{{
                            			let i = 1
                            			while i < a:start_line
                            				let line = getline(a:start_line - i)
                            
                            				if line =~? '\v^\s*(abstract\s+|final\s+)*\s*class\s'
                            					let classname_candidate = matchstr(line, '\cclass\s\+\zs'.class_name_pattern.'\ze')
                            					break
                            				endif
                            
                            				let i += 1
                            			endwhile
                            		end " }}}
                            		return phpcd#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack) " }}}
                            	elseif get(methodstack, 0) =~# function_invocation_pattern " {{{
                            		let function_name = matchstr(methodstack[0], '^\s*\zs'.function_name_pattern)
                            		let return_types = rpc#request(g:phpcd_channel_id, 'functype', '', function_name, expand('%:p'))
                            		if len(return_types) > 0
                            			let return_type = phpcd#SelectOne(return_types)
                            			return phpcd#GetCallChainReturnType(return_type, '', class_candidate_imports, methodstack)
                            		endif " }}}
                            	else " {{{
                            		" extract the variable name from the context {{{
    1              0.000003 		let object = methodstack[0]
    1              0.000007 		let object_is_array = (object =~ '\v^[^[]+\[' ? 1 : 0)
    1              0.000009 		let object = matchstr(object, variable_name_pattern)
                            
    1   0.000815   0.000011 		let function_boundary = phpcd#GetCurrentFunctionBoundaries()
    1              0.000005 		let search_end_line = max([1, function_boundary[0][0]])
                            		" -1 makes us ignore the current line (where the completion was invoked
    1              0.000007 		let lines = reverse(getline(search_end_line, a:start_line - 1)) "}}}
                            
                            		" check Constant lookup {{{
    1              0.000033 		let classname_candidate = matchstr(a:context, '\zs'.class_name_pattern.'\ze::')
    1              0.000002 		if classname_candidate != ''
                            			let [classname_candidate, class_candidate_namespace] = phpcd#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
                            			return phpcd#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
                            		endif "}}}
                            
                            		" scan the file backwards from the current line {{{
    1              0.000001 		let i = 1
    7              0.000010 		for line in lines
                            				" in file lookup for /* @var $foo Class */
    7              0.000049 				if line =~# '@var\s\+'.object.'\s\+'.class_name_pattern "{{{
                            					let classname_candidate = matchstr(line, '@var\s\+'.object.'\s\+\zs'.class_name_pattern.'\(\[\]\)\?')
                            					let [classname_candidate, class_candidate_namespace] = phpcd#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
                            					break
                            				endif "}}}
                            
                            				" in file lookup for /* @var Class $foo */
    7              0.000046 				if line =~# '@var\s\+'.class_name_pattern.'\s\+'.object "{{{
                            					let classname_candidate = matchstr(line, '@var\s\+\zs'.class_name_pattern.'\(\[\]\)\?\ze'.'\s\+'.object)
                            					let [classname_candidate, class_candidate_namespace] = phpcd#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
                            					break
                            				endif "}}}
                            
                            			" do in-file lookup of $var = new Class or $var = new (s|S)tatic
    7              0.000060 			if line =~# '^\s*'.object.'\s*=\s*new\s\+'.class_name_pattern && !object_is_array " {{{
                            				let classname_candidate = matchstr(line, object.'\c\s*=\s*new\s*\zs'.class_name_pattern.'\ze')
                            				if classname_candidate =~? '\vstatic|self' " {{{
                            					let nsuse = rpc#request(g:phpcd_channel_id, 'nsuse', expand('%:p'))
                            					let classname_candidate = nsuse.class
                            				end " }}}
                            				let [classname_candidate, class_candidate_namespace] = phpcd#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
                            				break
                            			endif " }}}
                            
    7              0.000052 			if line =~# '^\s*'.object.'\s*=\s*\(require\|include\).*' && !object_is_array " {{{
                            				let path = matchstr(line, '\(require\|include\)\(_once\)\?\s*__DIR__\s*\.\s*\zs.*\ze;')
                            				let cwd = expand('%:p:h')
                            				let path = cwd.substitute(path, "'", '', 'g')
                            				let path = fnamemodify(path, ':p:.')
                            
                            				silent! below 1sp
                            				exec 'e +$ ' . path
                            				call search(';')
                            				let [symbol, context, namespace, imports] = phpcd#GetCurrentSymbolWithContext()
                            				let classname = phpcd#GetClassName(line('.'), symbol.'->', namespace, imports)
                            				q
                            				return classname
                            			endif " }}}
                            
                            			" lambda declaration line
    7              0.000032 			if line =~? 'function\s*(.\{-\}\s*'.object " {{{
                            				" skip function () use($object)
                            				if line =~? 'use\s*(.\{-\}'.object.'\>'
                            					let i += 1
                            					continue
                            				endif
                            
                            				" search for type hinted arguments
                            				let classname_candidate = matchstr(line, '\c\zs'.class_name_pattern.'\ze\s\+'.object.'\>')
                            				if classname_candidate
                            					if classname_candidate[0] == '\'
                            						return classname_candidate
                            					endif
                            					let [classname_candidate, class_candidate_namespace] = phpcd#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
                            					break
                            				endif
                            			endif " }}}
                            
                            			" function declaration line
    7              0.000063 			if line =~? 'function\s\+'.function_name_pattern.'\s*(.\{-\}\s*'.object " {{{
    1   0.028961   0.000078 				let nsuse = rpc#request(g:phpcd_channel_id, 'nsuse', expand('%:p'))
                            
    1              0.000006 				let line_no = a:start_line - i
    1              0.000003 				if line_no > nsuse.start_line && line_no < nsuse.end_line
    1              0.000005 					let classname = nsuse.namespace.'\'.nsuse.class
    1              0.000001 				else
                            					let classname = ''
                            				endif
                            
    1              0.000032 				let funcname = matchstr(line, '\cfunction\s\+\zs'.function_name_pattern.'\ze')
    1   0.012085   0.000068 				let argtypes = rpc#request(g:phpcd_channel_id, 'argtype', classname, funcname, object, expand('%:p'))
                            
    1   0.000096   0.000082 				let classname_candidate = phpcd#SelectOne(argtypes)
    1              0.000001 				break
                            			endif " }}}
                            
                            			" assignment for the variable in question with a variable on the right hand side
    6              0.000068 			if line =~# '^\s*'.object.'\s*=&\?\s*\(clone\s\+\)\?\s*'.variable_name_pattern.';' " {{{
                            				let c = matchstr(a:context, variable_name_pattern.'\zs.\+')
                            				let classname_candidate = phpcd#GetTypeAt(a:start_line - i, c)
                            				break
                            			endif " }}}
                            
                            			" assignment for the variable in question with function chains on the right hand side
    6              0.000034 			if line =~? '^\s*' . object . '\s*=.*);\?$' " {{{
                            				let classname_candidate = phpcd#GetCallChainReturnTypeAt(a:start_line - i)
                            				break
                            			endif " }}}
                            
    6              0.000041 			if line =~? object.'\s*=\s*'.variable_name_pattern.'[' " {{{
                            				let sub_context = matchstr(line, '=\s*\zs'.variable_name_pattern.'\ze[')
                            				let prev_class = phpcd#GetClassName(a:start_line - i, sub_context, a:current_namespace, a:imports)
                            
                            				let [classname_candidate, class_candidate_namespace] = s:getArrayType(prev_class)
                            				break
                            			endif " }}}
                            
                            			" foreach with the variable in question
    6              0.000032 			if line =~? 'foreach\s*(.\{-}\s\+'.object.'\s*)' " {{{
                            				let sub_context = matchstr(line, 'foreach\s*(\s*\zs.\{-}\ze\s\+as')
                            				let prev_class = phpcd#GetClassName(a:start_line - i, sub_context, a:current_namespace, a:imports)
                            
                            				let [classname_candidate, class_candidate_namespace] = s:getArrayType(prev_class)
                            				if classname_candidate != ''
                            					break
                            				else
                            					let i += 1
                            					continue
                            				endif
                            			endif " }}}
                            
                            			" catch clause with the variable in question
    6              0.000044 			if line =~? 'catch\s*(\zs'.class_name_pattern.'\ze\s\+'.object " {{{
                            				let classname_candidate = matchstr(line, 'catch\s*(\zs'.class_name_pattern.'\ze\s\+'.object)
                            				break
                            			endif " }}}
                            
    6              0.000008 			let i += 1
    6              0.000004 		endfor " }}}
                            
    1              0.000002 		if classname_candidate != '' " {{{
    1   0.000104   0.000010 			return phpcd#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
                            		endif " }}}
                            	endif " }}}

FUNCTION  nerdtree#exec()
Called 5 times
Total time:   0.014401
 Self time:   0.000587

count  total (s)   self (s)
    5              0.000018     let old_ei = &ei
    5              0.000036     set ei=BufEnter,BufLeave,VimEnter
    5   0.014298   0.000484     exec a:cmd
    5              0.000043     let &ei = old_ei

FUNCTION  <SNR>53_fzf_expand()
Called 2 times
Total time:   0.000058
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000058   0.000017   return s:fzf_call('expand', a:fmt, 1)

FUNCTION  <SNR>4_BMAdd()
Called 3 times
Total time:   0.001198
 Self time:   0.000105

count  total (s)   self (s)
    3              0.000007   if s:bmenu_wait == 0
                                " when adding too many buffers, redraw in short format
    3              0.000007     if s:bmenu_count == &menuitems && s:bmenu_short == 0
                                  call s:BMShow()
                                else
    3   0.001151   0.000058       call <SID>BMFilename(expand("<afile>"), expand("<abuf>"))
    3              0.000009       let s:bmenu_count = s:bmenu_count + 1
    3              0.000003     endif
    3              0.000001   endif

FUNCTION  <SNR>67_Filter()
Called 19 times
Total time:   0.000565
 Self time:   0.000565

count  total (s)   self (s)
   19              0.000079     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
                                endif
                            
   19              0.000072     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
                                endif
                            
   19              0.000067     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
                                endif
                            
   19              0.000043     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
                                endfor
                            
   19              0.000018     return 1

FUNCTION  <SNR>78_PollFileParseResponse()
Called 58 times
Total time:   0.029095
 Self time:   0.012184

count  total (s)   self (s)
   58   0.015584   0.001982   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
   58              0.007392   exec s:python_command "ycm_state.HandleFileParseRequest()"
   58   0.004201   0.000892   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  <SNR>44_get()
Called 286 times
Total time:   0.007943
 Self time:   0.001371

count  total (s)   self (s)
  286   0.007849   0.001277   return call('delimitMate#Get', a:000)

FUNCTION  emmet#lang#html#findTokens()
Called 2 times
Total time:   0.000526
 Self time:   0.000526

count  total (s)   self (s)
    2              0.000003   let str = a:str
    2              0.000007   let [pos, last_pos] = [0, 0]
    2              0.000003   while 1
    2              0.000017     let tag = matchstr(str, '<[a-zA-Z].\{-}>', pos)
    2              0.000004     if len(tag) == 0
    2              0.000003       break
                                endif
                                let pos = stridx(str, tag, pos) + len(tag)
                              endwhile
    2              0.000002   while 1
    2              0.000013     let tag = matchstr(str, '{%[^%]\{-}%}', pos)
    2              0.000004     if len(tag) == 0
    2              0.000002       break
                                endif
                                let pos = stridx(str, tag, pos) + len(tag)
                              endwhile
    2              0.000004   let last_pos = pos
    4              0.000008   while len(str) > 0
    4              0.000318     let token = matchstr(str, s:mx, pos)
    4              0.000009     if token ==# ''
    2              0.000002       break
                                endif
    2              0.000012     if token =~# '^\s'
                                  let token = matchstr(token, '^\s*\zs.*')
                                  let last_pos = stridx(str, token, pos)
                                endif
    2              0.000017     let pos = stridx(str, token, pos) + len(token)
    2              0.000003   endwhile
    2              0.000008   let str = a:str[last_pos :-1]
    2              0.000014   if str =~# '^\w\+="[^"]*$'
                                return ''
                              endif
    2              0.000003   return str

FUNCTION  <SNR>4_BMRemove()
Called 4 times
Total time:   0.001103
 Self time:   0.000554

count  total (s)   self (s)
    4              0.000018   if s:bmenu_wait == 0
    4              0.000123     let name = expand("<afile>")
    4              0.000034     if isdirectory(name)
                                  return
                                endif
    4   0.000615   0.000066     let munge = <SID>BMMunge(name, expand("<abuf>"))
                            
    4              0.000007     if s:bmenu_short == 0
    4              0.000227       exe 'silent! aun &Buffers.' . munge
    4              0.000006     else
                                  exe 'silent! aun &Buffers.' . <SID>BMHash2(munge) . munge
                                endif
    4              0.000016     let s:bmenu_count = s:bmenu_count - 1
    4              0.000004   endif

FUNCTION  <SNR>45_is_smart_quote()
Called 1 time
Total time:   0.000112
 Self time:   0.000092

count  total (s)   self (s)
                              " TODO: Allow using a:char in the pattern.
    1   0.000025   0.000005   let tmp = s:get('smart_quotes')
    1              0.000002   if empty(tmp)
                                return 0
                              endif
    1              0.000016   let regex = matchstr(tmp, '^!\?\zs.*')
                              " Flip matched value if regex starts with !
    1              0.000005   let mod = tmp =~ '^!' ? [1, 0] : [0, 1]
    1              0.000022   let matched = search(regex, 'ncb', line('.')) > 0
    1              0.000007   let noescaped = substitute(getline('.'), '\\.', '', 'g')
    1              0.000024   let odd =  (count(split(noescaped, '\zs'), a:char) % 2)
    1              0.000003   let result = mod[matched] || odd
    1              0.000001   return result

FUNCTION  <SNR>53_present()
Called 5 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
   10              0.000042   for key in a:000
    6              0.000036     if !empty(get(a:dict, key, ''))
    1              0.000001       return 1
                                endif
    5              0.000005   endfor
    4              0.000004   return 0

FUNCTION  fzf#wrap()
Called 1 time
Total time:   0.000587
 Self time:   0.000290

count  total (s)   self (s)
    1              0.000003   let args = ['', {}, 0]
    1              0.000011   let expects = map(copy(args), 'type(v:val)')
    1              0.000002   let tidx = 0
    4              0.000010   for arg in copy(a:000)
    3              0.000012     let tidx = index(expects, type(arg), tidx)
    3              0.000003     if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
                                endif
    3              0.000007     let args[tidx] = arg
    3              0.000004     let tidx += 1
    3              0.000004     unlet arg
    3              0.000003   endfor
    1              0.000003   let [name, opts, bang] = args
                            
    1              0.000003   if len(name)
    1              0.000002     let opts.name = name
    1              0.000001   end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
    1              0.000001   if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
                              elseif !s:has_any(opts, s:layout_keys)
    1              0.000005     if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
                                else
    1   0.000039   0.000014       let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout)))
    1              0.000001     endif
    1              0.000000   endif
                            
                              " Colors: g:fzf_colors
    1   0.000218   0.000022   let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
    1              0.000010   if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
                              endif
                            
                              " Action: g:fzf_action
    1   0.000048   0.000012   if !s:has_any(opts, ['sink', 'sink*'])
    1              0.000008     let opts._action = get(g:, 'fzf_action', s:default_action)
    1              0.000014     let opts.options .= ' --expect='.join(keys(opts._action), ',')
    1              0.000004     function! opts.sink(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
    1              0.000010     let opts['sink*'] = remove(opts, 'sink')
    1              0.000001   endif
                            
    1              0.000002   return opts

FUNCTION  <SNR>4_BMMunge()
Called 7 times
Total time:   0.001145
 Self time:   0.000552

count  total (s)   self (s)
    7              0.000027   let name = a:fname
    7              0.000014   if name == ''
    4              0.000013     if !exists("g:menutrans_no_file")
                                  let g:menutrans_no_file = "[No file]"
                                endif
    4              0.000005     let name = g:menutrans_no_file
    4              0.000003   else
    3              0.000102     let name = fnamemodify(name, ':p:~')
    3              0.000004   endif
                              " detach file name and separate it out:
    7              0.000026   let name2 = fnamemodify(name, ':t')
    7              0.000011   if a:bnum >= 0
    7              0.000025     let name2 = name2 . ' (' . a:bnum . ')'
    7              0.000004   endif
    7   0.000689   0.000096   let name = name2 . "\t" . <SID>BMTruncName(fnamemodify(name,':h'))
    7              0.000035   let name = escape(name, "\\. \t|")
    7              0.000069   let name = substitute(name, "&", "&&", "g")
    7              0.000034   let name = substitute(name, "\n", "^@", "g")
    7              0.000008   return name

FUNCTION  <SNR>78_OnTextChangedNormalMode()
Called 35 times
Total time:   0.040758
 Self time:   0.000544

count  total (s)   self (s)
   35   0.002464   0.000189   if !s:AllowedToCompleteInCurrentBuffer()
    1              0.000001     return
                              endif
                            
   34   0.038181   0.000242   call s:OnFileReadyToParse()

FUNCTION  emmet#getDollarValueByKey()
Called 2 times
Total time:   0.000423
 Self time:   0.000183

count  total (s)   self (s)
    2              0.000003   let ret = 0
    2              0.000004   let key = a:key
    2   0.000259   0.000019   let ftsetting = get(s:emmet_settings, emmet#getFileType())
    2              0.000010   if type(ftsetting) ==# 4 && has_key(ftsetting, key)
                                let V = get(ftsetting, key)
                                if type(V) ==# 1 | return V | endif
                              endif
    2              0.000011   if type(ret) !=# 1 && has_key(s:emmet_settings.variables, key)
                                let V = get(s:emmet_settings.variables, key)
                                if type(V) ==# 1 | return V | endif
                              endif
    2              0.000012   if has_key(s:emmet_settings, 'custom_expands') && type(s:emmet_settings['custom_expands']) ==# 4
    4              0.000013     for k in keys(s:emmet_settings['custom_expands'])
    2              0.000014       if key =~# k
                                    let V = get(s:emmet_settings['custom_expands'], k)
                                    if type(V) ==# 1 | return V | endif
                                    if type(V) ==# 2 | return V(key) | endif
                                  endif
    2              0.000003     endfor
    2              0.000003   endif
    2              0.000001   return ret

FUNCTION  phpcd#GetCurrentFunctionBoundaries()
Called 1 time
Total time:   0.000804
 Self time:   0.000804

count  total (s)   self (s)
    1              0.000004 	let old_cursor_pos = [line('.'), col('.')]
    1              0.000003 	let current_line_no = old_cursor_pos[0]
    1              0.000001 	let function_pattern = '\<function\s\+[^(]\+('
                            
    1              0.000015 	let func_start_pos = searchpos(function_pattern, 'Wbc')
    1              0.000003 	if func_start_pos == [0, 0]
                            		call cursor(old_cursor_pos[0], old_cursor_pos[1])
                            		return 0
                            	endif
                            
                            	" get the line where the function declaration actually started
    1              0.000017 	call search('\cfunction\_.\{-}(\_.\{-})\_.\{-}{', 'Wce')
                            
                            	" get the position of the function block's closing "}"
    1              0.000731 	let func_end_pos = searchpairpos('{', '', '}', 'W', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"')
    1              0.000002 	if func_end_pos == [0, 0]
                            		" there is a function start but no end found, assume that we are in a
                            		" function but the user did not typed the closing "}" yet and the
                            		" function runs to the end of the file
                            		let func_end_pos = [line('$'), len(getline(line('$')))]
                            	endif
                            
                            	" Decho func_start_pos[0].' <= '.current_line_no.' && '.current_line_no.' <= '.func_end_pos[0]
    1              0.000004 	if func_start_pos[0] <= current_line_no && current_line_no <= func_end_pos[0]
    1              0.000004 		call cursor(old_cursor_pos[0], old_cursor_pos[1])
    1              0.000002 		return [func_start_pos, func_end_pos]
                            	endif
                            
                            	call cursor(old_cursor_pos[0], old_cursor_pos[1])
                            	return 0

FUNCTION  200()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002     if g:NERDTreeStatusline != -1
    1              0.000005         let &l:statusline = g:NERDTreeStatusline
    1              0.000001     endif

FUNCTION  202()
Called 1 time
Total time:   0.040593
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000042   0.000013     let creator = s:Creator.New()
    1   0.040550   0.000009     call creator.toggleTabTree(a:dir)

FUNCTION  203()
Called 1 time
Total time:   0.040541
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000247   0.000005     if g:NERDTree.ExistsForTab()
    1   0.000417   0.000004         if !g:NERDTree.IsOpen()
    1   0.027325   0.000010             call self._createTreeWin()
    1              0.000001             if !&hidden
    1   0.012490   0.000014                 call b:NERDTree.render()
    1              0.000001             endif
    1   0.000051   0.000011             call b:NERDTree.ui.restoreScreenState()
    1              0.000001         else
                                        call g:NERDTree.Close()
                                    endif
    1              0.000001     else
                                    call self.createTabTree(a:dir)
                                endif

FUNCTION  208()
Called 21 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
   21              0.000088     let newObj = copy(self)
   21              0.000038     let newObj._flags = {}
   21              0.000020     return newObj

FUNCTION  <SNR>67_ResetConcealOption()
Called 5 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    5              0.000024     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
    2              0.000012         let &l:concealcursor = b:indentLine_original_concealcursor
    2              0.000012         let &l:conceallevel = b:indentLine_original_conceallevel
    2              0.000008         let b:indentLine_ConcealOptionSet = 0
    2              0.000002     endif

FUNCTION  210()
Called 60 times
Total time:   0.000625
 Self time:   0.000625

count  total (s)   self (s)
   60              0.000076     let flagstring = ""
   60              0.000161     for i in values(self._flags)
                                    let flagstring .= join(i)
                                endfor
                            
   60              0.000114     if len(flagstring) == 0
   60              0.000052         return ""
                                endif
                            
                                return '[' . flagstring . ']'

FUNCTION  214()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003     if g:NERDTreeQuitOnOpen && s:NERDTree.IsOpen()
                                    call s:NERDTree.Close()
                                endif

FUNCTION  217()
Called 5 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    5              0.000019     return exists("b:NERDTree")

FUNCTION  218()
Called 3 times
Total time:   0.000701
 Self time:   0.000701

count  total (s)   self (s)
    3              0.000013     if !exists("t:NERDTreeBufName")
                                    return
                                end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
    3              0.000678     return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  rpc#request()
Called 8 times
Total time:   0.230113
 Self time:   0.230113

count  total (s)   self (s)
    8              0.000034 	let args = a:000[:]
                            
    8              0.000038 	if args[1] == 'location' || args[1] == 'info'
    2              0.000112 		call add(args, expand('%:p'))
    2              0.000002 	endif
                            
    8              0.000039 	if has('nvim')
                            		return call('rpcrequest', args)
                            	else
    8              0.000028 		let channel = job_getchannel(args[0])
    8              0.000030 		let request = [0, 1, args[1], args[2:]]
    8              0.229647 		let [type, msgid, error, response] = json_decode(ch_evalraw(channel, json_encode(request)."\n"))
    8              0.000047 		if error
                            			throw error
                            		end
    8              0.000018 		return response
                            	end

FUNCTION  <SNR>91_FreshState()
Called 37 times
Total time:   0.017906
 Self time:   0.013387

count  total (s)   self (s)
                              "{{{
                              " A state is to know ALL relevant details about the
                              " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
                              " fast (incremental).
                              " TODO: this should be split up in detecting the block type and computing the
                              " indent for the block type, so that when we do not know the indent we do
                              " not need to clear the whole state and re-detect the block type again.
                              " State:
                              "	lnum		last indented line == prevnonblank(a:lnum - 1)
                              "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
                              "			3:<script>, 4:<style>, 5:<!--, 6:<!--[
                              "	baseindent	use this indent for line a:lnum as a start - kind of
                              "			autoindent (if block==0)
                              "	scripttype = ''	type attribute of a script tag (if block==3)
                              "	blocktagind	indent for current opening (get) and closing (set)
                              "			blocktag (if block!=0)
                              "	blocklnr	lnum of starting blocktag (if block!=0)
                              "	inattr		line {lnum} starts with attributes of a tag
   37              0.000071   let state = {}
   37              0.000141   let state.lnum = prevnonblank(a:lnum - 1)
   37              0.000067   let state.scripttype = ""
   37              0.000063   let state.blocktagind = -1
   37              0.000055   let state.block = 0
   37              0.000059   let state.baseindent = 0
   37              0.000052   let state.blocklnr = 0
   37              0.000055   let state.inattr = 0
                            
   37              0.000051   if state.lnum == 0
                                return state
                              endif
                            
                              " Heuristic:
                              " remember startline state.lnum
                              " look back for <pre, </pre, <script, </script, <style, </style tags
                              " remember stopline
                              " if opening tag found,
                              "	assume a:lnum within block
                              " else
                              "	look back in result range (stopline, startline) for comment
                              "	    \ delimiters (<!--, -->)
                              "	if comment opener found,
                              "	    assume a:lnum within comment
                              "	else
                              "	    assume usual html for a:lnum
                              "	    if a:lnum-1 has a closing comment
                              "		look back to get indent of comment opener
                              " FI
                            
                              " look back for a blocktag
   37              0.000080   let stopline2 = v:lnum + 1
   37              0.000152   if has_key(b:hi_indent, 'block') && b:hi_indent.block > 5
                                let [stopline2, stopcol2] = searchpos('<!--', 'bnW')
                              endif
   37              0.000902   let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bnW")
   37              0.000076   if stopline > 0 && stopline < stopline2
                                " ugly ... why isn't there searchstr()
                                let tagline = tolower(getline(stopline))
                                let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
                                if blocktag[0] != "/"
                                  " opening tag found, assume a:lnum within block
                                  let state.block = s:indent_tags[blocktag]
                                  if state.block == 3
                                    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
                                  endif
                                  let state.blocklnr = stopline
                                  " check preceding tags in the line:
                                  call s:CountITags(tagline[: stopcol-2])
                                  let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * shiftwidth()
                                  return state
                                elseif stopline == state.lnum
                                  " handle special case: previous line (= state.lnum) contains a
                                  " closing blocktag which is preceded by line-noise;
                                  " blocktag == "/..."
                                  let swendtag = match(tagline, '^\s*</') >= 0
                                  if !swendtag
                                    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bnW")
                                    call s:CountITags(tolower(getline(bline)[: bcol-2]))
                                    let state.baseindent = indent(bline) + (s:curind + s:nextrel) * shiftwidth()
                                    return state
                                  endif
                                endif
                              endif
   37              0.000059   if stopline > stopline2
                                let stopline = stopline2
                                let stopcol = stopcol2
                              endif
                            
                              " else look back for comment
   37              0.003527   let [comlnum, comcol, found] = searchpos('\(<!--\[\)\|\(<!--\)\|-->', 'bpnW', stopline)
   37              0.000066   if found == 2 || found == 3
                                " comment opener found, assume a:lnum within comment
                                let state.block = (found == 3 ? 5 : 6)
                                let state.blocklnr = comlnum
                                " check preceding tags in the line:
                                call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
                                if found == 2
                                  let state.baseindent = b:hi_indent.baseindent
                                endif
                                let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                return state
                              endif
                            
                              " else within usual HTML
   37              0.000200   let text = tolower(getline(state.lnum))
                            
                              " Check a:lnum-1 for closing comment (we need indent from the opening line).
                              " Not when other tags follow (might be --> inside a string).
   37              0.000141   let comcol = stridx(text, '-->')
   37              0.000093   if comcol >= 0 && match(text, '[<>]', comcol) <= 0
                                call cursor(state.lnum, comcol + 1)
                                let [comlnum, comcol] = searchpos('<!--', 'bW')
                                if comlnum == state.lnum
                                  let text = text[: comcol-2]
                                else
                                  let text = tolower(getline(comlnum)[: comcol-2])
                                endif
                                call s:CountITags(text)
                                let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                " TODO check tags that follow "-->"
                                return state
                              endif
                            
                              " Check if the previous line starts with end tag.
   37              0.000335   let swendtag = match(text, '^\s*</') >= 0
                            
                              " If previous line ended in a closing tag, line up with the opening tag.
   37              0.000334   if !swendtag && text =~ '</' . s:tagname . '\s*>\s*$'
    1              0.000004     call cursor(state.lnum, 99999)
    1              0.000031     normal! F<
    1   0.000047   0.000007     let start_lnum = HtmlIndent_FindStartTag()
    1              0.000001     if start_lnum > 0
    1              0.000004       let state.baseindent = indent(start_lnum)
    1              0.000002       if col('.') > 2
                                    " check for tags before the matching opening tag.
    1              0.000003         let text = getline(start_lnum)
    1              0.000010         let swendtag = match(text, '^\s*</') >= 0
    1   0.000040   0.000010         call s:CountITags(text[: col('.') - 2])
    1              0.000003         let state.baseindent += s:nextrel * shiftwidth()
    1              0.000001         if !swendtag
    1              0.000003           let state.baseindent += s:curind * shiftwidth()
    1              0.000001         endif
    1              0.000000       endif
    1              0.000001       return state
                                endif
                              endif
                            
                              " Else: no comments. Skip backwards to find the tag we're inside.
   36   0.001797   0.000294   let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
                              " Check if that line starts with end tag.
   36              0.000107   let text = getline(state.lnum)
   36              0.000284   let swendtag = match(text, '^\s*</') >= 0
   36   0.003250   0.000304   call s:CountITags(tolower(text))
   36              0.000219   let state.baseindent = indent(state.lnum) + s:nextrel * shiftwidth()
   36              0.000046   if !swendtag
   36              0.000100     let state.baseindent += s:curind * shiftwidth()
   36              0.000030   endif
   36              0.000041   return state

FUNCTION  222()
Called 2 times
Total time:   0.001726
 Self time:   0.001726

count  total (s)   self (s)
    2              0.000007     if exists("t:NERDTreeBufName")
    2              0.001717         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  223()
Called 2 times
Total time:   0.001747
 Self time:   0.000021

count  total (s)   self (s)
    2   0.001744   0.000018     return s:NERDTree.GetWinNum() != -1

FUNCTION  225()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     return self._type == "window"

FUNCTION  228()
Called 168 times
Total time:   0.000958
 Self time:   0.000958

count  total (s)   self (s)
  168              0.000419     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
  168              0.000190     return s:NERDTree._PathFilters

FUNCTION  rpc#stop()
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000009 	if has('nvim')
                            		return call('rpcstop', a:000)
                            	else
    1              0.000021 		return job_stop(a:1)
                            	end

FUNCTION  231()
Called 2 times
Total time:   0.024589
 Self time:   0.000019

count  total (s)   self (s)
    2   0.024588   0.000018     call self.ui.render()

FUNCTION  233()
Called 2 times
Total time:   0.000263
 Self time:   0.000257

count  total (s)   self (s)
    2   0.000016   0.000013     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let help .= "\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    silent! put =help
                                elseif !self.isMinimal()
    2              0.000006         let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
    2              0.000011         silent! put =help
    2              0.000000     endif

FUNCTION  235()
Called 1 time
Total time:   0.002501
 Self time:   0.000605

count  total (s)   self (s)
    1              0.000006     let line = getline(a:ln)
                            
    1   0.000056   0.000006     let rootLine = self.getRootLineNum()
                            
    1              0.000002     if a:ln == rootLine
                                    return self.nerdtree.root.path
                                endif
                            
    1   0.000007   0.000005     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
    1              0.000001     if a:ln < rootLine
                                    return {}
                                endif
                            
    1   0.000054   0.000005     let indent = self._indentLevelFor(line)
                            
                                " remove the tree parts and the leading space
    1   0.000071   0.000007     let curFile = self._stripMarkup(line)
                            
    1              0.000002     let dir = ""
    1              0.000001     let lnum = a:ln
   16              0.000017     while lnum > 0
   16              0.000026         let lnum = lnum - 1
   16              0.000039         let curLine = getline(lnum)
   16   0.000873   0.000075         let curLineStripped = self._stripMarkup(curLine)
                            
                                    " have we reached the top of the tree?
   16              0.000024         if lnum == rootLine
    1   0.000096   0.000010             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
    1              0.000001             break
                                    endif
   15              0.000053         if curLineStripped =~# '/$'
   14   0.000445   0.000061             let lpindent = self._indentLevelFor(curLine)
   14              0.000019             if lpindent < indent
    3              0.000006                 let indent = indent - 1
                            
    3              0.000018                 let dir = substitute (curLineStripped,'^\\', "", "") . dir
    3              0.000004                 continue
                                        endif
   11              0.000009         endif
   12              0.000008     endwhile
    1              0.000004     let curFile = self.nerdtree.root.path.drive . dir . curFile
    1   0.000470   0.000007     let toReturn = g:NERDTreePath.New(curFile)
    1              0.000002     return toReturn

FUNCTION  236()
Called 1 time
Total time:   0.002093
 Self time:   0.000652

count  total (s)   self (s)
                                " if the node is the root then return the root line no.
    1   0.000217   0.000004     if a:file_node.isRoot()
                                    return self.getRootLineNum()
                                endif
                            
    1              0.000002     let totalLines = line("$")
                            
                                " the path components we have matched so far
    1   0.000080   0.000016     let pathcomponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/ *$', '', '')]
                                " the index of the component we are searching for
    1              0.000002     let curPathComponent = 1
                            
    1   0.000067   0.000006     let fullpath = a:file_node.path.str({'format': 'UI'})
                            
    1   0.000037   0.000005     let lnum = self.getRootLineNum()
   15              0.000013     while lnum > 0
   15              0.000020         let lnum = lnum + 1
                                    " have we reached the bottom of the tree?
   15              0.000020         if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
   15              0.000032         let curLine = getline(lnum)
                            
   15   0.000441   0.000062         let indent = self._indentLevelFor(curLine)
   15              0.000019         if indent ==# curPathComponent
   15   0.000751   0.000059             let curLine = self._stripMarkup(curLine)
                            
   15              0.000057             let curPath =  join(pathcomponents, '/') . '/' . curLine
   15              0.000045             if stridx(fullpath, curPath, 0) ==# 0
    4              0.000019                 if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
    4              0.000023                     let curLine = substitute(curLine, '/ *$', '', '')
    4              0.000012                     call add(pathcomponents, curLine)
    4              0.000008                     let curPathComponent = curPathComponent + 1
                            
    4              0.000008                     if fullpath ==# curPath
    1              0.000001                         return lnum
                                                endif
    3              0.000002                 endif
    3              0.000001             endif
   14              0.000008         endif
   14              0.000009     endwhile
                                return -1

FUNCTION  237()
Called 2 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    2              0.000003     let rootLine = 1
    8              0.000048     while getline(rootLine) !~# '^\(/\|<\)'
    6              0.000014         let rootLine = rootLine + 1
    6              0.000006     endwhile
    2              0.000002     return rootLine

FUNCTION  238()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002     return self._showBookmarks

FUNCTION  239()
Called 148 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
  148              0.000150     return self._showFiles

FUNCTION  HtmlIndent()
Called 38 times
Total time:   0.034368
 Self time:   0.013790

count  total (s)   self (s)
                              "{{{
   38              0.000128   if prevnonblank(v:lnum - 1) < 1
                                " First non-blank line has no indent.
                                return 0
                              endif
                            
   38              0.000197   let curtext = tolower(getline(v:lnum))
   38              0.000102   let indentunit = shiftwidth()
                            
   38              0.000144   let b:hi_newstate = {}
   38              0.000097   let b:hi_newstate.lnum = v:lnum
                            
                              " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
                              " a tag works very differently. Do not do this when the line starts with
                              " "<", it gets the "htmlTag" ID but we are not inside a tag then.
   38              0.000437   if curtext !~ '^\s*<'
   26              0.000623     normal! ^
   26              0.005191     let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
   26              0.000063     let foundHtmlString = 0
   43              0.000145     for synid in reverse(stack)
   17              0.000065       let name = synIDattr(synid, "name")
   17              0.000071       if index(b:hi_insideStringNames, name) >= 0
                                    let foundHtmlString = 1
                                  elseif index(b:hi_insideTagNames, name) >= 0
                                    " Yes, we are inside a tag.
                                    let indent = s:InsideTag(foundHtmlString)
                                    if indent >= 0
                                      " Do not keep the state. TODO: could keep the block type.
                                      let b:hi_indent.lnum = 0
                                      return indent
                                    endif
                                  endif
   17              0.000015     endfor
   26              0.000024   endif
                            
                              " does the line start with a closing tag?
   38              0.000392   let swendtag = match(curtext, '^\s*</') >= 0
                            
   38              0.000221   if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
                                " use state (continue from previous line)
    1              0.000001   else
                                " start over (know nothing)
   37   0.018289   0.000383     let b:hi_indent = s:FreshState(v:lnum)
   37              0.000022   endif
                            
   38              0.000059   if b:hi_indent.block >= 2
                                " within block
                                let endtag = s:endtags[b:hi_indent.block]
                                let blockend = stridx(curtext, endtag)
                                if blockend >= 0
                                  " block ends here
                                  let b:hi_newstate.block = 0
                                  " calc indent for REST OF LINE (may start more blocks):
                                  call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
                                  if swendtag && b:hi_indent.block != 5
                                    let indent = b:hi_indent.blocktagind + s:curind * indentunit
                                    let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
                                  else
                                    let indent = s:Alien{b:hi_indent.block}()
                                    let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
                                  endif
                                else
                                  " block continues
                                  " indent this line with alien method
                                  let indent = s:Alien{b:hi_indent.block}()
                                endif
                              else
                                " not within a block - within usual html
   38              0.000109     let b:hi_newstate.block = b:hi_indent.block
   38              0.000042     if swendtag
                                  " The current line starts with an end tag, align with its start tag.
    3              0.000009       call cursor(v:lnum, 1)
    3   0.000127   0.000019       let start_lnum = HtmlIndent_FindStartTag()
    3              0.000005       if start_lnum > 0
                                    " check for the line starting with something inside a tag:
                                    " <sometag               <- align here
                                    "    attr=val><open>     not here
    3              0.000009         let text = getline(start_lnum)
    3              0.000024         let angle = matchstr(text, '[<>]')
    3              0.000006         if angle == '>'
                                      call cursor(start_lnum, 1)
                                      normal! f>%
                                      let start_lnum = line('.')
                                      let text = getline(start_lnum)
                                    endif
                            
    3              0.000009         let indent = indent(start_lnum)
    3              0.000006         if col('.') > 2
    3              0.000023           let swendtag = match(text, '^\s*</') >= 0
    3   0.000101   0.000026           call s:CountITags(text[: col('.') - 2])
    3              0.000009           let indent += s:nextrel * shiftwidth()
    3              0.000003           if !swendtag
    3              0.000008             let indent += s:curind * shiftwidth()
    3              0.000002           endif
    3              0.000001         endif
    3              0.000003       else
                                    " not sure what to do
                                    let indent = b:hi_indent.baseindent
                                  endif
    3              0.000007       let b:hi_newstate.baseindent = indent
    3              0.000002     else
   35   0.002705   0.000216       call s:CountTagsAndState(curtext)
   35              0.000075       let indent = b:hi_indent.baseindent
   35              0.000158       let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
   35              0.000024     endif
   38              0.000022   endif
                            
   38              0.000077   let b:hi_lasttick = b:changedtick
   38              0.000168   call extend(b:hi_indent, b:hi_newstate, "force")
   38              0.000047   return indent

FUNCTION  <SNR>9_SynSet()
Called 5 times
Total time:   0.140383
 Self time:   0.009927

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    5              0.001746   syn clear
    5              0.000072   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    5              0.000026   let s = expand("<amatch>")
    5              0.000015   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    5              0.000007   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
   10              0.000084     for name in split(s, '\.')
    5   0.138198   0.007742       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    5              0.000017     endfor
    5              0.000005   endif

FUNCTION  lightline#update_once()
Called 308 times
Total time:   0.005153
 Self time:   0.005153

count  total (s)   self (s)
  308              0.003166   if !exists('w:lightline') || w:lightline
                                call lightline#update()
                              endif

FUNCTION  <SNR>73_line()
Called 53 times
Total time:   0.068045
 Self time:   0.031676

count  total (s)   self (s)
   53              0.000135   let _ = a:tabline ? '' : '%{lightline#link()}'
   53              0.000148   if s:lightline.palette == {}
                                call lightline#colorscheme()
                              endif
   53              0.000276   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
   53              0.000266   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
   53              0.000284   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
   53              0.000139   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
   53              0.000289   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
   53   0.013474   0.000755   let [lt, lc, ll] = s:expand(copy(l_))
   53              0.000314   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
   53   0.013931   0.000741   let [rt, rc, rl] = s:expand(copy(r_))
  141              0.000301   for i in range(len(lt))
   88              0.000439     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
  281              0.000564     for j in range(len(lt[i]))
  193              0.002329       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
  193              0.002042       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
  193              0.000755       if j < len(lt[i]) - 1 && s.left !=# ''
  105   0.007811   0.001273         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
  105              0.000090       endif
  193              0.000132     endfor
   88              0.000589     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
   88              0.000779     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
   88              0.000065   endfor
   53              0.000173   let _ .= '%#LightlineMiddle_' . mode . '#%='
  194              0.000391   for i in reverse(range(len(rt)))
  141              0.000880     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
  141              0.001066     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
  141              0.000617     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
  352              0.000715     for j in range(len(rt[i]))
  211              0.002189       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
  211              0.002118       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
  211              0.000746       if j < len(rt[i]) - 1 && s.right !=# ''
   70   0.004698   0.000776         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
   70              0.000061       endif
  211              0.000149     endfor
  141              0.000092   endfor
   53              0.000107   return _

FUNCTION  <SNR>44_Map()
Called 8 times
Total time:   0.010953
 Self time:   0.000719

count  total (s)   self (s)
                              " Set mappings:
    8              0.000010   try
    8              0.000017     let save_keymap = &keymap
    8              0.000014     let save_iminsert = &iminsert
    8              0.000009     let save_imsearch = &imsearch
    8              0.000045     let save_cpo = &cpo
    8              0.000109     set keymap=
    8              0.000050     set cpo&vim
    8              0.000057     silent! doautocmd <nomodeline> User delimitMate_map
    8   0.000261   0.000034     if s:get('autoclose')
    8   0.007880   0.000047       call s:AutoClose()
    8              0.000006     else
                                  call s:NoAutoClose()
                                endif
    8   0.002212   0.000038     call s:ExtraMappings()
    8              0.000010   finally
    8              0.000063     let &cpo = save_cpo
    8              0.000045     let &keymap = save_keymap
    8              0.000048     let &iminsert = save_iminsert
    8              0.000022     let &imsearch = save_imsearch
    8              0.000010   endtry
                            
    8              0.000016   let b:delimitMate_enabled = 1

FUNCTION  phpcd#UpdateIndex()
Called 2 times
Total time:   0.068193
 Self time:   0.000208

count  total (s)   self (s)
    2              0.000013 	if !exists('g:phpid_channel_id')
                            		return
                            	endif
                            
    2              0.000006 	let g:phpcd_need_update = 0
    2   0.068153   0.000168 	let nsuse = rpc#request(g:phpcd_channel_id, 'nsuse', expand('%:p'))
                            
    2              0.000004 	if !nsuse.class
    2              0.000002 		return
                            	endif
                            
                            	let classname = nsuse.namespace . '\' . nsuse.class
                            	return rpc#notify(g:phpid_channel_id, 'update', classname)

FUNCTION  <SNR>78_SetUpCompleteopt()
Called 22 times
Total time:   0.000555
 Self time:   0.000555

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
   22              0.000183   set completeopt-=menu
   22              0.000077   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
   22              0.000067   set completeopt-=longest
                            
   22              0.000036   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
                              endif

FUNCTION  phpcd#SelectOne()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000004 	let items = a:items
    1              0.000003 	let len = len(items)
    1              0.000002 	if (len == 1)
    1              0.000003 		return items[0]
                            	elseif (len == 0)
                            		return
                            	endif
                            
                            	let list = []
                            	for i in range(1, len)
                            		call add(list, printf("%2d %s", i, items[i - 1]))
                            	endfor
                            	let index = inputlist(list)
                            	if index >= 1 && index <= len
                            		return items[index - 1]
                            	endif

FUNCTION  240()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000003     return self._showHelp

FUNCTION  241()
Called 168 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
  168              0.000169     return self._showHidden

FUNCTION  242()
Called 30 times
Total time:   0.000812
 Self time:   0.000777

count  total (s)   self (s)
                                " have to do this work around because match() returns bytes, not chars
   30              0.000254     let numLeadBytes = match(a:line, '\M\[^ '.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']')
                                " The next line is a backward-compatible workaround for strchars(a:line(0:numLeadBytes-1]). strchars() is in 7.3+
   30              0.000350     let leadChars = len(split(a:line[0:numLeadBytes-1], '\zs'))
                            
   30   0.000142   0.000107     return leadChars / s:UI.IndentWid()

FUNCTION  243()
Called 30 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
   30              0.000024     return 2

FUNCTION  244()
Called 168 times
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
  168              0.000185     return self._ignoreEnabled == 1

FUNCTION  245()
Called 6 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    6              0.000006     return g:NERDTreeMinimalUI

FUNCTION  246()
Called 32 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   32              0.000173     return '^\(['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+\)'

FUNCTION  248()
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000003     if !has_key(self, '_screenState')
                                    return
                                endif
    1              0.000007     exec("silent vertical resize " . self._screenState['oldWindowSize'])
                            
    1              0.000002     let old_scrolloff=&scrolloff
    1              0.000003     let &scrolloff=0
    1              0.000003     call cursor(self._screenState['oldTopLine'], 0)
    1              0.000007     normal! zt
    1              0.000007     call setpos(".", self._screenState['oldPos'])
    1              0.000004     let &scrolloff=old_scrolloff

FUNCTION  delimitMate#JumpOut()
Called 1 time
Total time:   0.001149
 Self time:   0.000051

count  total (s)   self (s)
    1   0.000929   0.000012   if s:is_forbidden(a:char)
                                return a:char
                              endif
    1   0.000204   0.000023   let jump = s:is_jump(a:char)
    1              0.000002   if jump == 1
                                " HACK: Instead of <Right>, we remove the char to be jumped over and
                                " insert it again. This will trigger re-indenting via 'indentkeys'.
                                " Ref: https://github.com/Raimondi/delimitMate/issues/168
                                return "\<Del>".a:char
                              elseif jump == 3
                                return s:joinUndo() . "\<Right>" . s:joinUndo() . "\<Right>"
                              elseif jump == 5
                                return "\<Down>\<C-O>I" . s:joinUndo() . "\<Right>"
                              else
    1              0.000001     return a:char
                              endif

FUNCTION  <SNR>44_AutoClose()
Called 8 times
Total time:   0.007833
 Self time:   0.003568

count  total (s)   self (s)
                              " Add matching pair and jump to the midle:
                              " inoremap <silent> <buffer> ( ()<Left>
    8              0.000014   let i = 0
   34   0.001258   0.000250   while i < len(s:get('matchpairs_list'))
   26   0.001585   0.000269     let ld = s:get('left_delims')[i] == '|' ? '<bar>' : s:get('left_delims')[i]
   26   0.001528   0.000249     let rd = s:get('right_delims')[i] == '|' ? '<bar>' : s:get('right_delims')[i]
   26              0.000555     exec 'inoremap <expr><silent> <Plug>delimitMate' . ld. ' <SID>TriggerAbb().delimitMate#ParenDelim("' . escape(rd, '|') . '")'
   26              0.000287     exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
   26              0.000037     let i += 1
   26              0.000023   endwhile
                            
                              " Exit from inside the matching pair:
   34   0.000269   0.000065   for delim in s:get('right_delims')
   26              0.000053     let delim = delim == '|' ? '<bar>' : delim
   26              0.000354     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb().delimitMate#JumpOut("\' . delim . '")'
   26              0.000252     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate'. delim
   26              0.000019   endfor
                            
                              " Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                              " inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
   32   0.000311   0.000072   for delim in s:get('quotes_list')
   24              0.000033     if delim == '|'
                                  let delim = '<Bar>'
                                endif
   24              0.000363     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb()."<C-R>=delimitMate#QuoteDelim(\"\\\' . delim . '\")<CR>"'
   24              0.000244     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate' . delim
   24              0.000016   endfor
                            
                              " Try to fix the use of apostrophes (kept for backward compatibility):
                              " inoremap <silent> <buffer> n't n't
    8   0.000254   0.000035   for map in s:get('apostrophes_list')
                                exec "inoremap <silent> " . map . " " . map
                                exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
                              endfor

FUNCTION  IsTagStart()
Called 38 times
Total time:   0.001065
 Self time:   0.001065

count  total (s)   self (s)
   38              0.000930     if a:line =~? '^\s*@if' || a:line =~? '^\s*@else' || a:line =~? '^\s*@for' || a:line =~? '^\s*@sect' || a:line =~? '^\s*@while'
   13              0.000015         return 1
                                endif
                            
   25              0.000023     return 0

FUNCTION  <SNR>67_SetConcealOption()
Called 7 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
    7              0.000011     if !g:indentLine_setConceal
                                    return
                                endif
    7              0.000027     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
    5              0.000010         let b:indentLine_ConcealOptionSet = 1
    5              0.000013         let b:indentLine_original_concealcursor = &l:concealcursor
    5              0.000011         let b:indentLine_original_conceallevel = &l:conceallevel
    5              0.000029         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    5              0.000029         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    5              0.000002     endif

FUNCTION  251()
Called 32 times
Total time:   0.001554
 Self time:   0.001372

count  total (s)   self (s)
   32              0.000046     let line = a:line
                                " remove the tree parts and the leading space
   32   0.000541   0.000359     let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                " strip off any read only flag
   32              0.000197     let line = substitute (line, ' \['.g:NERDTreeGlyphReadOnly.'\]', "","")
                            
                                " strip off any bookmark flags
   32              0.000143     let line = substitute (line, ' {[^}]*}', "","")
                            
                                " strip off any executable flags
   32              0.000146     let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                " strip off any generic flags
   32              0.000142     let line = substitute (line, '\[[^]]*\]', "","")
                            
   32              0.000142     let line = substitute (line,' -> .*',"","") " remove link to
                            
   32              0.000034     return line

FUNCTION  252()
Called 2 times
Total time:   0.024570
 Self time:   0.000347

count  total (s)   self (s)
    2              0.000013     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    2              0.000005     let curLine = line(".")
    2              0.000005     let curCol = col(".")
    2              0.000008     let topLine = line("w0")
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    2              0.000050     silent 1,$delete _
                            
    2   0.000276   0.000013     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    2   0.000008   0.000006     if !self.isMinimal()
    2              0.000011         call setline(line(".")+1, "")
    2              0.000008         call cursor(line(".")+1, col("."))
    2              0.000002     endif
                            
    2   0.000011   0.000008     if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                " add the 'up a dir' line
    2   0.000007   0.000004     if !self.isMinimal()
    2   0.000016   0.000013         call setline(line(".")+1, s:UI.UpDirLine())
    2              0.000008         call cursor(line(".")+1, col("."))
    2              0.000002     endif
                            
                                " draw the header line
    2   0.000426   0.000026     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    2              0.000010     call setline(line(".")+1, header)
    2              0.000008     call cursor(line(".")+1, col("."))
                            
                                " draw the tree
    2   0.023582   0.000033     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    2              0.000015     silent 1,1delete _
                            
                                " restore the view
    2              0.000006     let old_scrolloff=&scrolloff
    2              0.000008     let &scrolloff=0
    2              0.000005     call cursor(topLine, 1)
    2              0.000031     normal! zt
    2              0.000005     call cursor(curLine, curCol)
    2              0.000006     let &scrolloff = old_scrolloff
                            
    2              0.000010     setlocal readonly nomodifiable

FUNCTION  <SNR>67_Disable()
Called 5 times
Total time:   0.000263
 Self time:   0.000102

count  total (s)   self (s)
    5              0.000024     if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                elseif exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    return
                                elseif s:Filter() == 0
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
                                endif

FUNCTION  <SNR>4_BMFilename()
Called 3 times
Total time:   0.001093
 Self time:   0.000372

count  total (s)   self (s)
    3              0.000013   if isdirectory(a:name)
                                return
                              endif
    3   0.000615   0.000019   let munge = <SID>BMMunge(a:name, a:num)
    3   0.000142   0.000017   let hash = <SID>BMHash(munge)
    3              0.000004   if s:bmenu_short == 0
    3              0.000015     let name = 'an ' . g:bmenu_priority . '.' . hash . ' &Buffers.' . munge
    3              0.000003   else
                                let name = 'an ' . g:bmenu_priority . '.' . hash . '.' . hash . ' &Buffers.' . <SID>BMHash2(munge) . munge
                              endif
                              " set 'cpo' to include the <CR>
    3              0.000015   let cpo_save = &cpo
    3              0.000023   set cpo&vim
    3              0.000216   exe name . ' :confirm b' . a:num . '<CR>'
    3              0.000025   let &cpo = cpo_save

FUNCTION  260()
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000003     return '.. (up a dir)'

FUNCTION  <SNR>45_is_forbidden()
Called 9 times
Total time:   0.004354
 Self time:   0.000281

count  total (s)   self (s)
    9   0.000121   0.000066   if s:is_excluded_ft(&filetype)
                                return 1
                              endif
    9   0.000240   0.000039   if !s:get('excluded_regions_enabled')
                                return 0
                              endif
    9   0.003649   0.000051   let region = s:get_syn_name()
    9   0.000299   0.000080   return index(s:get('excluded_regions_list'), region) >= 0

FUNCTION  youcompleteme#CompleteFunc()
Called 432 times
Total time:   0.002949
 Self time:   0.002949

count  total (s)   self (s)
  432              0.000802   if a:findstart
  216              0.000825     return s:completion.start_column - 1
                              endif
  216              0.000340   return s:completion.candidates

FUNCTION  GetLastRealCodeLNum()
Called 31 times
Total time:   0.004723
 Self time:   0.004723

count  total (s)   self (s)
                            
   31              0.000059     let lnum = a:startline
                            
   31              0.000071     if b:GetLastRealCodeLNum_ADD && b:GetLastRealCodeLNum_ADD == lnum + 1
                            	let lnum = b:GetLastRealCodeLNum_ADD
                                endif
                            
   31              0.000051     while lnum > 1
   31              0.000087 	let lnum = prevnonblank(lnum)
   31              0.000080 	let lastline = getline(lnum)
                            
   31              0.000058 	if b:InPHPcode_and_script && lastline =~ '?>\s*$'
                            	    let lnum = lnum - 1
                            	elseif lastline =~ '^\s*?>.*<?\%(php\)\=\s*$'
                            	    let lnum = lnum - 1
                            	elseif lastline =~ '^\s*\%(//\|#\|/\*.*\*/\s*$\)'
                            	    let lnum = lnum - 1
                            	elseif lastline =~ '\*/\s*$'
                            	    call cursor(lnum, 1)
                            	    if lastline !~ '^\*/'
                            		call search('\*/', 'W')
                            	    endif
                            	    let lnum = searchpair('/\*', '', '\*/', s:searchpairflags, 'Skippmatch2()')
                            
                            	    let lastline = getline(lnum)
                            	    if lastline =~ '^\s*/\*'
                            		let lnum = lnum - 1
                            	    else
                            		break
                            	    endif
                            
                            
                            	elseif lastline =~? '\%(//\s*\|?>.*\)\@<!<?\%(php\)\=\s*$\|^\s*<script\>'
                            
                            	    while lastline !~ '\(<?.*\)\@<!?>' && lnum > 1
                            		let lnum = lnum - 1
                            		let lastline = getline(lnum)
                            	    endwhile
                            	    if lastline =~ '^\s*?>'
                            		let lnum = lnum - 1
                            	    else
                            		break
                            	    endif
                            
                            
                            	elseif lastline =~? '^\a\w*;\=$' && lastline !~? s:notPhpHereDoc
                            	    let tofind=substitute( lastline, '\(\a\w*\);\=', '<<<\\s*[''"]\\=\1[''"]\\=$', '')
                            	    while getline(lnum) !~? tofind && lnum > 1
                            		let lnum = lnum - 1
                            	    endwhile
                            	elseif lastline =~ '^[^''"`]*[''"`][;,]'.s:endline
                            
                            	    let tofind=substitute( lastline, '^.*\([''"`]\)[;,].*$', '^[^\1]\\+[\1]$\\|^[^\1]\\+[=([]\\s*[\1]', '')
                            	    let trylnum = lnum
                            	    while getline(trylnum) !~? tofind && trylnum > 1
                            		let trylnum = trylnum - 1
                            	    endwhile
                            
                            	    if trylnum == 1
                            		break
                            	    else
                            		if lastline =~ ';'.s:endline
                            		    while getline(trylnum) !~? s:terminated && getline(trylnum) !~? '{'.s:endline && trylnum > 1
                            			let trylnum = prevnonblank(trylnum - 1)
                            		    endwhile
                            
                            
                            		    if trylnum == 1
                            			break
                            		    end
                            		end
                            		let lnum = trylnum
                            	    end
                            	else
   31              0.000032 	    break
                            	endif
                                endwhile
                            
   31              0.000070     if lnum==1 && getline(lnum) !~ '<?'
                            	let lnum=0
                                endif
                            
   31              0.000061     if b:InPHPcode_and_script && 1 > b:InPHPcode
                            	let b:InPHPcode_and_script = 0
                                endif
                            
   31              0.000037     return lnum

FUNCTION  emmet#toString()
Called 3 times
Total time:   0.005862
 Self time:   0.000684

count  total (s)   self (s)
    3              0.000006   let current = a:1
    3              0.000003   if a:0 > 1
    3              0.000004     let type = a:2
    3              0.000001   else
                                let type = &filetype
                              endif
    3              0.000011   if len(type) ==# 0 | let type = 'html' | endif
    3              0.000003   if a:0 > 2
    3              0.000004     let inline = a:3
    3              0.000001   else
                                let inline = 0
                              endif
    3              0.000003   if a:0 > 3
    3              0.000006     if type(a:4) ==# 1
                                  let filters = split(a:4, '\s*,\s*')
                                else
    3              0.000003       let filters = a:4
    3              0.000003     endif
    3              0.000003   else
                                let filters = ['html']
                              endif
    3              0.000002   if a:0 > 4
    3              0.000004     let group_itemno = a:5
    3              0.000001   else
                                let group_itemno = 0
                              endif
    3              0.000002   if a:0 > 5
    3              0.000003     let indent = a:6
    3              0.000003   else
                                let indent = ''
                              endif
                            
    3   0.000272   0.000020   let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
    3              0.000005   let itemno = 0
    3              0.000003   let str = ''
    3   0.000106   0.000016   let rtype = emmet#lang#type(type)
    6              0.000012   while itemno < current.multiplier
    3              0.000008     if len(current.name)
    3              0.000003       if current.multiplier ==# 1
    3   0.002861   0.000881         let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(group_itemno, current), indent)
    3              0.000003       else
                                    let inner = emmet#lang#{rtype}#toString(s:emmet_settings, current, type, inline, filters, s:itemno(itemno, current), indent)
                                  endif
    3              0.000005       if current.multiplier > 1
                                    let inner = substitute(inner, '\$#', '$line'.(itemno+1).'$', 'g')
                                  endif
    3              0.000012       let str .= inner
    3              0.000002     else
                                  let snippet = current.snippet
                                  if len(snippet) ==# 0
                                    let snippets = emmet#getResource(type, 'snippets', {})
                                    if !empty(snippets) && has_key(snippets, 'emmet_snippet')
                                      let snippet = snippets['emmet_snippet']
                                    endif
                                  endif
                                  if len(snippet) > 0
                                    let tmp = snippet
                                    let tmp = substitute(tmp, '\${emmet_name}', current.name, 'g')
                                    let snippet_node = emmet#newNode()
                                    let snippet_node.value = '{'.tmp.'}'
                                    let snippet_node.important = current.important
                                    let snippet_node.multiplier = current.multiplier
                                    let str .= emmet#lang#{rtype}#toString(s:emmet_settings, snippet_node, type, inline, filters, s:itemno(group_itemno, current), indent)
                                    if current.multiplier > 1
                                      let str .= "\n"
                                    endif
                                  else
                                    if len(current.name)
                                      let str .= current.name
                                    endif
                                    if len(current.value)
                                      let text = current.value[1:-2]
                                      if dollar_expr
                                        " TODO: regexp engine specified
                                        if exists('&regexpengine')
                                          let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        else
                                          let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", max([itemno, group_itemno])+1).submatch(2)', 'g')
                                        endif
                                        let text = substitute(text, '\${nr}', "\n", 'g')
                                        let text = substitute(text, '\\\$', '$', 'g')
                                      endif
                                      let str .= text
                                    endif
                                  endif
                                  let inner = ''
                                  if len(current.child)
                                    for n in current.child
                                      let inner .= emmet#toString(n, type, inline, filters, s:itemno(group_itemno, n), indent)
                                    endfor
                                  else
                                    let inner = current.value[1:-2]
                                  endif
                                  let inner = substitute(inner, "\n", "\n" . indent, 'g')
                                  let str = substitute(str, '\${:\(\w\+\)}', '\=s:localvar(current, submatch(1))', '')
                                  let str = substitute(str, '\${child}', inner, '')
                                endif
    3              0.000008     let itemno = itemno + 1
    3              0.000003   endwhile
    3              0.000009   return str

FUNCTION  emmet#lang#html#toString()
Called 3 times
Total time:   0.004381
 Self time:   0.001442

count  total (s)   self (s)
    3              0.000006   let settings = a:settings
    3              0.000004   let current = a:current
    3              0.000003   let type = a:type
    3              0.000003   let inline = a:inline
    3              0.000003   let filters = a:filters
    3              0.000003   let itemno = a:itemno
    3              0.000004   let indent = a:indent
    3   0.000261   0.000018   let dollar_expr = emmet#getResource(type, 'dollar_expr', 1)
    3   0.000253   0.000018   let q = emmet#getResource(type, 'quote_char', '"')
    3   0.000253   0.000018   let ct = emmet#getResource(type, 'comment_type', 'both')
    3   0.000405   0.000017   let an = emmet#getResource(type, 'attribute_name', {})
    3   0.000231   0.000022   let empty_element_suffix = emmet#getResource(type, 'empty_element_suffix', settings.html.empty_element_suffix)
                            
    3   0.000073   0.000019   if emmet#useFilter(filters, 'haml')
                                return emmet#lang#haml#toString(settings, current, type, inline, filters, itemno, indent)
                              endif
    3   0.000055   0.000009   if emmet#useFilter(filters, 'slim')
                                return emmet#lang#slim#toString(settings, current, type, inline, filters, itemno, indent)
                              endif
                            
    3              0.000003   let comment = ''
    3              0.000006   let current_name = current.name
    3              0.000004   if dollar_expr
    3              0.000020     let current_name = substitute(current_name, '\$$', itemno+1, '')
    3              0.000001   endif
                            
    3              0.000004   let str = ''
    3              0.000007   if len(current_name) == 0
                                let text = current.value[1:-2]
                                if dollar_expr
                                  " TODO: regexp engine specified
                                  let nr = itemno + 1
                                  if exists('&regexpengine')
                                    let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
                                  else
                                    let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr).submatch(3)', 'g')
                                  endif
                                  let text = substitute(text, '\${nr}', "\n", 'g')
                                  let text = substitute(text, '\\\$', '$', 'g')
                                endif
                                return text
                              endif
    3              0.000004   if len(current_name) > 0
    3              0.000007     let str .= '<' . current_name
    3              0.000001   endif
    9   0.000131   0.000039   for attr in emmet#util#unique(current.attrs_order + keys(current.attr))
    6              0.000014     if !has_key(current.attr, attr)
    5              0.000004       continue
                                endif
    1              0.000001     let Val = current.attr[attr]
    1              0.000003     if type(Val) == 2 && Val == function('emmet#types#true')
                                  unlet Val
                                  let Val = 'true'
                                  if g:emmet_html5
                                    let str .= ' ' . attr
                                  else
                                    let str .= ' ' . attr . '=' . q . attr . q
                                  endif
                                  if emmet#useFilter(filters, 'c')
                                    if attr ==# 'id' | let comment .= '#' . Val | endif
                                    if attr ==# 'class' | let comment .= '.' . Val | endif
                                  endif
                                else
    1              0.000001       if dollar_expr
    1              0.000004         while Val =~# '\$\([^#{]\|$\)'
                                      " TODO: regexp engine specified
                                      if exists('&regexpengine')
                                        let Val = substitute(Val, '\%#=1\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                      else
                                        let Val = substitute(Val, '\(\$\+\)\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d", itemno+1).submatch(2)', 'g')
                                      endif
                                    endwhile
    1              0.000005         let attr = substitute(attr, '\$$', itemno+1, '')
    1              0.000001       endif
    1   0.000021   0.000006       if attr ==# 'class' && emmet#useFilter(filters, 'bem')
                                    let vals = split(Val, '\s\+')
                                    let Val = ''
                                    let lead = ''
                                    for _val in vals
                                      if len(Val) > 0
                                        let Val .= ' '
                                      endif
                                      if _val =~# '^_'
                                        if has_key(current.parent.attr, 'class')
                                          let lead = current.parent.attr["class"]
                                          if _val =~# '^__'
                                            let Val .= lead . _val
                                          else
                                            let Val .= lead . ' ' . lead . _val
                                          endif
                                        else
                                          let lead = split(vals[0], '_')[0]
                                          let Val .= lead . _val
                                        endif
                                      elseif _val =~# '^-'
                                        for l in split(_val, '_')
                                          if len(Val) > 0
                                            let Val .= ' '
                                          endif
                                          let l = substitute(l, '^-', '__', '')
                                          if len(lead) == 0
                                            let pattr = current.parent.attr
                                            if has_key(pattr, 'class')
                                              let lead = split(pattr['class'], '\s\+')[0]
                                            endif
                                          endif
                                          let Val .= lead . l
                                          let lead .= l . '_'
                                        endfor
                                      else
                                        let Val .= _val
                                      endif
                                    endfor
                                  endif
    1              0.000003       if has_key(an, attr)
                                    let attr = an[attr]
                                  endif
    1   0.000033   0.000020       if emmet#isExtends(type, 'jsx') && Val =~ '^{.*}$'
                                    let str .= ' ' . attr . '=' . Val
                                  else
    1              0.000005         let str .= ' ' . attr . '=' . q . Val . q
    1              0.000000       endif
    1   0.000019   0.000003       if emmet#useFilter(filters, 'c')
                                    if attr ==# 'id' | let comment .= '#' . Val | endif
                                    if attr ==# 'class' | let comment .= '.' . Val | endif
                                  endif
    1              0.000001     endif
    1              0.000002     unlet Val
    1              0.000001   endfor
    3              0.000008   if len(comment) > 0 && ct ==# 'both'
                                let str = '<!-- ' . comment . " -->\n" . str
                              endif
    3              0.000004   if current.empty
                                let str .= ' />'
                              elseif stridx(','.settings.html.empty_elements.',', ','.current_name.',') != -1
                                let str .= empty_element_suffix
                              else
    3              0.000003     let str .= '>'
    3              0.000009     let text = current.value[1:-2]
    3              0.000003     if dollar_expr
                                  " TODO: regexp engine specified
    3              0.000006       let nr = itemno + 1
    3              0.000008       if exists('&regexpengine')
    3              0.000048         let text = substitute(text, '\%#=1\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
    3              0.000002       else
                                    let text = substitute(text, '\%(\\\)\@\<!\(\$\+\)\(@-\?[0-9]\+\)\{0,1}\([^{#]\|$\)', '\=printf("%0".len(submatch(1))."d",s:dollar_add(submatch(2)[1:],nr)).submatch(3)', 'g')
                                  endif
    3              0.000015       let text = substitute(text, '\${nr}', "\n", 'g')
    3              0.000013       let text = substitute(text, '\\\$', '$', 'g')
    3              0.000006       if text != ''
                                    let str = substitute(str, '\("\zs$#\ze"\|\s\zs\$#"\|"\$#\ze\s\)', text, 'g')
                                  endif
    3              0.000000     endif
    3              0.000005     let str .= text
    3              0.000007     let nc = len(current.child)
    3              0.000003     let dr = 0
    3              0.000003     if nc > 0
    2              0.000006       for n in range(nc)
    1              0.000002         let child = current.child[n]
    1              0.000006         if child.multiplier > 1 || (child.multiplier == 1 && len(child.child) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1) || settings.html.block_all_childless
                                      let str .= "\n" . indent
                                      let dr = 1
                                    elseif len(current_name) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1
    1              0.000006           if nc > 1 || (len(child.name) > 0 && stridx(','.settings.html.inline_elements.',', ','.child.name.',') == -1)
    1              0.000002             let str .= "\n" . indent
    1              0.000001             let dr = 1
    1              0.000003           elseif current.multiplier == 1 && nc == 1 && len(child.name) == 0
                                        let str .= "\n" . indent
                                        let dr = 1
                                      endif
    1              0.000000         endif
    1              0.000183         let inner = emmet#toString(child, type, 0, filters, itemno, indent)
    1              0.000019         let inner = substitute(inner, "^\n", '', 'g')
    1              0.000016         let inner = substitute(inner, "\n", "\n" . escape(indent, '\'), 'g')
    1              0.000017         let inner = substitute(inner, "\n" . escape(indent, '\') . '$', '', 'g')
    1              0.000004         let str .= inner
    1              0.000002       endfor
    1              0.000001     else
    2              0.000010       if settings.html.indent_blockelement && len(current_name) > 0 && stridx(','.settings.html.inline_elements.',', ','.current_name.',') == -1 || settings.html.block_all_childless
                                    let str .= "\n" . indent . '${cursor}' . "\n"
                                  else
    2              0.000005         let str .= '${cursor}'
    2              0.000002       endif
    2              0.000001     endif
    3              0.000003     if dr
    1              0.000003       let str .= "\n"
    1              0.000001     endif
    3              0.000013     let str .= '</' . current_name . '>'
    3              0.000002   endif
    3              0.000009   if len(comment) > 0
                                if ct ==# 'lastonly'
                                  let str .= '<!-- ' . comment . ' -->'
                                else
                                  let str .= "\n<!-- /" . comment . ' -->'
                                endif
                              endif
    3              0.000018   if len(current_name) > 0 && current.multiplier > 0 || stridx(','.settings.html.block_elements.',', ','.current_name.',') != -1
    3              0.000007     let str .= "\n"
    3              0.000003   endif
    3              0.000005   return str

FUNCTION  <SNR>53_splittable()
Called 1 time
Total time:   0.000026
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000025   0.000008   return s:present(a:dict, 'up', 'down') && &lines > 15 || s:present(a:dict, 'left', 'right') && &columns > 40

FUNCTION  <SNR>45_set()
Called 184 times
Total time:   0.004956
 Self time:   0.004956

count  total (s)   self (s)
  184              0.000315   let scope = a:0 ? a:1 : 's'
  184              0.000442   let bufnr = bufnr('%')
  184              0.000617   if !exists('s:options[bufnr]')
    2              0.000012     let s:options[bufnr] = {}
    2              0.000001   endif
  184              0.000230   if scope == 's'
  184              0.000535     let name = 's:options.' . bufnr . '.' . a:name
  184              0.000128   else
                                let name = scope . ':delimitMate_' . a:name
                                if exists('name')
                                  exec 'unlet! ' . name
                                endif
                              endif
  184              0.001203   exec 'let ' . name . ' = a:value'

FUNCTION  phpcd#GetCurrentNameSpace()
Called 2 times
Total time:   0.079775
 Self time:   0.000153

count  total (s)   self (s)
    2   0.079765   0.000143 	let nsuse = rpc#request(g:phpcd_channel_id, 'nsuse', expand('%:p'))
                            
    2              0.000007 	return [nsuse.namespace, nsuse.imports]

FUNCTION  <SNR>78_OnDeleteChar()
Called 24 times
Total time:   0.002750
 Self time:   0.000777

count  total (s)   self (s)
   24   0.002325   0.000352   if !s:AllowedToCompleteInCurrentBuffer()
                                return a:key
                              endif
                            
   24              0.000128   call timer_stop( s:pollers.completion.id )
   24              0.000060   if pumvisible()
   15              0.000066     return "\<C-y>" . a:key
                              endif
    9              0.000014   return a:key

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 1 time
Total time:   0.181994
 Self time:   0.000037

count  total (s)   self (s)
    1   0.181991   0.000034     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  IsTagEnd()
Called 38 times
Total time:   0.000699
 Self time:   0.000699

count  total (s)   self (s)
   38              0.000545     if a:line =~? '^\s*@end' || a:line =~? '^\s*@stop' || a:line =~? '^\s*@else'
    2              0.000002         return 1
                                endif
                            
   36              0.000036     return 0

FUNCTION  <SNR>78_StartMessagePoll()
Called 22 times
Total time:   0.000334
 Self time:   0.000334

count  total (s)   self (s)
   22              0.000070   if s:pollers.receive_messages.id < 0
   20              0.000215     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
   20              0.000017   endif

FUNCTION  GetBladeIndent()
Called 38 times
Total time:   0.038193
 Self time:   0.002061

count  total (s)   self (s)
   38              0.000167     let lnum = v:lnum
   38              0.000216     let preNum = prevnonblank(lnum - 1)
                                
   38              0.000061     if preNum == 0
                                    return 0
                                endif
                            
   38   0.034628   0.000260 	let indent = HtmlIndent()
                            
   38              0.000107     let preLine = getline(preNum)
   38              0.000098     let curLine = getline(lnum)
                            
   38   0.001261   0.000196     if IsTagStart(preLine) == 1
   13              0.000069         let indent += &sw
   13              0.000011     endif
                            
   38   0.000870   0.000171     if IsTagEnd(curLine) == 1
    2              0.000008         let indent -= &sw
    2              0.000001     endif
                            
   38              0.000100     silent! unlet preLine
   38              0.000056     silent! unlet curLine
                            
   38              0.000046     return indent

FUNCTION  HtmlIndent_CheckUserSettings()
Called 1 time
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
                              "{{{
    1              0.000002   let inctags = ''
    1              0.000003   if exists("b:html_indent_inctags")
                                let inctags = b:html_indent_inctags
                              elseif exists("g:html_indent_inctags")
                                let inctags = g:html_indent_inctags
                              endif
    1              0.000002   let b:hi_tags = {}
    1              0.000003   if len(inctags) > 0
                                call s:AddITags(b:hi_tags, split(inctags, ","))
                              endif
                            
    1              0.000001   let autotags = ''
    1              0.000003   if exists("b:html_indent_autotags")
                                let autotags = b:html_indent_autotags
                              elseif exists("g:html_indent_autotags")
                                let autotags = g:html_indent_autotags
                              endif
    1              0.000001   let b:hi_removed_tags = {}
    1              0.000002   if len(autotags) > 0
                                call s:RemoveITags(b:hi_removed_tags, split(autotags, ","))
                              endif
                            
                              " Syntax names indicating being inside a string of an attribute value.
    1              0.000001   let string_names = []
    1              0.000003   if exists("b:html_indent_string_names")
                                let string_names = b:html_indent_string_names
                              elseif exists("g:html_indent_string_names")
                                let string_names = g:html_indent_string_names
                              endif
    1              0.000002   let b:hi_insideStringNames = ['htmlString']
    1              0.000002   if len(string_names) > 0
                                for s in string_names
                                  call add(b:hi_insideStringNames, s)
                                endfor
                              endif
                            
                              " Syntax names indicating being inside a tag.
    1              0.000001   let tag_names = []
    1              0.000003   if exists("b:html_indent_tag_names")
                                let tag_names = b:html_indent_tag_names
                              elseif exists("g:html_indent_tag_names")
                                let tag_names = g:html_indent_tag_names
                              endif
    1              0.000003   let b:hi_insideTagNames = ['htmlTag', 'htmlScriptTag']
    1              0.000002   if len(tag_names) > 0
                                for s in tag_names
                                  call add(b:hi_insideTagNames, s)
                                endfor
                              endif
                            
    1              0.000004   let indone = {"zero": 0,"auto": "indent(prevnonblank(v:lnum-1))","inc": "b:hi_indent.blocktagind + shiftwidth()"}
                            
    1              0.000002   let script1 = ''
    1              0.000003   if exists("b:html_indent_script1")
                                let script1 = b:html_indent_script1
                              elseif exists("g:html_indent_script1")
    1              0.000002     let script1 = g:html_indent_script1
    1              0.000000   endif
    1              0.000002   if len(script1) > 0
    1              0.000004     let b:hi_js1indent = get(indone, script1, indone.zero)
    1              0.000001   else
                                let b:hi_js1indent = 0
                              endif
                            
    1              0.000002   let style1 = ''
    1              0.000003   if exists("b:html_indent_style1")
                                let style1 = b:html_indent_style1
                              elseif exists("g:html_indent_style1")
                                let style1 = g:html_indent_style1
                              endif
    1              0.000002   if len(style1) > 0
                                let b:hi_css1indent = get(indone, style1, indone.zero)
                              else
    1              0.000002     let b:hi_css1indent = 0
    1              0.000001   endif
                            
    1              0.000003   if !exists('b:html_indent_line_limit')
    1              0.000002     if exists('g:html_indent_line_limit')
                                  let b:html_indent_line_limit = g:html_indent_line_limit
                                else
    1              0.000002       let b:html_indent_line_limit = 200
    1              0.000001     endif
    1              0.000001   endif

FUNCTION  phpcd#ExpandClassName()
Called 2 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000005 	if a:classname[0] == '\'
    1              0.000004 		let last_slash_pos = strridx(a:classname, '\')
    1              0.000001 		if last_slash_pos <= 0
                            			return [a:classname[1:], '\']
                            		else
    1              0.000005 			return [a:classname[last_slash_pos+1:], a:classname[:last_slash_pos-1]]
                            		endif
                            	endif
                            
    1              0.000006 	let parts = split(a:classname, '\\\+')
    1              0.000004 	if has_key(a:imports, parts[0])
                            		let parts[0] = a:imports[parts[0]]
                            	else
    1              0.000004 		call insert(parts, a:current_namespace, 0)
    1              0.000001 	endif
                            
    1              0.000002 	if len(parts) == 1
                            		let parts = split(parts[0], '\\\+')
                            	endif
    1              0.000002 	let classname = parts[-1]
    1              0.000006 	let namespace = join(parts[0:-2], '\')
    1              0.000002 	return [classname, namespace]

FUNCTION  emmet#getBaseType()
Called 6 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    6              0.000018   if !has_key(s:emmet_settings, a:type)
    6              0.000008     return ''
                              endif
                              if !has_key(s:emmet_settings[a:type], 'extends')
                                return a:type
                              endif
                              let extends = s:emmet_settings[a:type].extends
                              if type(extends) ==# 1
                                let tmp = split(extends, '\s*,\s*')
                                let ext = tmp[0]
                              else
                                let ext = extends[0]
                              endif
                              if a:type !=# ext
                                return emmet#getBaseType(ext)
                              endif
                              return ''

FUNCTION  <SNR>78_AllowedToCompleteInBuffer()
Called 807 times
Total time:   0.046778
 Self time:   0.041490

count  total (s)   self (s)
  807              0.006724   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  807              0.006641   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
   12              0.000015     return 0
                              endif
                            
  795   0.009828   0.004540   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  795              0.005034   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  795              0.003260   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  795              0.001805   let allowed = whitelist_allows && blacklist_allows
  795              0.000844   if allowed
  795              0.003564     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  795              0.000625   endif
  795              0.000953   return allowed

FUNCTION  <SNR>73_subseparator()
Called 175 times
Total time:   0.010460
 Self time:   0.010460

count  total (s)   self (s)
  175              0.001201   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
  175              0.006958   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
  175              0.002104   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  GetPhpIndent()
Called 8 times
Total time:   0.014078
 Self time:   0.008009

count  total (s)   self (s)
                            
    8              0.000049     let b:GetLastRealCodeLNum_ADD = 0
                            
    8              0.000012     let UserIsEditing=0
    8              0.000024     if	b:PHP_oldchangetick != b:changedtick
    8              0.000016 	let b:PHP_oldchangetick = b:changedtick
    8              0.000011 	let UserIsEditing=1
    8              0.000009     endif
                            
    8              0.000013     if b:PHP_default_indenting
                            	let b:PHP_default_indenting = g:PHP_default_indenting * shiftwidth()
                                endif
                            
    8              0.000033     let cline = getline(v:lnum)
                            
    8              0.000023     if !b:PHP_indentinghuge && b:PHP_lastindented > b:PHP_indentbeforelast
    7              0.000011 	if b:PHP_indentbeforelast
    1              0.000002 	    let b:PHP_indentinghuge = 1
    1              0.000001 	endif
    7              0.000015 	let b:PHP_indentbeforelast = b:PHP_lastindented
    7              0.000007     endif
                            
    8              0.000053     if b:InPHPcode_checked && prevnonblank(v:lnum - 1) != b:PHP_lastindented
    7              0.000010 	if b:PHP_indentinghuge
    2              0.000007 	    let b:PHP_indentinghuge = 0
    2              0.000009 	    let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
    2              0.000001 	endif
    7              0.000015 	let real_PHP_lastindented = v:lnum
    7              0.000016 	let b:PHP_LastIndentedWasComment=0
    7              0.000015 	let b:PHP_InsideMultilineComment=0
    7              0.000014 	let b:PHP_indentbeforelast = 0
                            
    7              0.000013 	let b:InPHPcode = 0
    7              0.000013 	let b:InPHPcode_checked = 0
    7              0.000012 	let b:InPHPcode_and_script = 0
    7              0.000018 	let b:InPHPcode_tofind = ""
                            
    7              0.000013     elseif v:lnum > b:PHP_lastindented
    1              0.000002 	let real_PHP_lastindented = b:PHP_lastindented
    1              0.000000     else
                            	let real_PHP_lastindented = v:lnum
                                endif
                            
    8              0.000018     let b:PHP_lastindented = v:lnum
                            
                            
    8              0.000010     if !b:InPHPcode_checked " {{{ One time check
    7              0.000008 	let b:InPHPcode_checked = 1
    7              0.000013 	let b:UserIsTypingComment = 0
                            
    7              0.000011 	let synname = ""
    7              0.000051 	if cline !~ '<?.*?>'
    7   0.001295   0.000072 	    let synname = IslinePHP (prevnonblank(v:lnum), "")
    7              0.000003 	endif
                            
    7              0.000009 	if synname!=""
    7              0.000013 	    if synname ==? "SpecStringEntrails"
                            		let b:InPHPcode = -1 " thumb down
                            		let b:InPHPcode_tofind = ""
                            	    elseif synname !=? "phpHereDoc" && synname !=? "phpHereDocDelimiter"
    7              0.000009 		let b:InPHPcode = 1
    7              0.000013 		let b:InPHPcode_tofind = ""
                            
    7              0.000063 		if synname =~? '^php\%(Doc\)\?Comment'
                            		    let b:UserIsTypingComment = 1
                            		    let b:InPHPcode_checked = 0
                            		endif
                            
    7              0.000027 		if synname =~? '^javaScript'
                            		    let b:InPHPcode_and_script = 1
                            		endif
                            
    7              0.000006 	    else
                            		let b:InPHPcode = 0
                            
                            		let lnum = v:lnum - 1
                            		while getline(lnum) !~? '<<<\s*[''"]\=\a\w*[''"]\=$' && lnum > 1
                            		    let lnum = lnum - 1
                            		endwhile
                            
                            		let b:InPHPcode_tofind = substitute( getline(lnum), '^.*<<<\s*[''"]\=\(\a\w*\)[''"]\=$', '^\\s*\1;\\=$', '')
                            	    endif
    7              0.000005 	else
                            	    let b:InPHPcode = 0
                            	    let b:InPHPcode_tofind = s:PHP_startindenttag
                            	endif
    7              0.000007     endif "!b:InPHPcode_checked }}}
                            
                            
                                " Test if we are indenting PHP code {{{
    8              0.000033     let lnum = prevnonblank(v:lnum - 1)
    8              0.000022     let last_line = getline(lnum)
    8              0.000015     let endline= s:endline
                            
    8              0.000017     if b:InPHPcode_tofind!=""
                            	if cline =~? b:InPHPcode_tofind
                            	    let b:InPHPcode_tofind = ""
                            	    let b:UserIsTypingComment = 0
                            
                            	    if b:InPHPcode == -1
                            		let b:InPHPcode = 1
                            		return -1
                            	    end
                            
                            	    let b:InPHPcode = 1
                            
                            	    if cline =~ '\*/'
                            		call cursor(v:lnum, 1)
                            		if cline !~ '^\*/'
                            		    call search('\*/', 'W')
                            		endif
                            		let lnum = searchpair('/\*', '', '\*/', s:searchpairflags, 'Skippmatch2()')
                            
                            		let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            
                            		let b:PHP_LastIndentedWasComment = 0
                            
                            		if cline =~ '^\s*\*/'
                            		    return indent(lnum) + 1
                            		else
                            		    return indent(lnum)
                            		endif
                            
                            	    elseif cline =~? '<script\>'
                            		let b:InPHPcode_and_script = 1
                            		let b:GetLastRealCodeLNum_ADD = v:lnum
                            	    endif
                            	endif
                                endif
                            
    8              0.000011     if 1 == b:InPHPcode
                            
    8              0.000094 	if !b:InPHPcode_and_script && last_line =~ '\%(<?.*\)\@<!?>\%(.*<?\)\@!' && IslinePHP(lnum, '?>')=~?"Delimiter"
                            	    if cline !~? s:PHP_startindenttag
                            		let b:InPHPcode = 0
                            		let b:InPHPcode_tofind = s:PHP_startindenttag
                            	    elseif cline =~? '<script\>'
                            		let b:InPHPcode_and_script = 1
                            	    endif
                            
                            	elseif last_line =~ '^[^''"`]\+[''"`]$' " a string identifier with nothing after it and no other string identifier before
                            	    let b:InPHPcode = -1
                            	    let b:InPHPcode_tofind = substitute( last_line, '^.*\([''"`]\).*$', '^[^\1]*\1[;,]$', '')
                            	elseif last_line =~? '<<<\s*[''"]\=\a\w*[''"]\=$'
                            	    let b:InPHPcode = 0
                            	    let b:InPHPcode_tofind = substitute( last_line, '^.*<<<\s*[''"]\=\(\a\w*\)[''"]\=$', '^\\s*\1;\\=$', '')
                            
                            	elseif !UserIsEditing && cline =~ '^\s*/\*\%(.*\*/\)\@!' && getline(v:lnum + 1) !~ '^\s*\*'
                            	    let b:InPHPcode = 0
                            	    let b:InPHPcode_tofind = '\*/'
                            
                            	elseif cline =~? '^\s*</script>'
                            	    let b:InPHPcode = 0
                            	    let b:InPHPcode_tofind = s:PHP_startindenttag
                            	endif
    8              0.000008     endif " }}}
                            
                            
    8              0.000014     if 1 > b:InPHPcode && !b:InPHPcode_and_script
                            	return -1
                                endif
                            
                                " Indent successive // or # comment the same way the first is {{{
    8              0.000016     let addSpecial = 0
    8              0.000055     if cline =~ '^\s*\%(//\|#\|/\*.*\*/\s*$\)'
                            	let addSpecial = b:PHP_outdentSLComments
                            	if b:PHP_LastIndentedWasComment == 1
                            	    return indent(real_PHP_lastindented)
                            	endif
                            	let b:PHP_LastIndentedWasComment = 1
                                else
    8              0.000016 	let b:PHP_LastIndentedWasComment = 0
    8              0.000006     endif " }}}
                            
                                " Indent multiline /* comments correctly {{{
                            
    8              0.000019     if b:PHP_InsideMultilineComment || b:UserIsTypingComment
                            	if cline =~ '^\s*\*\%(\/\)\@!'
                            	    if last_line =~ '^\s*/\*'
                            		return indent(lnum) + 1
                            	    else
                            		return indent(lnum)
                            	    endif
                            	else
                            	    let b:PHP_InsideMultilineComment = 0
                            	endif
                                endif
                            
    8              0.000050     if !b:PHP_InsideMultilineComment && cline =~ '^\s*/\*\%(.*\*/\)\@!'
                            	if getline(v:lnum + 1) !~ '^\s*\*'
                            	    return -1
                            	endif
                            	let b:PHP_InsideMultilineComment = 1
                                endif " }}}
                            
                            
                                " Things always indented at col 1 (PHP delimiter: <?, ?>, Heredoc end) {{{
    8              0.000039     if cline =~# '^\s*<?' && cline !~ '?>' && b:PHP_outdentphpescape
                            	return 0
                                endif
                            
    8              0.000033     if	cline =~ '^\s*?>' && cline !~# '<?' && b:PHP_outdentphpescape
                            	return 0
                                endif
                            
    8              0.000078     if cline =~? '^\s*\a\w*;$\|^\a\w*$\|^\s*[''"`][;,]' && cline !~? s:notPhpHereDoc
                            	return 0
                                endif " }}}
                            
    8              0.000017     let s:level = 0
                            
    8   0.001275   0.000063     let lnum = GetLastRealCodeLNum(v:lnum - 1)
                            
    8              0.000021     let last_line = getline(lnum)
    8              0.000022     let ind = indent(lnum)
                            
    8              0.000014     if ind==0 && b:PHP_default_indenting
                            	let ind = b:PHP_default_indenting
                                endif
                            
    8              0.000008     if lnum == 0
                            	return b:PHP_default_indenting + addSpecial
                                endif
                            
                            
    8              0.000039     if cline =~ '^\s*}\%(}}\)\@!'
                            	let ind = indent(FindOpenBracket(v:lnum, 1))
                            	let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            	return ind
                                endif
                            
    8              0.000031     if cline =~ '^\s*\*/'
                            	call cursor(v:lnum, 1)
                            	if cline !~ '^\*/'
                            	    call search('\*/', 'W')
                            	endif
                            	let lnum = searchpair('/\*', '', '\*/', s:searchpairflags, 'Skippmatch2()')
                            
                            	let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            
                            	if cline =~ '^\s*\*/'
                            	    return indent(lnum) + 1
                            	else
                            	    return indent(lnum)
                            	endif
                                endif
                            
                            
    8              0.000119     if last_line =~ '[;}]'.endline && last_line !~ '^[)\]]' && last_line !~# s:defaultORcase
    5              0.000009 	if ind==b:PHP_default_indenting
    1              0.000003 	    return b:PHP_default_indenting + addSpecial
                            	elseif b:PHP_indentinghuge && ind==b:PHP_CurrentIndentLevel && cline !~# '^\s*\%(else\|\%(case\|default\).*:\|[})];\=\)' && last_line !~# '^\s*\%(\%(}\s*\)\=else\)' && getline(GetLastRealCodeLNum(lnum - 1))=~';'.endline
                            	    return b:PHP_CurrentIndentLevel + addSpecial
                            	endif
    4              0.000002     endif
                            
    7              0.000012     let LastLineClosed = 0
                            
    7              0.000016     let terminated = s:terminated
                            
    7              0.000016     let unstated  = s:unstated
                            
                            
    7              0.000042     if ind != b:PHP_default_indenting && cline =~# '^\s*else\%(if\)\=\>'
                            	let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            	return indent(FindTheIfOfAnElse(v:lnum, 1))
                                elseif cline =~# s:defaultORcase
                            	return FindTheSwitchIndent(v:lnum) + shiftwidth() * b:PHP_vintage_case_default_indent
                                elseif cline =~ '^\s*)\=\s*{'
                            	let previous_line = last_line
                            	let last_line_num = lnum
                            
                            	while last_line_num > 1
                            
                            	    if previous_line =~ terminated || previous_line =~ s:structureHead
                            
                            		let ind = indent(last_line_num)
                            
                            		if  b:PHP_BracesAtCodeLevel
                            		    let ind = ind + shiftwidth()
                            		endif
                            
                            		return ind
                            	    endif
                            
                            	    let last_line_num = GetLastRealCodeLNum(last_line_num - 1)
                            	    let previous_line = getline(last_line_num)
                            	endwhile
                                elseif cline =~ '^\s*->'
                            	return FindArrowIndent(lnum)
                                elseif last_line =~# unstated && cline !~ '^\s*);\='.endline
                            	let ind = ind + shiftwidth() " we indent one level further when the preceding line is not stated
                            	return ind + addSpecial
                            
                                elseif (ind != b:PHP_default_indenting || last_line =~ '^[)\]]' ) && last_line =~ terminated
    4              0.000011 	let previous_line = last_line
    4              0.000006 	let last_line_num = lnum
    4              0.000006 	let LastLineClosed = 1
                            
    4              0.000008 	let isSingleLineBlock = 0
   16              0.000014 	while 1
   16              0.000172 	    if ! isSingleLineBlock && previous_line =~ '^\s*}\|;\s*}'.endline
                            
                            		call cursor(last_line_num, 1)
                            		if previous_line !~ '^}'
                            		    call search('}\|;\s*}'.endline, 'W')
                            		end
                            		let oldLastLine = last_line_num
                            		let last_line_num = searchpair('{', '', '}', 'bW', 'Skippmatch()')
                            
                            		if getline(last_line_num) =~ '^\s*{'
                            		    let last_line_num = GetLastRealCodeLNum(last_line_num - 1)
                            		elseif oldLastLine == last_line_num
                            		    let isSingleLineBlock = 1
                            		    continue
                            		endif
                            
                            		let previous_line = getline(last_line_num)
                            
                            		continue
                            	    else
   16              0.000026 		let isSingleLineBlock = 0
                            
   16              0.000124 		if getline(last_line_num) =~# '^\s*else\%(if\)\=\>'
                            		    let last_line_num = FindTheIfOfAnElse(last_line_num, 0)
                            		    continue
                            		endif
                            
                            
   16              0.000029 		let last_match = last_line_num
                            
   16              0.000047 		let one_ahead_indent = indent(last_line_num)
   16   0.002557   0.000117 		let last_line_num = GetLastRealCodeLNum(last_line_num - 1)
   16              0.000051 		let two_ahead_indent = indent(last_line_num)
   16              0.000035 		let after_previous_line = previous_line
   16              0.000044 		let previous_line = getline(last_line_num)
                            
                            
   16              0.000215 		if previous_line =~# s:defaultORcase.'\|{'.endline
    4              0.000004 		    break
                            		endif
                            
   12              0.000450 		if after_previous_line=~# '^\s*'.s:blockstart.'.*)'.endline && previous_line =~# '[;}]'.endline
                            		    break
                            		endif
                            
   12              0.000032 		if one_ahead_indent == two_ahead_indent || last_line_num < 1
    4              0.000049 		    if previous_line =~# '\%(;\|^\s*}\)'.endline || last_line_num < 1
                            			break
                            		    endif
    4              0.000001 		endif
   12              0.000006 	    endif
   12              0.000013 	endwhile
                            
    4              0.000013 	if indent(last_match) != ind
                            	    let ind = indent(last_match)
                            	    let b:PHP_CurrentIndentLevel = b:PHP_default_indenting
                            
                            	    return ind + addSpecial
                            	endif
    4              0.000002     endif
                            
    7              0.000046     if (last_line !~ '^\s*}\%(}}\)\@!')
    7   0.001120   0.000049 	let plinnum = GetLastRealCodeLNum(lnum - 1)
    7              0.000006     else
                            	let plinnum = GetLastRealCodeLNum(FindOpenBracket(lnum, 1) - 1)
                                endif
                            
    7              0.000021     let AntepenultimateLine = getline(plinnum)
                            
    7   0.000171   0.000048     let last_line = StripEndlineComments(last_line)
                            
    7              0.000015     if ind == b:PHP_default_indenting
                            	if last_line =~ terminated && last_line !~# s:defaultORcase
                            	    let LastLineClosed = 1
                            	endif
                                endif
                            
    7              0.000008     if !LastLineClosed
                            
    3              0.000006 	let openedparent = -1
                            
                            
    3              0.000036 	if last_line =~# '[{(\[]'.endline || last_line =~? '\h\w*\s*(.*,$' && AntepenultimateLine !~ '[,(\[]'.endline && BalanceDirection(last_line) > 0
                            
    3              0.000005 	    let dontIndent = 0
    3              0.000035 	    if last_line =~ '\S\+\s*{'.endline && last_line !~ '^\s*[)\]]\+\(\s*:\s*'.s:PHP_validVariable.'\)\=\s*{'.endline && last_line !~ s:structureHead
                            		let dontIndent = 1
                            	    endif
                            
    3              0.000006 	    if !dontIndent && (!b:PHP_BracesAtCodeLevel || last_line !~# '^\s*{')
    3              0.000009 		let ind = ind + shiftwidth()
    3              0.000002 	    endif
                            
    3              0.000008 	    if b:PHP_BracesAtCodeLevel || b:PHP_vintage_case_default_indent == 1
                            		let b:PHP_CurrentIndentLevel = ind
                            
                            	    endif
                            
    3              0.000007 	elseif last_line =~ '),'.endline && BalanceDirection(last_line) < 0
                            	    call cursor(lnum, 1)
                            	    call searchpos('),'.endline, 'cW')
                            	    let openedparent = searchpair('(', '', ')', 'bW', 'Skippmatch()')
                            	    if openedparent != lnum
                            		let ind = indent(openedparent)
                            	    endif
                            
                            	elseif last_line =~ s:structureHead
                            	    let ind = ind + shiftwidth()
                            
                            
                            	elseif AntepenultimateLine =~ '{'.endline && AntepenultimateLine !~? '^\s*use\>' || AntepenultimateLine =~ terminated || AntepenultimateLine =~# s:defaultORcase
                            	    let ind = ind + shiftwidth()
                            	endif
                            
                            
    3              0.000003 	if openedparent >= 0
                            	    let last_line = StripEndlineComments(getline(openedparent))
                            	endif
    3              0.000003     endif
                            
    7              0.000038     if cline =~ '^\s*[)\]];\='
    3              0.000007 	let ind = ind - shiftwidth()
    3              0.000002     endif
                            
    7              0.000045     if last_line =~ '^\s*->' && last_line !~? s:structureHead && BalanceDirection(last_line) <= 0
                            	let ind = ind - shiftwidth()
                                endif
                            
    7              0.000014     let b:PHP_CurrentIndentLevel = ind
    7              0.000015     return ind + addSpecial

FUNCTION  <SNR>91_CountITags()
Called 40 times
Total time:   0.003051
 Self time:   0.001520

count  total (s)   self (s)
                              "{{{
                              " Store the result in s:curind and s:nextrel.
   40              0.000072   let s:curind = 0  " relative indent steps for current line [unit &sw]:
   40              0.000051   let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
   40              0.000049   let s:block = 0		" assume starting outside of a block
   40              0.000071   let s:countonly = 1	" don't change state
   40   0.002649   0.001118   call substitute(a:text, '<\zs/\=' . s:tagname . '\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
   40              0.000062   let s:countonly = 0

FUNCTION  <SNR>78_CloseCompletionMenu()
Called 375 times
Total time:   0.003667
 Self time:   0.002852

count  total (s)   self (s)
  375              0.000874   if pumvisible()
   91   0.001422   0.000607     call s:SendKeys( "\<C-e>" )
   91              0.000086   endif

FUNCTION  emmet#reExpandDollarExpr()
Called 2 times
Total time:   0.000837
 Self time:   0.000077

count  total (s)   self (s)
    2              0.000004   let expand = a:expand
    2   0.000778   0.000018   let dollar_exprs = emmet#getDollarExprs(expand)
    2              0.000006   if len(dollar_exprs) > 0
                                if a:times < 9
                                  for n in range(len(dollar_exprs))
                                    let pair = get(dollar_exprs, n)
                                    let pat = get(pair, 'expr')
                                    let sub = get(pair, 'value')
                                    let expand = substitute(expand, pat, sub, '')
                                  endfor
                                  return emmet#reExpandDollarExpr(expand, a:times + 1)
                                endif
                              endif
    2              0.000003   return expand

FUNCTION  <SNR>67_IndentLinesDisable()
Called 5 times
Total time:   0.000888
 Self time:   0.000814

count  total (s)   self (s)
    5              0.000006     if g:indentLine_newVersion
    5              0.000030         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
  105              0.000083             for id in w:indentLine_indentLineId
  100              0.000061                 try
  100              0.000266                     call matchdelete(id)
  100              0.000089                 catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
  100              0.000063             endfor
    5              0.000031             let w:indentLine_indentLineId = []
    5              0.000004         endif
                            
    5   0.000114   0.000040         call s:ResetConcealOption()
    5              0.000005         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  phpcd#GetCurrentInstruction()
Called 2 times
Total time:   0.009265
 Self time:   0.009265

count  total (s)   self (s)
                            	" locate the current instruction
                            	" up until the previous non comment or string ";"
                            	" or php region start (<?php or <?) without newlines
    2              0.000009 	let col_number = a:col_number
    2              0.000006 	let line_number = a:line_number
    2              0.000008 	let line = getline(a:line_number)
    2              0.000004 	let current_char = -1
    2              0.000004 	let instruction = ''
    2              0.000004 	let parent_depth = 0
    2              0.000003 	let bracket_depth = 0
    2              0.000015 	let stop_chars = [ '!', '@', '%', '^', '&', '*', '/', '-', '+', '=', ':', '>', '<', '.', '?', ';', '(', '|', '[' ]
                            
    2              0.000080 	let phpbegin_length = len(matchstr(getline(a:phpbegin[0]), '\zs<?\(php\)\?\ze'))
    2              0.000018 	let phpbegin_end = [a:phpbegin[0], a:phpbegin[1] - 1 + phpbegin_length]
                            
                            	" will hold the first place where a coma could have ended the match
    2              0.000005 	let first_coma_break_pos = -1
    2              0.000011 	let next_char = len(line) < col_number ? line[col_number + 1] : ''
                            
   39              0.000059 	while !(line_number <= 1 && col_number <= 1)
   39              0.000051 		if current_char != -1
   37              0.000055 			let next_char = current_char
   37              0.000020 		endif
                            
   39              0.000108 		let current_char = line[col_number]
   39              0.004807 		let synIDName = synIDattr(synID(line_number, col_number + 1, 0), 'name')
                            
   39              0.000095 		if col_number - 1 == -1
    4              0.000006 			let prev_line_number = line_number - 1
    4              0.000009 			let prev_line = getline(line_number - 1)
    4              0.000009 			let prev_col_number = strlen(prev_line)
    4              0.000002 		else
   35              0.000054 			let prev_line_number = line_number
   35              0.000057 			let prev_col_number = col_number - 1
   35              0.000050 			let prev_line = line
   35              0.000023 		endif
   39              0.000085 		let prev_char = prev_line[prev_col_number]
                            
                            		" skip comments
   39              0.000270 		if synIDName =~? 'comment\|phpDocTags'
                            			let current_char = ''
                            		endif
                            
                            		" break on the last char of the "and" and "or" operators
   39              0.000092 		if synIDName == 'phpOperator' && (current_char == 'r' || current_char == 'd')
                            			break
                            		endif
                            
                            		" break on statements as "return" or "throws"
   39              0.000089 		if synIDName == 'phpStatement' || synIDName == 'phpException'
                            			break
                            		endif
                            
                            		" if the current char should be considered
   39              0.000252 		if current_char != '' && parent_depth >= 0 && bracket_depth >= 0 && synIDName !~? 'comment\|string'
                            			" break if we are on a "naked" stop_char (operators, colon, openparent...)
   35              0.000112 			if index(stop_chars, current_char) != -1
    6              0.000045 				let do_break = 1
                            				" dont break if it does look like a "->"
    6              0.000026 				if (prev_char == '-' && current_char == '>') || (current_char == '-' && next_char == '>')
    4              0.000006 					let do_break = 0
    4              0.000004 				endif
                            				" dont break if it does look like a "::"
    6              0.000019 				if (prev_char == ':' && current_char == ':') || (current_char == ':' && next_char == ':')
                            					let do_break = 0
                            				endif
                            
    6              0.000007 				if do_break
    2              0.000002 					break
                            				endif
    4              0.000002 			endif
                            
                            			" save the coma position for later use if theres a "naked" , possibly separating a parameter and it is not in a parented part
   33              0.000068 			if first_coma_break_pos == -1 && current_char == ','
                            				let first_coma_break_pos = len(instruction)
                            			endif
   33              0.000021 		endif
                            
                            		" count nested darenthesis and brackets so we can tell if we need to break on a ';' or not (think of for (;;) loops)
   37              0.000259 		if synIDName =~? 'phpBraceFunc\|phpParent\|Delimiter'
                            			if current_char == '('
                            				let parent_depth += 1
                            			elseif current_char == ')'
                            				let parent_depth -= 1
                            
                            			elseif current_char == '['
                            				let bracket_depth += 1
                            			elseif current_char == ']'
                            				let bracket_depth -= 1
                            			endif
                            		endif
                            
                            		" stop collecting chars if we see a function start { (think of first line in a function)
   37              0.000098 		if (current_char == '{' || current_char == '}') && synIDName =~? 'phpBraceFunc\|phpParent\|Delimiter'
                            			break
                            		endif
                            
                            		" break if we are reached the php block start (<?php or <?)
   37              0.000107 		if [line_number, col_number] == phpbegin_end
                            			break
                            		endif
                            
   37              0.000091 		let instruction = current_char.instruction
                            
                            		" step a char or a line back if we are on the first column of the line already
   37              0.000052 		let col_number -= 1
   37              0.000037 		if col_number == -1
    4              0.000005 			let line_number -= 1
    4              0.000010 			let line = getline(line_number)
    4              0.000008 			let col_number = strlen(line)
    4              0.000004 		endif
   37              0.000026 	endwhile
                            
                            	" strip leading whitespace
    2              0.000019 	let instruction = substitute(instruction, '^\s\+', '', '')
                            
                            	" there were a "naked" coma in the instruction
    2              0.000003 	if first_coma_break_pos != -1
                            		if instruction !~? '^use' && instruction !~? '^class' " use ... statements and class delcarations should not be broken up by comas
                            			let pos = (-1 * first_coma_break_pos) + 1
                            			let instruction = instruction[pos :]
                            		endif
                            	endif
                            
                            	" HACK to remove one line conditionals from code like "if ($foo) echo 'bar'"
                            	" what the plugin really need is a proper php tokenizer
    2              0.000020 	if instruction =~? '\c^\(if\|while\|foreach\|for\)\s*('
                            		" clear everything up until the first (
                            		let instruction = substitute(instruction, '^\(if\|while\|foreach\|for\)\s*(\s*', '', '')
                            
                            		" lets iterate trough the instruction until we can find the pair for the opening (
                            		let i = 0
                            		let depth = 1
                            		while i < len(instruction)
                            			if instruction[i] == '('
                            				let depth += 1
                            			endif
                            			if instruction[i] == ')'
                            				let depth -= 1
                            			endif
                            			if depth == 0
                            				break
                            			end
                            			let i += 1
                            		endwhile
                            		let instruction = instruction[i + 1 : len(instruction)]
                            	endif
                            
                            	" trim whitespace from the ends
    2              0.000019 	let instruction = substitute(instruction, '\v^(^\s+)|(\s+)$', '', 'g')
                            
    2              0.000004 	return instruction

FUNCTION  <SNR>72_GetEnclosingTagLocations()
Called 367 times
Total time:   0.180024
 Self time:   0.180024

count  total (s)   self (s)
                              " Sadly, pyeval does not exist before Vim 7.3.584
  367              0.001541   if has('python')
                                if v:version >= 703 && has( 'patch584' )
                                  return pyeval( 'mta_vim.LocationOfEnclosingTagsInWindowView()' )
                                else
                                  py vim.command( 'return ' + str( mta_vim.LocationOfEnclosingTagsInWindowView() ) )
                                endif
                              else
  367              0.001754     if v:version >= 703 && has( 'patch584' )
                                  return py3eval( 'mta_vim.LocationOfEnclosingTagsInWindowView()' )
                                else
  367              0.171684       py3 vim.command( 'return ' + str( mta_vim.LocationOfEnclosingTagsInWindowView() ) )
                                endif
                              endif

FUNCTION  <SNR>44_init()
Called 8 times
Total time:   0.015768
 Self time:   0.002942

count  total (s)   self (s)
                            " Initialize variables:
                              " autoclose
    8   0.000708   0.000062   call s:option_init("autoclose", 1)
                              " matchpairs
    8   0.000611   0.000083   call s:option_init("matchpairs", string(&matchpairs)[1:-2])
    8   0.001345   0.000405   call s:option_init("matchpairs_list", map(split(s:get('matchpairs'), '.:.\zs,\ze.:.'), 'split(v:val, ''^.\zs:\ze.$'')'))
    8   0.000317   0.000046   let pairs = s:get('matchpairs_list')
    8              0.000096   if len(filter(pairs, 'v:val[0] ==# v:val[1]'))
                                echohl ErrorMsg
                                echom 'delimitMate: each member of a pair in delimitMate_matchpairs must be different from each other.'
                                echom 'delimitMate: invalid pairs: ' . join(map(pairs, 'join(v:val, ":")'), ', ')
                                echohl Normal
                                return 0
                              endif
    8   0.000835   0.000124   call s:option_init("left_delims", map(copy(s:get('matchpairs_list')), 'v:val[0]'))
    8   0.000844   0.000129   call s:option_init("right_delims", map(copy(s:get('matchpairs_list')), 'v:val[1]'))
                              " quotes
    8   0.000500   0.000045   call s:option_init("quotes", "\" ' `")
    8   0.000806   0.000136   call s:option_init("quotes_list",split(s:get('quotes'), '\s\+'))
                              " nesting_quotes
    8   0.000453   0.000040   call s:option_init("nesting_quotes", [])
                              " excluded_regions
    8   0.000490   0.000042   call s:option_init("excluded_regions", "Comment")
    8   0.000823   0.000112   call s:option_init("excluded_regions_list", split(s:get('excluded_regions'), ',\s*'))
    8   0.000262   0.000048   let enabled = len(s:get('excluded_regions_list')) > 0
    8   0.000452   0.000039   call s:option_init("excluded_regions_enabled", enabled)
                              " expand_space
    8              0.000039   if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                                echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet b:delimitMate_expand_space
                                let b:delimitMate_expand_space = 1
                              endif
    8              0.000033   if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                                echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet g:delimitMate_expand_space
                                let g:delimitMate_expand_space = 1
                              endif
    8   0.000479   0.000037   call s:option_init("expand_space", 0)
                              " expand_cr
    8              0.000038   if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                                echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet b:delimitMate_expand_cr
                                let b:delimitMate_expand_cr = 1
                              endif
    8              0.000029   if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                                echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet g:delimitMate_expand_cr
                                let g:delimitMate_expand_cr = 1
                              endif
    8              0.000096   if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                                echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
                              endif
    8   0.000483   0.000042   call s:option_init("expand_cr", 0)
                              " expand_in_quotes
    8   0.000463   0.000040   call s:option_init('expand_inside_quotes', 0)
                              " jump_expansion
    8   0.000555   0.000036   call s:option_init("jump_expansion", 0)
                              " smart_matchpairs
    8   0.000470   0.000044   call s:option_init("smart_matchpairs", '^\%(\w\|\!\|[$]\|[^[:punct:][:space:]]\)')
                              " smart_quotes
                              " XXX: backward compatibility. Ugly, should go the way of the dodo soon.
    8   0.000302   0.000076   let quotes = escape(join(s:get('quotes_list'), ''), '\-^[]')
    8              0.000043   let default_smart_quotes = '\%(\w\|[^[:punct:][:space:]' . quotes . ']\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]' . quotes . ']\)'
    8              0.000038   if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) == type(0)
                                if g:delimitMate_smart_quotes
                                  unlet g:delimitMate_smart_quotes
                                else
                                  unlet g:delimitMate_smart_quotes
                                  let g:delimitMate_smart_quotes = ''
                                endif
                              endif
    8              0.000033   if exists('b:delimitMate_smart_quotes') && type(b:delimitMate_smart_quotes) == type(0)
                                if b:delimitMate_smart_quotes
                                  unlet b:delimitMate_smart_quotes
                                  if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) && g:delimitMate_smart_quotes
                                    let b:delimitMate_smart_quotes = default_smart_quotes
                                  endif
                                else
                                  unlet b:delimitMate_smart_quotes
                                  let b:delimitMate_smart_quotes = ''
                                endif
                              endif
    8   0.000487   0.000043   call s:option_init("smart_quotes", default_smart_quotes)
                              " apostrophes
    8   0.000490   0.000037   call s:option_init("apostrophes", "")
    8   0.000728   0.000094   call s:option_init("apostrophes_list", split(s:get('apostrophes'), ":\s*"))
                              " tab2exit
    8   0.000485   0.000035   call s:option_init("tab2exit", 1)
                              " balance_matchpairs
    8   0.000438   0.000035   call s:option_init("balance_matchpairs", 0)
                              " eol marker
    8   0.000454   0.000035   call s:option_init("insert_eol_marker", 1)
    8   0.000471   0.000060   call s:option_init("eol_marker", "")
                              " Everything is fine.
    8              0.000007   return 1

FUNCTION  delimitMate#QuoteDelim()
Called 1 time
Total time:   0.000552
 Self time:   0.000120

count  total (s)   self (s)
    1   0.000222   0.000006   if s:is_forbidden(a:char)
                                return a:char
                              endif
    1   0.000044   0.000018   let char_at = s:get_char(0)
    1   0.000036   0.000007   let char_before = s:get_char(-1)
    1   0.000027   0.000006   let nesting_on = index(s:get('nesting_quotes'), a:char) > -1
    1              0.000004   let left_q = nesting_on ? s:lquote(a:char) : 0
    1              0.000001   if nesting_on && left_q > 1
                                " Nesting quotes.
                                let right_q =  s:rquote(a:char)
                                let quotes = right_q > left_q + 1 ? 0 : left_q - right_q + 2
                                let lefts = quotes - 1
                                return repeat(a:char, quotes) . repeat(s:joinUndo() . "\<Left>", lefts)
                              elseif char_at == a:char
                                " Inside an empty pair, jump out
                                return a:char . "\<Del>"
                              elseif a:char == '"' && index(split(&ft, '\.'), "vim") != -1 && getline('.') =~ '^\s*$'
                                " If we are in a vim file and it looks like we're starting a comment, do
                                " not add a closing char.
                                return a:char
                              elseif s:is_smart_quote(a:char)
                                " Seems like a smart quote, insert a single char.
                                return a:char
                              elseif (char_before == a:char && char_at != a:char) && !empty(s:get('smart_quotes'))
                                " Seems like we have an unbalanced quote, insert one quotation
                                " mark and jump to the middle.
                                return a:char . s:joinUndo() . "\<Left>"
                              else
                                " Insert a pair and jump to the middle.
    1              0.000001     let sufix = ''
    1   0.000028   0.000008     if !empty(s:get('eol_marker')) && col('.') - 1 == len(getline('.'))
                                  let idx = len(s:get('eol_marker')) * -1
                                  let marker = getline('.')[idx : ]
                                  let has_marker = marker == s:get('eol_marker')
                                  let sufix = !has_marker ? s:get('eol_marker') : ''
                                endif
    1   0.000014   0.000006     return a:char . a:char . s:joinUndo() . "\<Left>"
                              endif

FUNCTION  <SNR>72_HighlightEnclosingTagsIfPossible()
Called 367 times
Total time:   0.220209
 Self time:   0.012133

count  total (s)   self (s)
                              " Remove any previous highlighting.
  367              0.001726   if get( w:, 'tags_highlighted', 0 )
  302              0.000652       let w:tags_highlighted = 0
  302              0.001415       2match none
  302              0.000256   endif
                            
                              " Don't remove the pop-up menu and don't run when there are no colors at all.
  367              0.002884   if pumvisible() || ( &t_Co < 8 && !has( "gui_running" ) )
                                  return
                              endif
                            
  367   0.210585   0.002509   call s:HighlightEnclosingTags()

FUNCTION  delimitMate#Set()
Called 184 times
Total time:   0.006024
 Self time:   0.001068

count  total (s)   self (s)
  184   0.005954   0.000998   return call('s:set', a:000)

FUNCTION  IslinePHP()
Called 7 times
Total time:   0.001223
 Self time:   0.001223

count  total (s)   self (s)
    7              0.000025     let cline = getline(a:lnum)
                            
    7              0.000016     if a:tofind==""
    7              0.000013 	let tofind = "^\\s*[\"'`]*\\s*\\zs\\S"
    7              0.000004     else
                            	let tofind = a:tofind
                                endif
                            
    7              0.000015     let tofind = tofind . '\c'
                            
    7              0.000100     let coltotest = match (cline, tofind) + 1
                            
    7              0.000846     let synname = synIDattr(synID(a:lnum, coltotest, 0), "name")
                            
    7              0.000030     if synname ==? 'phpStringSingle' || synname ==? 'phpStringDouble' || synname ==? 'phpBacktick'
                            	if cline !~ '^\s*[''"`]'
                            	    return "SpecStringEntrails"
                            	else
                            	    return synname
                            	end
                                end
                            
    7              0.000063     if get(s:SynPHPMatchGroups, tolower(synname)) || synname =~ '^php' ||  synname =~? '^javaScript'
    7              0.000008 	return synname
                                else
                            	return ""
                                endif

FUNCTION  <SNR>78_InsideCommentOrStringAndShouldStop()
Called 214 times
Total time:   0.074915
 Self time:   0.003641

count  total (s)   self (s)
  214   0.072376   0.001102   let retval = s:InsideCommentOrString()
  214              0.000413   let inside_comment = retval == 1
  214              0.000320   let inside_string = retval == 2
                            
  214              0.000615   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
  214              0.000210   return retval

FUNCTION  fzf#run()
Called 1 time
Total time:   0.043969
 Self time:   0.000402

count  total (s)   self (s)
    1              0.000001 try
    1   0.000030   0.000009   let [shell, shellslash] = s:use_sh()
                            
    1   0.000033   0.000010   let dict   = exists('a:1') ? s:upgrade(a:1) : {}
    1   0.000019   0.000009   let temps  = { 'result': s:fzf_tempname() }
    1   0.000015   0.000007   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    1              0.000001   try
    1   0.000073   0.000008     let fzf_exec = s:fzf_exec()
    1              0.000001   catch
                                throw v:exception
                              endtry
                            
    1              0.000006   if has('nvim') && !has_key(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
                              endif
    1              0.000005   if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
                              endif
                            
    1              0.000006   if !has_key(dict, 'source') && !empty($FZF_DEFAULT_COMMAND) && !s:is_win
                                let temps.source = s:fzf_tempname()
                                call writefile(s:wrap_cmds(split($FZF_DEFAULT_COMMAND, "\n")), temps.source)
                                let dict.source = (empty($SHELL) ? &shell : $SHELL).' '.fzf#shellescape(temps.source)
                              endif
                            
    1              0.000002   if has_key(dict, 'source')
                                let source = dict.source
                                let type = type(source)
                                if type == 1
                                  let prefix = '( '.source.' )|'
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call writefile(source, temps.input)
                                  let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
                                endif
                              else
    1              0.000017     let prefix = ''
    1              0.000003   endif
                            
    1              0.000008   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0)
    1              0.000016   let use_height = has_key(dict, 'down') && !has('gui_running') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) && executable('tput') && filereadable('/dev/tty')
    1              0.000030   let has_vim8_term = has('terminal') && has('patch-8.0.995')
    1              0.000011   let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
    1              0.000012   let use_term = has_nvim_term || has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || !use_height && s:present(dict, 'down', 'up', 'left', 'right', 'window'))
    1              0.000024   let use_tmux = (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:tmux_enabled() && s:splittable(dict)
    1              0.000004   if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
                              endif
    1              0.000002   if use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
                              elseif use_term
    1              0.000003     let optstr .= ' --no-height'
    1              0.000000   endif
    1              0.000008   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
    1              0.000001   if use_term
    1   0.043491   0.000051     return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
                            finally
    1              0.000014   let [&shell, &shellslash] = [shell, shellslash]
    1              0.000004 endtry

FUNCTION  phpcd#GetMethodStack()
Called 2 times
Total time:   0.000780
 Self time:   0.000780

count  total (s)   self (s)
    2              0.000005 	let methodstack = []
    2              0.000002 	let i = 0
    2              0.000006 	let end = len(a:line)
                            
    2              0.000002 	let current_part = ''
                            
    2              0.000002 	let parent_depth = 0
    2              0.000003 	let in_string = 0
    2              0.000002 	let string_start = ''
                            
    2              0.000002 	let next_char = ''
                            
   17              0.000020 	while i < end
   15              0.000034 		let current_char = a:line[i]
   15              0.000046 		let next_char = i + 1 < end ? a:line[i + 1] : ''
   15              0.000038 		let prev_char = i >= 1 ? a:line[i - 1] : ''
   15              0.000034 		let prev_prev_char = i >= 2 ? a:line[i - 2] : ''
                            
   15              0.000052 		if in_string == 0 && parent_depth == 0 && ((current_char == '-' && next_char == '>') || (current_char == ':' && next_char == ':'))
    2              0.000008 			call add(methodstack, current_part)
    2              0.000003 			let current_part = ''
    2              0.000002 			let i += 2
    2              0.000002 			continue
                            		endif
                            
                            		" if it's looks like a string
   13              0.000028 		if current_char == "'" || current_char == '"'
                            			" and it is not escaped
                            			if prev_char != '\' || (prev_char == '\' && prev_prev_char == '\')
                            				" and we are in a string already
                            				if in_string
                            					" and that string started with this char too
                            					if current_char == string_start
                            						" clear the string mark
                            						let in_string = 0
                            					endif
                            				else " ... and we are not in a string
                            					" set the string mark
                            					let in_string = 1
                            					let string_start = current_char
                            				endif
                            			endif
                            		endif
                            
   13              0.000027 		if !in_string && a:line[i] == '('
                            			let parent_depth += 1
                            		endif
   13              0.000024 		if !in_string && a:line[i] == ')'
                            			let parent_depth -= 1
                            		endif
                            
   13              0.000030 		let current_part .= current_char
   13              0.000015 		let i += 1
   13              0.000008 	endwhile
                            
                            	" add the last remaining part, this can be an empty string and this is expected
                            	" the empty string represents the completion base (which happen to be an empty string)
    2              0.000003 	if current_part != ''
                            		call add(methodstack, current_part)
                            	endif
                            
    2              0.000003 	return methodstack

FUNCTION  <SNR>44_TriggerAbb()
Called 9 times
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
    9              0.000130   if v:version < 703 || ( v:version == 703 && !has('patch489') ) || pumvisible()
                                return ''
                              endif
    9              0.000031   return "\<C-]>"

FUNCTION  <SNR>78_OnBlankLine()
Called 214 times
Total time:   0.033042
 Self time:   0.001265

count  total (s)   self (s)
  214   0.032941   0.001164   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  214   0.789744   0.061043  <SNR>78_OnTextChangedInsertMode()
  788   0.672812             <SNR>58_Highlight_Matching_Pair()
  204   0.568592   0.209132  <SNR>78_InvokeCompletion()
 1226   0.343709             <SNR>78_Pyeval()
  391   0.265913   0.017639  <SNR>78_PollCompletion()
    8   0.230113             rpc#request()
  367   0.220209   0.012133  <SNR>72_HighlightEnclosingTagsIfPossible()
  367   0.208076   0.028052  <SNR>72_HighlightEnclosingTags()
    1   0.181994   0.000037  nerdtree#ui_glue#invokeKeyMap()
    1   0.181957   0.000109  77()
  367   0.180024             <SNR>72_GetEnclosingTagLocations()
    4   0.177348   0.001506  phpcd#CompletePHP()
    1   0.172377   0.000039  76()
    1   0.172338   0.000028  <SNR>39_activateFileNode()
    1   0.172310   0.000047  105()
    1   0.172263   0.000028  122()
    1   0.172179   0.000025  175()
    1   0.172154   0.000045  176()
    1   0.156557   0.006328  15()
    5   0.140383   0.009927  <SNR>9_SynSet()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  788              0.672812  <SNR>58_Highlight_Matching_Pair()
 1226              0.343709  <SNR>78_Pyeval()
    8              0.230113  rpc#request()
  204   0.568592   0.209132  <SNR>78_InvokeCompletion()
  367              0.180024  <SNR>72_GetEnclosingTagLocations()
   71   0.115193   0.110282  <SNR>78_OnFileReadyToParse()
 1422              0.072314  lightline#link()
  214              0.071274  <SNR>78_InsideCommentOrString()
  214   0.789744   0.061043  <SNR>78_OnTextChangedInsertMode()
  807   0.046778   0.041490  <SNR>78_AllowedToCompleteInBuffer()
   62   0.045837   0.035958  131()
  300   0.054146   0.034613  <SNR>78_OnCursorMovedNormalMode()
   48              0.032408  <SNR>78_UpdateMatches()
   53   0.068045   0.031676  <SNR>73_line()
  367   0.208076   0.028052  <SNR>72_HighlightEnclosingTags()
  216              0.020604  <SNR>78_OnCompleteDone()
   23   0.063406   0.018278  <SNR>78_OnBufferEnter()
  391   0.265913   0.017639  <SNR>78_PollCompletion()
  106   0.025909   0.015630  <SNR>73_expand()
   15   0.038548   0.015412  <SNR>78_OnInsertLeave()

